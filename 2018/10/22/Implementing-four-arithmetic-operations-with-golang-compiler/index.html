<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>用Golang实现四则运算 - 编译篇 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="编译原理,Golang"><meta name="description" content="&lt;p&gt;Yui的编译过程分为以下几个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理&lt;/li&gt;
&lt;li&gt;词法分析&lt;/li&gt;
&lt;li&gt;语法分析&lt;/li&gt;
&lt;li&gt;语义分析&lt;/li&gt;
&lt;li&gt;将指令列表序列化为字节码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们详细的了解一下每一个步骤的具体工作&lt;/p&gt;
&lt;h1 id=&#34;预处理&#34;&gt;&lt;a href=&#34;#预处理&#34; class=&#34;headerlink&#34; title=&#34;预处理&#34;&gt;&lt;/a&gt;预处理&lt;/h1&gt;&lt;p&gt;预处理主要完成以下几个工作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移除源代码中所有的注释信息&lt;/li&gt;
&lt;li&gt;获取源代码中所有的&lt;code&gt;define&lt;/code&gt;代码，解析出define的key和value并把它们的映射关系保存在内存中&lt;/li&gt;
&lt;li&gt;移除所有的define代码&lt;/li&gt;
&lt;li&gt;移除所有的停用词&lt;/li&gt;
&lt;li&gt;根据之前已经获取到的映射关系，把源代码中所有的被定义关键字替换为其相应的值&lt;/li&gt;
&lt;li&gt;从源代码中解析出所有的表达式（多个表达式的情况下每个表达式用 &lt;code&gt;&amp;#123;&amp;#125;&lt;/code&gt; 进行包裹）&lt;/li&gt;
&lt;/"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">用Golang实现四则运算 - 编译篇</h1></div><div class="post-meta"><span class="post-time">2018-10-22</span></div><div class="post-content"><p>Yui的编译过程分为以下几个阶段：</p><ul><li>预处理</li><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>将指令列表序列化为字节码</li></ul><p>下面我们详细的了解一下每一个步骤的具体工作</p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>预处理主要完成以下几个工作：</p><ul><li>移除源代码中所有的注释信息</li><li>获取源代码中所有的<code>define</code>代码，解析出define的key和value并把它们的映射关系保存在内存中</li><li>移除所有的define代码</li><li>移除所有的停用词</li><li>根据之前已经获取到的映射关系，把源代码中所有的被定义关键字替换为其相应的值</li><li>从源代码中解析出所有的表达式（多个表达式的情况下每个表达式用 <code>&#123;&#125;</code> 进行包裹）</li></ul><p>更多详细的信息可以查看预处理过程的<a target="_blank" rel="noopener" href="https://github.com/RitterHou/yui/blob/master/compiler/preprocessor.go#L65">源码</a>进行进一步的了解。同时需要注意的是，预处理过程可能会生成多个表达式，而词法分析、语法分析、语义分析都是只针对单个表达式进行的。</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>词法分析比较简单，只需要把表达式解析为token的列表，token包括以下几种类型：</p><ul><li>(</li><li>)</li><li>+</li><li>-</li><li>*</li><li>&#x2F;</li><li>浮点数</li><li>整数</li></ul><p>token的解析使用正则表达式而不是手动的创建DFA和NFA，经过词法分析之后原始的字符串被分割为一个token列表，词法分析的源码在<a target="_blank" rel="noopener" href="https://github.com/RitterHou/yui/blob/master/compiler/lexer.go#L8">这里</a>。</p><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>语法分析的目的是把词法分析所得到的token列表转化为一棵抽象语法树（Abstract Syntax Tree，AST）。例如对于表达式</p><pre><code>(1 + 2) * (3 - 4)
</code></pre><p>由于我们使用的是中缀表达式，所以应该生成一棵如下的AST</p><p><img src="/images/20181022/ast.png"></p><p>这里生成AST的难点在于运算规则的优先级，表达式运算有如下的三个优先级</p><ol><li>括号：最高的优先级</li><li>乘除法：中等的优先级</li><li>加减法：最低的优先级</li></ol><p>我们分别使用了不同的方法对应不同的优先级计算，计算加减法的方法在最外层，计算乘除法的方法在中间一层，最内部的方法解析括号内的表达式和负数。通过不断地读入token，这三个方法递归的执行，最终生成一棵AST。语法分析的源码在<a target="_blank" rel="noopener" href="https://github.com/RitterHou/yui/blob/master/compiler/parser.go#L68">这里</a>。</p><h1 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h1><p>在上一步我们已经得到了一棵AST，在语义分析中我们将遍历这棵树并且生成指令列表。我们使用递归的方式来遍历整棵树，在遍历的过程中我们把访问到的每个节点都创建为一条指令，然后把这条指令添加到指令列表中。</p><p>指令分为两类，一类是数值指令，一类是计算指令。所有的叶子节点都是数值指令，所有的内部节点都是计算指令。例如，对于上面那棵语法树，它可以生成如下的指令列表</p><pre><code>PUSH 1
PUSH 2
PLUS
PUSH 3
PUSH 4
MINUS
MULTIPLY
</code></pre><p>语义分析的源码在<a target="_blank" rel="noopener" href="https://github.com/RitterHou/yui/blob/master/compiler/semantic.go#L68">这里</a>。</p><h1 id="将指令列表序列化为字节码"><a href="#将指令列表序列化为字节码" class="headerlink" title="将指令列表序列化为字节码"></a>将指令列表序列化为字节码</h1><p>在上一步的语义分析中我们已经得到了最终的指令列表，但是指令本身需要经过序列化才可以进行保存和传输，下面我们看看如何把指令列表进行序列化。</p><p>由于在源码中可能有多个表达式，所以最终我们在语法分析结束后，得到的可能是包含多个表达式的指令列表。对于每一个表达式的指令列表，我们使用如下方式进行序列化</p><ul><li><p>首先我们对指令进行编码，每一个指令都使用一个字节进行编码，具体编码如下：</p><pre><code>  PUSH       0x00
  PLUS       0x01
  MINUS      0x02
  MULTIPLY   0x03
  DIVIDE     0x04
</code></pre></li><li><p>如果是操作指令，直接把这个指令的编码添加到字节数组中</p></li><li><p>如果是数值指令，除了把PUSH指令添加到字节数组之外，还要把对应的数值也序列化添加到字节数组中</p><ul><li>首先判断数值是整数还是浮点数，在添加数值之前先使用一个字节表示接下来的数值类型（整型或浮点型）</li><li>整数和浮点数使用各自的编码方式进行序列化，再把数字序列化的结果添加到字节数组中</li></ul></li></ul><p>针对每一个表达式进行序列化的源码在<a target="_blank" rel="noopener" href="https://github.com/RitterHou/yui/blob/master/compiler/builder.go#L10">这里</a>。</p><p>在对每一个表达式进行了序列化之后，我们得到了一个字节数组的数组，接下来我们再把所有表达式的序列化结果整合起来</p><ol><li>首先我们把MagicNumber放到字节数组的首部</li><li>取出一个表达式的序列化值，计算出这个字节数组的长度，然后将这个整型的长度转化为字节数组</li><li>把长度的值添加到字节数组中</li><li>把表达式本身添加到字节数组中</li><li>重复步骤 2 ~ 5 直到所有的表达式处理完毕</li></ol><p>通过上面的方式我们生成一个大的字节数组，这就是我们最终生成的结果。</p><p>例如我们有两个表达式A和B，它们生成了两个字节数组A1和B1，那么我们可以构建如下的序列化结果</p><pre><code>[MagicNumber][A1 Length Byte Array][A1][B1 Length Byte Array][B1]
</code></pre><p>在经过了上面这些步骤之后，我们最终把源码编译成了字节码。现在只需要把字节码写入到一个文件中，整个编译就完成了。</p><p>注：Yui还实现了从字节码到指令的转化过程，这是为了让目标文件中的指令更易读。此操作对应的命令为 <code>dec</code>，源码位于<a target="_blank" rel="noopener" href="https://github.com/RitterHou/yui/blob/master/compiler/decompiler.go#L63">这里</a>。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="用Golang实现四则运算 - 编译篇">https://www.nosuchfield.com/2018/10/22/Implementing-four-arithmetic-operations-with-golang-compiler/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Golang/" rel="tag">Golang</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>