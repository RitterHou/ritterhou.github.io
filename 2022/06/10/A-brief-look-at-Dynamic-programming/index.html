<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>简单了解一下动态规划 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="算法,数学"><meta name="description" content="&lt;p&gt;动态规划是一种求最优解的方式，个人了解也不是很深，胡乱写写，算是一点点自己的理解，有不对的地方欢迎批评。动态规划是一种在多个状态间进行转移时，由上一个最优状态推导出下一个最优状态的方式，而上一个最优状态又是由上上个最优状态推导得到的，如此不断向前推进，最后我们只需要知道初始最优状态即可。通过初始最优状态和状态间转移的逻辑和方式，我们就能获得全局最优状态。（是不是感觉有点像数学归纳法？）&lt;/p&gt;
&lt;p&gt;举一个斐波拉契数列的例子，最简单的解法自然是使用递归实现&lt;/p&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">简单了解一下动态规划</h1></div><div class="post-meta"><span class="post-time">2022-06-10</span></div><div class="post-content"><p>动态规划是一种求最优解的方式，个人了解也不是很深，胡乱写写，算是一点点自己的理解，有不对的地方欢迎批评。动态规划是一种在多个状态间进行转移时，由上一个最优状态推导出下一个最优状态的方式，而上一个最优状态又是由上上个最优状态推导得到的，如此不断向前推进，最后我们只需要知道初始最优状态即可。通过初始最优状态和状态间转移的逻辑和方式，我们就能获得全局最优状态。（是不是感觉有点像数学归纳法？）</p><p>举一个斐波拉契数列的例子，最简单的解法自然是使用递归实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fab</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fab(n - <span class="number">1</span>) + fab(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>简单分析就可以发现，以上例子中，很多的数字被重复计算了。例如在计算<code>fab(5)</code>时<code>fab(3)</code>已经被计算了，但是在计算<code>fab(4)</code>时<code>fab(3)</code>又被计算了一遍。因此，我们可以用一个table保存已经计算好的数据，避免重复计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">table = &#123;&#125;</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fab</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> table:</span><br><span class="line">        <span class="keyword">return</span> table[n]</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = fab(n - <span class="number">1</span>) + fab(n - <span class="number">2</span>)</span><br><span class="line">    table[n] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>更改了策略之后，我们发现计算速度快了很多，这其实就是动态规划需要避免的<strong>重叠子问题</strong>，这些重叠子问题的存在导致如果使用暴力穷举会产生很多额外的计算量。动态规划的解决办法就是找到<strong>最优子结构</strong>，通过不断的在最优子结构之间进行状态转移，最终得到最优解，而这个状态转移逻辑就称为<strong>状态转移方程</strong>。</p><p>再次观察可以知道，其实斐波拉契数列的计算只依赖于当前的值的前两个值，所以我们并不需要使用一个table来存数据，而只需要存储两个前值变量即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fab</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        tmp = a + b</span><br><span class="line">        a = b</span><br><span class="line">        b = tmp</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><p>从上面我们就可以知道，其实斐波拉契数列的计算过程就是一个使用最优子结构和状态转移方程还有初始状态，最终获得全局最优解的过程。下面再看一个跳台阶的例子</p><blockquote><p>有一个楼梯，一次可以跳1个台阶或者2个台阶，问跳n个台阶一共有多少种跳法</p></blockquote><p>上面的问题看似无从着手，但是如果使用上面的动态规划思想思索一下就可以想到，跳<code>n</code>个台阶的跳法，其实就等于跳<code>n - 1</code>个台阶的跳法数目，加上跳<code>n - 2</code>个台阶的跳法数目。为什么可以这样考虑呢，因为跳到最后一个台阶，可能是从第<code>n - 1</code>个台阶跳了一个台阶跳上去的，所以这种情况下只需要考虑<code>n - 1</code>个台阶有多少种跳法即可。当然还有一种可能，是从第<code>n - 2</code>个台阶跳了两个台阶跳上去的，此时只需要考虑<code>n - 2</code>个台阶的跳法数量即可。因此，跳<code>n</code>个台阶的跳法其实就等于<code>n-1</code>和<code>n-2</code>个台阶的跳法之和，即</p><pre><code>DP[n] = DP[n - 1] + DP[n - 2]
</code></pre><p>转移方程确定之后，我们只需要再确定初始状态即可（是不是越发的感觉像数学归纳法了）。简单分析就可以发现，跳1个台阶有1种跳法，跳2个台阶有2种跳法（一次跳2个，或者一次跳1个跳2次）。即</p><pre><code>DP[1] = 1
DP[2] = 2
</code></pre><p>因此我们可以构建如下代码逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">        tmp = a + b</span><br><span class="line">        a = b</span><br><span class="line">        b = tmp</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><p>如上就是一个典型的动态规划解决问题的过程。我们再看一个问题</p><blockquote><p>给k种面值的硬币，面值分别为c1, c2 … ck，每种硬币的数量无限，再给一个总金额amount，问最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回-1</p></blockquote><p>有了上面的训练，这题我们就可以稍微有点思路了。首先我们需要确定状态转移方程，<strong>这里的状态就是总金额</strong>，而状态转移就是金额跟随着硬币的增加而产生的剩余金额变化。要知道amount的最小硬币数，其实我们只需要知道<code>amount - c</code>的最小硬币数，amount的最小硬币数就是<code>amount - c</code>的最小硬币数再加1。但是因为有多个硬币，所以我们还需要对不同的<code>amount - c</code>进行判断，先得到其前置条件的最优解。</p><p>我们可以得到其状态转移方程</p><pre><code>DP[n] = min(DP[n - c1], DP[n - c2] ... DP[n - ck]) + 1
</code></pre><p>其中<code>DP[0] = 0</code>，<code>DP[负数] = -1</code>。由此我们可以构建如下代码逻辑</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">coin_problem</span>(<span class="params">coins, amount</span>):</span><br><span class="line">    coin_problem_table = <span class="built_in">dict</span>()  <span class="comment"># &#123;&quot;金额&quot;:&quot;硬币数&quot;&#125;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> coin_problem_table:</span><br><span class="line">            <span class="keyword">return</span> coin_problem_table[n]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            val = dp(n - coin)  <span class="comment"># 分解为子问题</span></span><br><span class="line">            <span class="keyword">if</span> val == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 没有解，就尝试下一个硬币</span></span><br><span class="line">            <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> res &gt; val:</span><br><span class="line">                res = val  <span class="comment"># 最优子解</span></span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 没有解</span></span><br><span class="line">            res = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += <span class="number">1</span>  <span class="comment"># 加上这次新加的硬币</span></span><br><span class="line">        coin_problem_table[n] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br></pre></td></tr></table></figure><p>以上问题其实是LeetCode的一个<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">零钱兑换问题</a>，如上代码在LeetCode中超过了93%的提交，效率还是不错的。</p><p>上面我们说的都是一维的问题，事实上动态规划时常会以二维数组的形式出现，下面我看一个例子</p><blockquote><p>一个机器人位于一个 m x n 的网格左上角，机器人每次只能向右或向下走一格，问机器人走到右下角有多少种方式？</p></blockquote><p><img src="/images/20220610/robot_maze.png"></p><p>看到了问题，我们就可以开始分析，机器人走到右下角的路径，肯定可以由它到右下角之前的前一个格子的路径推导得到。假设我们把格子都标上坐标，横着的用i表示，竖着的用j表示，显然<code>0 &lt;= i &lt;= m - 1</code>且<code>0 &lt;= j &lt;= n - 1</code>，我们也可以得到DP转移方程</p><pre><code>DP[i][j] = DP[i - 1][j] + DP[i][j - 1]
</code></pre><p>此外，我们可以发现，在最左边一列或者最上面一行的所有方格，其都只有一种走法。即对于最左一列，机器人只能往下走，对于最上面一行，机器人只能往右走，由此我们可以得到初始状态</p><pre><code>DP[0...m - 1][0] = 1
DP[0][0...n - 1] = 1
</code></pre><p>得到了转移方程和初始状态，那么实现代码也就很简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">robot_maze</span>(<span class="params">m, n</span>):</span><br><span class="line">    dp = [[<span class="number">0</span>] * n] * m  <span class="comment"># 创建二维数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):  <span class="comment"># 第一行</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 第一列</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这同样也是LeetCode的<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">一道题目</a>，我的实现超过了91%的时间和60%的内存，效率也还是不错的。</p><p>上面我们介绍了动态规划的思路和解决问题的方式，其中最重要的就是<strong>状态转移</strong>和<strong>初始状态</strong>的确定。通过这些练习，我们对动态规划已经有了一些了解，看起来我们已经熟悉了动态规划了。但事实是动态规划难就难在其变种太多，并且有些问题的状态转移很抽象。遇到这些变种的时候，我们可能很难才能确定状态设计和状态转移方程，这些只能通过不断地去练习刷题才能有所提升。</p><p>本文涉及到的完整代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fab1</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fab1(n - <span class="number">1</span>) + fab1(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">table = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fab2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> table:</span><br><span class="line">        <span class="keyword">return</span> table[n]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = fab2(n - <span class="number">1</span>) + fab2(n - <span class="number">2</span>)</span><br><span class="line">    table[n] = result</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fab3</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        tmp = a + b</span><br><span class="line">        a = b</span><br><span class="line">        b = tmp</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jump</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">        tmp = a + b</span><br><span class="line">        a = b</span><br><span class="line">        b = tmp</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">coin_problem</span>(<span class="params">coins, amount</span>):</span><br><span class="line">    coin_problem_table = <span class="built_in">dict</span>()  <span class="comment"># &#123;&quot;金额&quot;:&quot;硬币数&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> coin_problem_table:</span><br><span class="line">            <span class="keyword">return</span> coin_problem_table[n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            val = dp(n - coin)  <span class="comment"># 分解为子问题</span></span><br><span class="line">            <span class="keyword">if</span> val == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment"># 没有解，就尝试下一个硬币</span></span><br><span class="line">            <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> res &gt; val:</span><br><span class="line">                res = val  <span class="comment"># 最优子解</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 没有解</span></span><br><span class="line">            res = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res += <span class="number">1</span>  <span class="comment"># 加上这次新加的硬币</span></span><br><span class="line"></span><br><span class="line">        coin_problem_table[n] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(amount)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">robot_maze</span>(<span class="params">m, n</span>):</span><br><span class="line">    dp = [[<span class="number">0</span>] * n] * m  <span class="comment"># 创建二维数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):  <span class="comment"># 第一行</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 第一列</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># x = 35</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># start = time.time()</span></span><br><span class="line">    <span class="comment"># print(fab1(x))</span></span><br><span class="line">    <span class="comment"># print(&#x27;fab1 cost: &#123;&#125;ms&#x27;.format((time.time() - start) * 1000))</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># start = time.time()</span></span><br><span class="line">    <span class="comment"># print(fab2(x))</span></span><br><span class="line">    <span class="comment"># print(&#x27;fab2 cost: &#123;&#125;ms&#x27;.format((time.time() - start) * 1000))</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment"># start = time.time()</span></span><br><span class="line">    <span class="comment"># print(fab3(x))</span></span><br><span class="line">    <span class="comment"># print(&#x27;fab3 cost: &#123;&#125;ms&#x27;.format((time.time() - start) * 1000))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(jump(7))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(coin_problem([186, 419, 83, 408], 6249))</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(robot_maze(<span class="number">3</span>, <span class="number">7</span>))</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78220312">如何学好动态规划</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23995189/answer/1094101149">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 帅地的回答 - 知乎</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="简单了解一下动态规划">https://www.nosuchfield.com/2022/06/10/A-brief-look-at-Dynamic-programming/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6/" rel="tag">数学</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>