<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>常见排序算法的原理和实现 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="算法,数据结构"><meta name="description" content="&lt;h2 id=&#34;冒泡排序&#34;&gt;&lt;a href=&#34;#冒泡排序&#34; class=&#34;headerlink&#34; title=&#34;冒泡排序&#34;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;冒泡排序的原理很简单，就是每次都把当前无序序列中最大（或者最小）的元素移动到序列的开头（或者结尾），之后再对除该元素之外的剩余序列做同样的操作。当所有的元素都冒泡完毕之后，整个序列就会变得有序。冒泡排序的过程正如它的名字一般，每次都把序列中最大的元素移动到末尾（假设我们选择了这种规则），这种操作就好像水中的泡泡不断地从水中浮到水面一般。&lt;/p&gt;
&lt;p&gt;冒泡排序的实现如下，简单观察就可以知道它的时间复杂度为O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/p&gt;
&lt;figure class=&#34;highlight python&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">常见排序算法的原理和实现</h1></div><div class="post-meta"><span class="post-time">2022-05-27</span></div><div class="post-content"><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序的原理很简单，就是每次都把当前无序序列中最大（或者最小）的元素移动到序列的开头（或者结尾），之后再对除该元素之外的剩余序列做同样的操作。当所有的元素都冒泡完毕之后，整个序列就会变得有序。冒泡排序的过程正如它的名字一般，每次都把序列中最大的元素移动到末尾（假设我们选择了这种规则），这种操作就好像水中的泡泡不断地从水中浮到水面一般。</p><p>冒泡排序的实现如下，简单观察就可以知道它的时间复杂度为O(n<sup>2</sup>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span> - i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>原理上类似于冒泡排序，区别在于冒泡排序比较的是相邻元素的大小，选择排序则会与一个固定的数值进行大小比较，省去了一些没有必要的比较过程。同样是获取一个无序序列的最小值并放到开头，冒泡排序是逐个比较并交换值，而选择排序会以第一个元素作为基准值进行比较，获取到最小值后只需要把最小值和开头元素进行交换即可。</p><p>选择排序实现如下，复杂度为O(n<sup>2</sup>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        min_num_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, length):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_num_index]:</span><br><span class="line">                min_num_index = j</span><br><span class="line">        arr[min_num_index], arr[i] = arr[i], arr[min_num_index]</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是将序列分为两部分，一部分有序，一部分无序。每次从无序序列选择一个元素插入到有序序列中的正确位置，保证有序序列仍然有序，就好像打牌的时候不断地抓牌把牌插入到正确的位置一般。在这里我们把序列的前半段当做有序序列，后半段当做无序序列。</p><p>插入排序实现如下，复杂度为O(n<sup>2</sup>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        value = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> value &lt; arr[j]:  <span class="comment"># 元素向前挪动</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]  <span class="comment"># 全部向后移一位</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = value</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是将两个有序序列合并为一个序列，而合并前的有序序列又可以由两个有序序列合并得到，如此反复最终实现排序。</p><p>归并排序实现如下，复杂度为O(NlogN)</p><figure class="highlight python"><figcaption><span>flat</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_merge_sort</span>(<span class="params">_arr, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 计算中间位置</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 获得左半边的有序序列</span></span><br><span class="line">        _merge_sort(_arr, left, mid)</span><br><span class="line">        <span class="comment"># 获得右半边的有序序列</span></span><br><span class="line">        _merge_sort(_arr, mid + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        tmp = []</span><br><span class="line">        i = left</span><br><span class="line">        j = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">or</span> j &lt;= right:  <span class="comment"># 遍历</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; mid:  <span class="comment"># i已经到了尽头，只存j</span></span><br><span class="line">                tmp.append(_arr[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; right:  <span class="comment"># j已经到了尽头，只存i</span></span><br><span class="line">                tmp.append(_arr[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 取较小的那个值</span></span><br><span class="line">            <span class="keyword">if</span> _arr[i] &lt; _arr[j]:</span><br><span class="line">                tmp.append(_arr[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.append(_arr[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        _arr[left: right + <span class="number">1</span>] = tmp  <span class="comment"># 将这一段序列设为有序</span></span><br><span class="line"></span><br><span class="line">    _merge_sort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序和归并排序类似，都是使用分治法。区别在于归并排序是先创建两个有序的子序列，而快速排序是随机选取一个主元（pivot），然后将大于该元素的值放在其右边，小于该元素的值放在其左边。如此反复，最终序列就变得有序了。</p><p>快速排序实现如下，复杂度为O(NlogN)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_quick_sort</span>(<span class="params">_arr, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pivot = random.randint(left, right)  <span class="comment"># 随机一个pivot</span></span><br><span class="line">        _arr[pivot], _arr[right] = _arr[right], _arr[pivot]  <span class="comment"># 把这个值放到最右边</span></span><br><span class="line">        j = left</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">            <span class="keyword">if</span> _arr[i] &lt; _arr[right]:  <span class="comment"># 如果当前这个值小于pivot对应的值</span></span><br><span class="line">                _arr[i], _arr[j] = _arr[j], _arr[i]  <span class="comment"># 将这个值放到左边去</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        _arr[j], _arr[right] = _arr[right], _arr[j]  <span class="comment"># 最后把这个值放在小值和大值的中间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对左右两边的值进行分治</span></span><br><span class="line">        _quick_sort(_arr, left, j - <span class="number">1</span>)</span><br><span class="line">        _quick_sort(_arr, j + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">    _quick_sort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="包含所有排序算法和测试的完整代码如下"><a href="#包含所有排序算法和测试的完整代码如下" class="headerlink" title="包含所有排序算法和测试的完整代码如下"></a>包含所有排序算法和测试的完整代码如下</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">time_log=<span class="literal">True</span>, result_log=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            start = time.time()</span><br><span class="line">            result = func(*args, **kw)</span><br><span class="line">            end = time.time()</span><br><span class="line">            <span class="keyword">if</span> time_log:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;&#123;:&gt;12&#125;: &#123;:&gt;7.2f&#125;ms&#x27;</span>.<span class="built_in">format</span>(func.__name__, (end - start) * <span class="number">1000</span>))</span><br><span class="line">            <span class="keyword">if</span> result_log:</span><br><span class="line">                <span class="built_in">print</span>(result, end=<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log(<span class="params">result_log=<span class="literal">True</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_array</span>(<span class="params">start=<span class="number">0</span>, end=<span class="number">1000</span>, length=<span class="number">500</span></span>):</span><br><span class="line">    <span class="keyword">if</span> start &gt;= end <span class="keyword">or</span> length &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    random_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        random_list.append(random.randint(start, end))</span><br><span class="line">    <span class="keyword">return</span> random_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span> - i):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j + <span class="number">1</span>]:</span><br><span class="line">                arr[j], arr[j + <span class="number">1</span>] = arr[j + <span class="number">1</span>], arr[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">        min_num_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, length):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_num_index]:</span><br><span class="line">                min_num_index = j</span><br><span class="line">        arr[min_num_index], arr[i] = arr[i], arr[min_num_index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">        value = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> value &lt; arr[j]:  <span class="comment"># 元素向前挪动</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]  <span class="comment"># 全部向后移一位</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_merge_sort</span>(<span class="params">_arr, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 计算中间位置</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="comment"># 获得左半边的有序序列</span></span><br><span class="line">        _merge_sort(_arr, left, mid)</span><br><span class="line">        <span class="comment"># 获得右半边的有序序列</span></span><br><span class="line">        _merge_sort(_arr, mid + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        tmp = []</span><br><span class="line">        i = left</span><br><span class="line">        j = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= mid <span class="keyword">or</span> j &lt;= right:  <span class="comment"># 遍历</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; mid:  <span class="comment"># i已经到了尽头，只存j</span></span><br><span class="line">                tmp.append(_arr[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> j &gt; right:  <span class="comment"># j已经到了尽头，只存i</span></span><br><span class="line">                tmp.append(_arr[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 取较小的那个值</span></span><br><span class="line">            <span class="keyword">if</span> _arr[i] &lt; _arr[j]:</span><br><span class="line">                tmp.append(_arr[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.append(_arr[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        _arr[left: right + <span class="number">1</span>] = tmp  <span class="comment"># 将这一段序列设为有序</span></span><br><span class="line"></span><br><span class="line">    _merge_sort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@log()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_quick_sort</span>(<span class="params">_arr, left, right</span>):</span><br><span class="line">        <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        pivot = random.randint(left, right)  <span class="comment"># 随机一个pivot</span></span><br><span class="line">        _arr[pivot], _arr[right] = _arr[right], _arr[pivot]  <span class="comment"># 把这个值放到最右边</span></span><br><span class="line">        j = left</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">            <span class="keyword">if</span> _arr[i] &lt; _arr[right]:  <span class="comment"># 如果当前这个值小于pivot对应的值</span></span><br><span class="line">                _arr[i], _arr[j] = _arr[j], _arr[i]  <span class="comment"># 将这个值放到左边去</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        _arr[j], _arr[right] = _arr[right], _arr[j]  <span class="comment"># 最后把这个值放在小值和大值的中间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对左右两边的值进行分治</span></span><br><span class="line">        _quick_sort(_arr, left, j - <span class="number">1</span>)</span><br><span class="line">        _quick_sort(_arr, j + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">    _quick_sort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    random_array = get_array()</span><br><span class="line"></span><br><span class="line">    array1 = copy.deepcopy(random_array)</span><br><span class="line">    bubble_sort(array1)</span><br><span class="line"></span><br><span class="line">    array2 = copy.deepcopy(random_array)</span><br><span class="line">    select_sort(array2)</span><br><span class="line"></span><br><span class="line">    array3 = copy.deepcopy(random_array)</span><br><span class="line">    insert_sort(array3)</span><br><span class="line"></span><br><span class="line">    array4 = copy.deepcopy(random_array)</span><br><span class="line">    merge_sort(array4)</span><br><span class="line"></span><br><span class="line">    array5 = copy.deepcopy(random_array)</span><br><span class="line">    quick_sort(array5)</span><br></pre></td></tr></table></figure><p>执行结果如下</p><pre><code>   get_array:    1.08ms
[606, 969, 12, 732, 279, 820, 962, 752, 989, 594, 789, 83, 818, 555, 872, 266, 863, 800, 953, 879, 371, 685, 171, 325, 868, 141, 209, 581, 660, 252, 426, 731, 672, 360, 913, 427, 44, 272, 399, 291, 492, 957, 921, 315, 65, 10, 745, 343, 832, 144, 550, 403, 634, 579, 863, 164, 730, 562, 487, 23, 755, 957, 906, 378, 656, 18, 337, 446, 315, 36, 530, 826, 788, 384, 687, 760, 769, 161, 424, 57, 572, 506, 954, 192, 765, 111, 184, 732, 220, 602, 815, 930, 915, 284, 347, 441, 530, 378, 938, 246, 434, 848, 334, 259, 535, 747, 125, 137, 77, 881, 403, 390, 758, 298, 268, 440, 428, 793, 871, 364, 688, 180, 184, 957, 398, 300, 336, 981, 212, 650, 986, 742, 182, 553, 149, 898, 805, 796, 489, 727, 253, 333, 512, 464, 310, 688, 241, 533, 49, 31, 338, 500, 359, 403, 328, 277, 259, 844, 4, 802, 715, 209, 889, 596, 177, 521, 707, 435, 970, 960, 800, 990, 749, 833, 837, 845, 993, 585, 961, 783, 649, 677, 134, 517, 784, 491, 974, 668, 442, 200, 692, 549, 506, 951, 175, 292, 585, 98, 637, 561, 178, 500, 673, 812, 22, 893, 701, 216, 575, 642, 183, 814, 544, 926, 280, 683, 3, 588, 743, 815, 707, 88, 666, 886, 775, 861, 421, 542, 204, 469, 462, 698, 698, 893, 748, 576, 154, 372, 253, 120, 377, 549, 415, 492, 613, 377, 160, 325, 960, 245, 581, 697, 782, 663, 431, 71, 83, 484, 283, 454, 913, 219, 192, 77, 202, 184, 733, 775, 582, 945, 7, 445, 143, 909, 507, 600, 189, 158, 19, 800, 304, 61, 874, 945, 763, 452, 996, 667, 70, 705, 953, 877, 864, 57, 467, 320, 361, 543, 645, 749, 312, 821, 139, 176, 667, 908, 506, 943, 738, 167, 267, 803, 502, 40, 598, 699, 40, 259, 74, 28, 761, 482, 200, 402, 784, 878, 189, 405, 384, 260, 248, 354, 265, 26, 89, 685, 964, 618, 546, 424, 604, 339, 621, 343, 68, 401, 534, 69, 476, 826, 747, 497, 594, 553, 863, 238, 856, 787, 723, 18, 680, 797, 945, 822, 455, 0, 822, 245, 715, 184, 399, 597, 78, 780, 913, 85, 825, 873, 969, 550, 776, 729, 704, 582, 227, 723, 923, 120, 104, 207, 885, 977, 66, 393, 672, 236, 812, 85, 659, 36, 900, 46, 763, 481, 806, 545, 974, 312, 757, 66, 538, 689, 806, 632, 284, 717, 358, 490, 375, 873, 203, 601, 276, 121, 544, 16, 450, 310, 255, 274, 232, 520, 822, 908, 806, 254, 357, 365, 41, 967, 258, 894, 174, 764, 656, 906, 212, 362, 154, 371, 836, 365, 237, 651, 767, 126, 85, 361, 434, 399, 58, 362, 846, 343, 293, 492, 172, 451, 962, 293, 100, 777, 28, 788, 179, 10, 292, 53, 479, 126, 0, 433, 850, 525, 723, 276, 611, 66, 401, 536, 570, 798, 231, 993, 222, 171, 737, 961, 222, 430]

 bubble_sort:  181.51ms
 select_sort:   51.87ms
 insert_sort:   29.96ms
  merge_sort:    3.12ms
  quick_sort:    2.97ms
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://ayay.xyz/posts/2021/20211119.html">十大常见排序算法</a><br><a target="_blank" rel="noopener" href="https://jacktang816.github.io/post/sort/">常见的基本排序算法</a><br><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a><br><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">Comparison Sorting Algorithms</a><br><a target="_blank" rel="noopener" href="https://visualgo.net/">VisuAlgo</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="常见排序算法的原理和实现">https://www.nosuchfield.com/2022/05/27/Principles-and-implementation-of-common-sorting-algorithms/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>