<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>《推荐系统实践》 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="算法,机器学习,读书笔记,推荐系统,数据挖掘"><meta name="description" content="&lt;blockquote&gt;
&lt;p&gt;从某种意义上说，推荐系统和搜索引擎对于用户来说是两个互补的工具。搜索引擎满足了用户有明确目的时的主动查找需求，而推荐系统能够在用户没有明确目的的时候帮助他们发现感兴趣的新内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;基于用户行为分析的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法称为协同过滤（Collaborative filtering）算法。顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;用户行为分类&#34;&gt;&lt;a href=&#34;#用户行为分类&#34; class=&#34;headerlink&#34; title=&#34;用户行为分类&#34;&gt;&lt;/a&gt;用户行为分类&lt;/h2&gt;&lt;p&gt;用户行为在个性化推荐系统中一般分两种——显性反馈行为（explicit feedback）和隐性反馈行为（implicit feedback）。显示反馈行为是用户主动做的，比如给视频点赞、给书籍打分等等；隐式反馈行为的代表就"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">《推荐系统实践》</h1></div><div class="post-meta"><span class="post-time">2025-06-22</span></div><div class="post-content"><blockquote><p>从某种意义上说，推荐系统和搜索引擎对于用户来说是两个互补的工具。搜索引擎满足了用户有明确目的时的主动查找需求，而推荐系统能够在用户没有明确目的的时候帮助他们发现感兴趣的新内容。</p></blockquote><blockquote><p>基于用户行为分析的推荐算法是个性化推荐系统的重要算法，学术界一般将这种类型的算法称为协同过滤（Collaborative filtering）算法。顾名思义，协同过滤就是指用户可以齐心协力，通过不断地和网站互动，使自己的推荐列表能够不断过滤掉自己不感兴趣的物品，从而越来越满足自己的需求。</p></blockquote><h2 id="用户行为分类"><a href="#用户行为分类" class="headerlink" title="用户行为分类"></a>用户行为分类</h2><p>用户行为在个性化推荐系统中一般分两种——显性反馈行为（explicit feedback）和隐性反馈行为（implicit feedback）。显示反馈行为是用户主动做的，比如给视频点赞、给书籍打分等等；隐式反馈行为的代表就是用户浏览页面，这种行为显示出来的用户偏好不是那么明显，但是数据量更大。</p><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="基于邻域的算法"><a href="#基于邻域的算法" class="headerlink" title="基于邻域的算法"></a>基于邻域的算法</h3><ul><li>基于用户的协同过滤算法 这种算法给用户推荐和他兴趣相似的其他用户喜欢的物品。<ol><li>找到和目标用户兴趣相似的用户集合（P45）。</li><li>找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户。</li></ol></li><li>基于物品的协同过滤算法 这种算法给用户推荐和他之前喜欢的物品相似的物品。<ol><li>计算物品之间的相似度（P53）。</li><li>根据物品的相似度和用户的历史行为给用户生成推荐列表。</li></ol></li></ul><h4 id="基于用户的协同过滤算法"><a href="#基于用户的协同过滤算法" class="headerlink" title="基于用户的协同过滤算法"></a>基于用户的协同过滤算法</h4><p>计算两个用户的兴趣相似程度：给定用户u和用户v，N(u)表示用户u曾经有过正反馈的物品集合，N(v)表示用户v曾经有过正反馈的物品集合。可以使用Jaccard公式计算两个用户的兴趣相似程度</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>w</mi><mrow><mi>u</mi><mi>v</mi></mrow></msub><mo>&#x3D;</mo><mfrac><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></mrow><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></mrow></mfrac></math></p><p>或者使用余弦相似公式计算相似程度</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>w</mi><mrow><mi>u</mi><mi>v</mi></mrow></msub><mo>&#x3D;</mo><mfrac><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></mrow><msqrt><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mrow><mo stretchy="false">|</mo></mrow><mrow><mo stretchy="false">|</mo></mrow><mi>N</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></msqrt></mfrac></math></p><p>以余弦相似公式为例，假设有用户ABCD，物品abcde，用户喜欢的物品如下</p><table><thead><tr><th>用户</th><th>物品 a</th><th>物品 b</th><th>物品 c</th><th>物品 d</th><th>物品 e</th></tr></thead><tbody><tr><td>A</td><td>☑️</td><td>☑️</td><td></td><td>☑️</td><td></td></tr><tr><td>B</td><td>☑️</td><td></td><td>☑️</td><td></td><td></td></tr><tr><td>C</td><td></td><td>☑️</td><td></td><td></td><td>☑️</td></tr><tr><td>D</td><td></td><td></td><td>☑️</td><td>☑️</td><td>☑️</td></tr></tbody></table><p>那么我们可以得到用户A和BCD的相似度</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>w</mi><mrow><mi>A</mi><mi>B</mi></mrow></msub><mo>&#x3D;</mo><mfrac><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mo fence="false" stretchy="false">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo fence="false" stretchy="false">}</mo><mo>∩</mo><mo fence="false" stretchy="false">{</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo fence="false" stretchy="false">}</mo><mo data-mjx-texclass="CLOSE">|</mo></mrow><msqrt><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mo fence="false" stretchy="false">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo fence="false" stretchy="false">}</mo><mo data-mjx-texclass="CLOSE">|</mo></mrow><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mo fence="false" stretchy="false">{</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo fence="false" stretchy="false">}</mo><mo data-mjx-texclass="CLOSE">|</mo></mrow></msqrt></mfrac><mo>&#x3D;</mo><mfrac><mn>1</mn><msqrt><mn>6</mn></msqrt></mfrac></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>w</mi><mrow><mi>A</mi><mi>C</mi></mrow></msub><mo>&#x3D;</mo><mfrac><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mo fence="false" stretchy="false">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo fence="false" stretchy="false">}</mo><mo>∩</mo><mo fence="false" stretchy="false">{</mo><mi>b</mi><mo>,</mo><mi>e</mi><mo fence="false" stretchy="false">}</mo><mo data-mjx-texclass="CLOSE">|</mo></mrow><msqrt><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mo fence="false" stretchy="false">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo fence="false" stretchy="false">}</mo><mo data-mjx-texclass="CLOSE">|</mo></mrow><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mo fence="false" stretchy="false">{</mo><mi>b</mi><mo>,</mo><mi>e</mi><mo fence="false" stretchy="false">}</mo><mo data-mjx-texclass="CLOSE">|</mo></mrow></msqrt></mfrac><mo>&#x3D;</mo><mfrac><mn>1</mn><msqrt><mn>6</mn></msqrt></mfrac><mspace linebreak="newline"></mspace></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>w</mi><mrow><mi>A</mi><mi>D</mi></mrow></msub><mo>&#x3D;</mo><mfrac><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mo fence="false" stretchy="false">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo fence="false" stretchy="false">}</mo><mo>∩</mo><mo fence="false" stretchy="false">{</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo>,</mo><mi>e</mi><mo fence="false" stretchy="false">}</mo><mo data-mjx-texclass="CLOSE">|</mo></mrow><msqrt><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mo fence="false" stretchy="false">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>d</mi><mo fence="false" stretchy="false">}</mo><mo data-mjx-texclass="CLOSE">|</mo></mrow><mrow data-mjx-texclass="INNER"><mo data-mjx-texclass="OPEN">|</mo><mo fence="false" stretchy="false">{</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo>,</mo><mi>e</mi><mo fence="false" stretchy="false">}</mo><mo data-mjx-texclass="CLOSE">|</mo></mrow></msqrt></mfrac><mo>&#x3D;</mo><mfrac><mn>1</mn><mn>3</mn></mfrac></math></p><p>具体计算过程以AD的相似度计算为例</p><ol><li>分子为交集并且交集为 <code>&#123;d&#125;</code>，<code>|&#123;d&#125;| = 1</code>，所以分子为1</li><li>分母为并集，<code>3 x 3 = 9</code>，开根号为3<br>最终值为 <code>1 / 3</code></li></ol><p>以上逻辑可以用代码进行实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">similarity</span>(<span class="params">users</span>):</span><br><span class="line">    w = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> combinations(users.keys(), <span class="number">2</span>):</span><br><span class="line">        r1 = <span class="built_in">len</span>(users[u] &amp; users[v])</span><br><span class="line">        r2 = math.sqrt(<span class="built_in">len</span>(users[u]) * <span class="built_in">len</span>(users[v]) * <span class="number">1.0</span>)</span><br><span class="line">        r = r1 / r2</span><br><span class="line">        w[u][v], w[v][u] = r, r  <span class="comment"># 保存两次，方便后面使用</span></span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    users = &#123;</span><br><span class="line">        <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> similarity(users).items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>: <span class="subst">&#123;json.dumps(v)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行后得到结果如下</p><pre><code>A: &#123;&quot;B&quot;: 0.4082482904638631, &quot;C&quot;: 0.4082482904638631, &quot;D&quot;: 0.3333333333333333&#125;
B: &#123;&quot;A&quot;: 0.4082482904638631, &quot;C&quot;: 0.0, &quot;D&quot;: 0.4082482904638631&#125;
C: &#123;&quot;A&quot;: 0.4082482904638631, &quot;B&quot;: 0.0, &quot;D&quot;: 0.4082482904638631&#125;
D: &#123;&quot;A&quot;: 0.3333333333333333, &quot;B&quot;: 0.4082482904638631, &quot;C&quot;: 0.4082482904638631&#125;
</code></pre><p>据此我们就可以得到各个用户之间的兴趣相似度了。有了用户兴趣的相似度之后，我们可以给用户推荐和他兴趣最相似的K个用户喜欢的物品。我们可以使用如下公式计算用户u对物品i的感兴趣程度</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>p</mi><mo stretchy="false">(</mo><mi>u</mi><mo>,</mo><mi>i</mi><mo stretchy="false">)</mo><mo>&#x3D;</mo><munder><mo data-mjx-texclass="OP">∑</mo><mrow><mi>v</mi><mo>∈</mo><mi>S</mi><mo stretchy="false">(</mo><mi>u</mi><mo>,</mo><mi>K</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>N</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></munder><msub><mi>w</mi><mrow><mi>u</mi><mi>v</mi></mrow></msub><msub><mi>r</mi><mrow><mi>v</mi><mi>i</mi></mrow></msub></math></p><p>其中，S(u, K)包含和用户u兴趣最接近的K个用户，N(i)是对物品i有过行为的用户集合，w<sub>uv</sub>是用户u和用户v的兴趣相似度，r<sub>vi</sub>代表用户v对物品i的兴趣，因为使用的是单一行为的隐反馈数据，所以所有的r<sub>vi</sub>&#x3D;1。</p><p>具体的逻辑实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recommend</span>(<span class="params">user, users, w, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param user: 计算指定用户的物品推荐程度</span></span><br><span class="line"><span class="string">    :param users: 数据集</span></span><br><span class="line"><span class="string">    :param w: 前一步计算得到的用户兴趣相似度</span></span><br><span class="line"><span class="string">    :param k: 取k个兴趣最相似的用户</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    rank = defaultdict(<span class="built_in">float</span>)</span><br><span class="line">    <span class="comment"># 获取指定用户和其它用户的兴趣相似度，并按照相似度从大到小排序，取前k个数据</span></span><br><span class="line">    <span class="keyword">for</span> v, wuv <span class="keyword">in</span> <span class="built_in">sorted</span>(w[user].items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:k]:</span><br><span class="line">        <span class="comment"># 取出指定用户的数据集</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> users[v]:</span><br><span class="line">            <span class="comment"># 如果这个数据已经在当前用户的数据集里面，跳过，因为已经感兴趣的数据不需要再次推荐</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> users[user]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            rank[i] += wuv</span><br><span class="line">    <span class="keyword">return</span> rank</span><br></pre></td></tr></table></figure><p>通过这个代码我们就可以计算得到指定用户的物品推荐程度了。完整的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">similarity</span>(<span class="params">users</span>):</span><br><span class="line">    w = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> combinations(users.keys(), <span class="number">2</span>):</span><br><span class="line">        r1 = <span class="built_in">len</span>(users[u] &amp; users[v])</span><br><span class="line">        r2 = math.sqrt(<span class="built_in">len</span>(users[u]) * <span class="built_in">len</span>(users[v]) * <span class="number">1.0</span>)</span><br><span class="line">        r = r1 / r2</span><br><span class="line">        w[u][v], w[v][u] = r, r  <span class="comment"># 保存两次，方便后面使用</span></span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recommend</span>(<span class="params">user, users, w, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param user: 计算指定用户的物品推荐程度</span></span><br><span class="line"><span class="string">    :param users: 数据集</span></span><br><span class="line"><span class="string">    :param w: 前一步计算得到的用户兴趣相似度</span></span><br><span class="line"><span class="string">    :param k: 取k个兴趣最相似的用户</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    rank = defaultdict(<span class="built_in">float</span>)</span><br><span class="line">    <span class="comment"># 获取指定用户和其它用户的兴趣相似度，并按照相似度从大到小排序，取前k个数据</span></span><br><span class="line">    <span class="keyword">for</span> v, wuv <span class="keyword">in</span> <span class="built_in">sorted</span>(w[user].items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:k]:</span><br><span class="line">        <span class="comment"># 取出指定用户的数据集</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> users[v]:</span><br><span class="line">            <span class="comment"># 如果这个数据已经在当前用户的数据集里面，跳过，因为已经感兴趣的数据不需要再次推荐</span></span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> users[user]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            rank[i] += wuv</span><br><span class="line">    <span class="keyword">return</span> rank</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    users = &#123;</span><br><span class="line">        <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w = similarity(users)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> w.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>: <span class="subst">&#123;json.dumps(v)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    rank = recommend(<span class="string">&#x27;C&#x27;</span>, users, w, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">sorted</span>(rank.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>: <span class="subst">&#123;v&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>执行代码得到的结果如下</p><pre><code>A: &#123;&quot;B&quot;: 0.4082482904638631, &quot;C&quot;: 0.4082482904638631, &quot;D&quot;: 0.3333333333333333&#125;
B: &#123;&quot;A&quot;: 0.4082482904638631, &quot;C&quot;: 0.0, &quot;D&quot;: 0.4082482904638631&#125;
C: &#123;&quot;A&quot;: 0.4082482904638631, &quot;B&quot;: 0.0, &quot;D&quot;: 0.4082482904638631&#125;
D: &#123;&quot;A&quot;: 0.3333333333333333, &quot;B&quot;: 0.4082482904638631, &quot;C&quot;: 0.4082482904638631&#125;
d: 0.8164965809277261
a: 0.4082482904638631
c: 0.4082482904638631
</code></pre><p>由上面的结果我们可以知道，针对用户<code>C</code>，最推荐的物品是物品<code>d</code>。</p><p>根据上面的例子我们已经简单了解了基于用户的协同过滤算法，不过这种算法存在问题，主要是</p><ol><li>随着网站的用户数目越来越大，计算用户兴趣相似度矩阵将越来越困难，其运算时间复杂度和空间复杂度的增长和用户数的增长近似于平方关系</li><li>基于用户的协同过滤很难对推荐结果作出解释</li></ol><p>因此，在实际的使用中，更常见的是<em>基于物品的协同过滤算法</em></p><h4 id="基于物品的协同过滤算法"><a href="#基于物品的协同过滤算法" class="headerlink" title="基于物品的协同过滤算法"></a>基于物品的协同过滤算法</h4><p>为了挖掘长尾信息，避免热门物品对推荐产生影响，减小二八定律的出现。可以用如下公式计算物品之间的相似度</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>w</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>&#x3D;</mo><mfrac><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>N</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></mrow><msqrt><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mrow><mo stretchy="false">|</mo></mrow><mstyle scriptlevel="0"><mspace width="thinmathspace"></mspace></mstyle><mrow><mo stretchy="false">|</mo></mrow><mi>N</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></msqrt></mfrac></math></p><p>分子是同时喜欢物品i和物品j的用户数，分母是喜欢两个物品用户数的并集。为了减小计算量，我们可以构建一个矩阵来存储某个用户喜欢的物品集合。</p><p>举个例子，比如用户A喜欢物品 {a, b, d}，那我们可以构建如下矩阵</p><pre><code>    |  a  |  b  |  c  |  d  |  e  |
----|-----|-----|-----|-----|-----|
a   |  0  |  1  |  0  |  1  |  0  |
b   |  1  |  0  |  0  |  1  |  0  |
c   |  0  |  0  |  0  |  0  |  0  |
d   |  1  |  1  |  0  |  0  |  0  |
e   |  0  |  0  |  0  |  0  |  0  |
</code></pre><p>因为a、b、d可以组成ab、ad、bd，所以将矩阵中的对应位置都填上1。这是一个用户的物品信息，对于多个用户，只需要把这些矩阵相加即可。例如有5个用户，他们的物品信息和生成的对应物品矩阵如下</p><p>用户 1: {a, c, d}</p><pre><code>    |  a  |  b  |  c  |  d  |  e  |
----|-----|-----|-----|-----|-----|
a   |  0  |  0  |  1  |  1  |  0  |
b   |  0  |  0  |  0  |  0  |  0  |
c   |  1  |  0  |  0  |  1  |  0  |
d   |  1  |  0  |  1  |  0  |  0  |
e   |  0  |  0  |  0  |  0  |  0  |
</code></pre><p>用户 2: {b, c, e}</p><pre><code>    |  a  |  b  |  c  |  d  |  e  |
----|-----|-----|-----|-----|-----|
a   |  0  |  0  |  0  |  0  |  0  |
b   |  0  |  0  |  1  |  0  |  1  |
c   |  0  |  1  |  0  |  0  |  1  |
d   |  0  |  0  |  0  |  0  |  0  |
e   |  0  |  1  |  1  |  0  |  0  |
</code></pre><p>用户 3: {a, d, e}</p><pre><code>    |  a  |  b  |  c  |  d  |  e  |
----|-----|-----|-----|-----|-----|
a   |  0  |  0  |  0  |  1  |  1  |
b   |  0  |  0  |  0  |  0  |  0  |
c   |  0  |  0  |  0  |  0  |  0  |
d   |  1  |  0  |  0  |  0  |  1  |
e   |  1  |  0  |  0  |  1  |  0  |
</code></pre><p>用户 4: {b, d}</p><pre><code>    |  a  |  b  |  c  |  d  |  e  |
----|-----|-----|-----|-----|-----|
a   |  0  |  0  |  0  |  0  |  0  |
b   |  0  |  0  |  0  |  1  |  0  |
c   |  0  |  0  |  0  |  0  |  0  |
d   |  0  |  1  |  0  |  0  |  0  |
e   |  0  |  0  |  0  |  0  |  0  |
</code></pre><p>用户 5: {a, b, c, e}</p><pre><code>    |  a  |  b  |  c  |  d  |  e  |
----|-----|-----|-----|-----|-----|
a   |  0  |  1  |  1  |  0  |  1  |
b   |  1  |  0  |  1  |  0  |  1  |
c   |  1  |  1  |  0  |  0  |  1  |
d   |  0  |  0  |  0  |  0  |  0  |
e   |  1  |  1  |  1  |  0  |  0  |
</code></pre><p>将这5个用户的物品信息相加，得到矩阵</p><pre><code>    |  a  |  b  |  c  |  d  |  e  |
----|-----|-----|-----|-----|-----|
a   |  0  |  1  |  2  |  3  |  2  |
b   |  1  |  0  |  3  |  2  |  3  |
c   |  2  |  3  |  0  |  2  |  3  |
d   |  3  |  2  |  2  |  0  |  2  |
e   |  2  |  3  |  3  |  2  |  0  |
</code></pre><p>在这个矩阵中值越高，代表物品的相关度越高。接下来我们将这个规则用代码进行实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="string">&#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">item_similarity</span>(<span class="params">train</span>):</span><br><span class="line">    <span class="comment"># c[i][number]表示使用物品i的用户数量</span></span><br><span class="line">    <span class="comment"># c[i][j]表示同时交互物品i和j的用户数</span></span><br><span class="line">    c = defaultdict(<span class="keyword">lambda</span>: defaultdict(<span class="built_in">int</span>))</span><br><span class="line">    <span class="keyword">for</span> user, items <span class="keyword">in</span> train.items():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">            <span class="comment"># 统计每个物品被交互的总次数</span></span><br><span class="line">            c[i][number] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 统计物品i与其他物品的共现次数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> items:</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                c[i][j] += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 计算最终的相似度矩阵 w</span></span><br><span class="line">    w = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">    <span class="keyword">for</span> i, related_items <span class="keyword">in</span> c.items():</span><br><span class="line">        <span class="keyword">for</span> j, cij <span class="keyword">in</span> related_items.items():</span><br><span class="line">            <span class="keyword">if</span> j == number: <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 余弦相似度公式</span></span><br><span class="line">            similarity = cij / math.sqrt(c[i][number] * c[j][number])</span><br><span class="line">            w[i][j] = similarity</span><br><span class="line">    <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure><p>如上我们先计算每个物品各自被用户喜欢的次数，再计算每个物品和其它物品同时被某个用户喜欢的次数，之后根据物品相似度公式即可计算出物品之间的相关性。为了简单起见，如上代码只使用了一个字典变量，物品自己被喜欢的次数被保存在key为<code>number</code>的字段中，物品和其它物品同时被喜欢的次数则保存在key为其它物品ID的字段中。</p><p>有了如上逻辑之后，我们就可以计算物品相似度了，假设有用户如下</p><pre><code>&#123;
  &#39;A&#39;: &#123;&#39;a&#39;, &#39;b&#39;, &#39;d&#39;&#125;,
  &#39;B&#39;: &#123;&#39;a&#39;, &#39;c&#39;&#125;,
  &#39;C&#39;: &#123;&#39;b&#39;, &#39;e&#39;, &#39;a&#39;&#125;,
  &#39;D&#39;: &#123;&#39;c&#39;, &#39;d&#39;, &#39;e&#39;&#125;
&#125;
</code></pre><p>计算得到的物品相似度</p><pre><code>b: &#123;&#39;a&#39;: 0.8164965809277261, &#39;d&#39;: 0.5, &#39;e&#39;: 0.5&#125;
a: &#123;&#39;b&#39;: 0.8164965809277261, &#39;d&#39;: 0.4082482904638631, &#39;c&#39;: 0.4082482904638631, &#39;e&#39;: 0.4082482904638631&#125;
d: &#123;&#39;b&#39;: 0.5, &#39;c&#39;: 0.5, &#39;e&#39;: 0.5, &#39;a&#39;: 0.4082482904638631&#125;
c: &#123;&#39;e&#39;: 0.5, &#39;d&#39;: 0.5, &#39;a&#39;: 0.4082482904638631&#125;
e: &#123;&#39;b&#39;: 0.5, &#39;c&#39;: 0.5, &#39;d&#39;: 0.5, &#39;a&#39;: 0.4082482904638631&#125;
</code></pre><p>可以看到物品a和物品b的相关度是最高的。在得到物品的相关度之后，我们可以使用如下公式计算用户u对一个物品j的兴趣</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>p</mi><mrow><mi>u</mi><mi>j</mi></mrow></msub><mo>&#x3D;</mo><munder><mo data-mjx-texclass="OP">∑</mo><mrow><mi>i</mi><mo>∈</mo><mi>N</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>S</mi><mo stretchy="false">(</mo><mi>j</mi><mo>,</mo><mi>K</mi><mo stretchy="false">)</mo></mrow></munder><msub><mi>w</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub><mstyle scriptlevel="0"><mspace width="thinmathspace"></mspace></mstyle><msub><mi>r</mi><mrow><mi>u</mi><mi>i</mi></mrow></msub></math></p><p>N(u)是用户喜欢的物品集合，S(j, K)是物品j最相似的K个物品的集合，w<sub>ji</sub>是物品j和i的相似度，r<sub>ui</sub>是用户对物品i的兴趣，可令r<sub>ui</sub>为1。我们可以把这个逻辑使用代码进行实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recommend</span>(<span class="params">interacted_items: <span class="type">Union</span>[<span class="built_in">set</span>, <span class="built_in">dict</span>], w, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param interacted_items: 指定用户交互过的物品</span></span><br><span class="line"><span class="string">    :param w: 物品的相似度</span></span><br><span class="line"><span class="string">    :param k: 取最相似的k个物品</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(interacted_items, <span class="built_in">set</span>):  <span class="comment"># 如果只有物品，没有评分，那么将评分统一设置为1</span></span><br><span class="line">        interacted_items = &#123;k: <span class="number">1</span> <span class="keyword">for</span> k <span class="keyword">in</span> interacted_items&#125;</span><br><span class="line">    rank = defaultdict(<span class="built_in">float</span>)</span><br><span class="line">    <span class="comment"># 用户交互过的物品，和用户对这个物品的评分</span></span><br><span class="line">    <span class="keyword">for</span> item, score <span class="keyword">in</span> interacted_items.items():</span><br><span class="line">        <span class="comment"># 物品的相似度信息，得到related_item和item的相似度similarity，按照相似度的值从大到小排序，取k个值</span></span><br><span class="line">        <span class="keyword">for</span> related_item, similarity <span class="keyword">in</span> <span class="built_in">sorted</span>(w[item].items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:k]:</span><br><span class="line">            <span class="comment"># 如果这个物品已经被用户交互过了，跳过</span></span><br><span class="line">            <span class="keyword">if</span> related_item <span class="keyword">in</span> interacted_items:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算相关的物品的相似度评分</span></span><br><span class="line">            rank[related_item] += score * similarity</span><br><span class="line">    <span class="keyword">return</span> rank</span><br></pre></td></tr></table></figure><p>有了计算用户和物品相关度的代码，我们就可以把逻辑结合起来，实现向用户推荐物品了。完整的代码实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line">number = <span class="string">&#x27;number&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">item_similarity</span>(<span class="params">train</span>):</span><br><span class="line">    <span class="comment"># c[i][number]表示使用物品i的用户数量</span></span><br><span class="line">    <span class="comment"># c[i][j]表示同时交互物品i和j的用户数</span></span><br><span class="line">    c = defaultdict(<span class="keyword">lambda</span>: defaultdict(<span class="built_in">int</span>))</span><br><span class="line">    <span class="keyword">for</span> user, items <span class="keyword">in</span> train.items():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">            <span class="comment"># 统计每个物品被交互的总次数</span></span><br><span class="line">            c[i][number] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 统计物品i与其他物品的共现次数</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> items:</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                c[i][j] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算最终的相似度矩阵 w</span></span><br><span class="line">    w = defaultdict(<span class="built_in">dict</span>)</span><br><span class="line">    <span class="keyword">for</span> i, related_items <span class="keyword">in</span> c.items():</span><br><span class="line">        <span class="keyword">for</span> j, cij <span class="keyword">in</span> related_items.items():</span><br><span class="line">            <span class="keyword">if</span> j == number: <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 余弦相似度公式</span></span><br><span class="line">            similarity = cij / math.sqrt(c[i][number] * c[j][number])</span><br><span class="line">            w[i][j] = similarity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recommend</span>(<span class="params">interacted_items: <span class="type">Union</span>[<span class="built_in">set</span>, <span class="built_in">dict</span>], w, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param interacted_items: 指定用户交互过的物品</span></span><br><span class="line"><span class="string">    :param w: 物品的相似度</span></span><br><span class="line"><span class="string">    :param k: 取最相似的k个物品</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(interacted_items, <span class="built_in">set</span>):  <span class="comment"># 如果只有物品，没有评分，那么将评分统一设置为1</span></span><br><span class="line">        interacted_items = &#123;k: <span class="number">1</span> <span class="keyword">for</span> k <span class="keyword">in</span> interacted_items&#125;</span><br><span class="line">    rank = defaultdict(<span class="built_in">float</span>)</span><br><span class="line">    <span class="comment"># 用户交互过的物品，和用户对这个物品的评分</span></span><br><span class="line">    <span class="keyword">for</span> item, score <span class="keyword">in</span> interacted_items.items():</span><br><span class="line">        <span class="comment"># 物品的相似度信息，得到related_item和item的相似度similarity，按照相似度的值从大到小排序，取k个值</span></span><br><span class="line">        <span class="keyword">for</span> related_item, similarity <span class="keyword">in</span> <span class="built_in">sorted</span>(w[item].items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)[:k]:</span><br><span class="line">            <span class="comment"># 如果这个物品已经被用户交互过了，跳过</span></span><br><span class="line">            <span class="keyword">if</span> related_item <span class="keyword">in</span> interacted_items:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算相关的物品的相似度评分</span></span><br><span class="line">            rank[related_item] += score * similarity</span><br><span class="line">    <span class="keyword">return</span> rank</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    users = &#123;</span><br><span class="line">        <span class="string">&#x27;A&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;B&#x27;</span>: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;C&#x27;</span>: &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;a&#x27;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;D&#x27;</span>: &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w = item_similarity(users)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> w.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>: <span class="subst">&#123;<span class="built_in">dict</span>(<span class="built_in">sorted</span>(v.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>))&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    rank = recommend(users[<span class="string">&#x27;B&#x27;</span>], w, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">sorted</span>(rank.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;k&#125;</span>: <span class="subst">&#123;v&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>以上代码的执行结果如下，可见用户<code>B</code>和物品<code>d</code>的相关度最高</p><pre><code>b: &#123;&#39;a&#39;: 0.8164965809277261, &#39;d&#39;: 0.5, &#39;e&#39;: 0.5&#125;
d: &#123;&#39;b&#39;: 0.5, &#39;c&#39;: 0.5, &#39;e&#39;: 0.5, &#39;a&#39;: 0.4082482904638631&#125;
a: &#123;&#39;b&#39;: 0.8164965809277261, &#39;d&#39;: 0.4082482904638631, &#39;c&#39;: 0.4082482904638631, &#39;e&#39;: 0.4082482904638631&#125;
c: &#123;&#39;d&#39;: 0.5, &#39;e&#39;: 0.5, &#39;a&#39;: 0.4082482904638631&#125;
e: &#123;&#39;b&#39;: 0.5, &#39;c&#39;: 0.5, &#39;d&#39;: 0.5, &#39;a&#39;: 0.4082482904638631&#125;
d: 0.9082482904638631
b: 0.8164965809277261
e: 0.5
</code></pre><p>基于物品的推荐在工程中使用的比基于用户的推荐要多，因为UserCF（User Collaborative Filtering）的推荐更社会化，反映了用户所在的小型兴趣群体中物品的热门程度，而ItemCF（Item Collaborative Filtering）的推荐更加个性化，反映了用户自己的兴趣传承。</p><h3 id="LFM（latent-factor-model）隐语义模型"><a href="#LFM（latent-factor-model）隐语义模型" class="headerlink" title="LFM（latent factor model）隐语义模型"></a>LFM（latent factor model）隐语义模型</h3><p>隐语义模型核心思想是通过隐含特征(latent factor)联系用户兴趣和物品，它可以通过对数据进行分类来实现推荐。这种基于用户对数据的兴趣分类的方式，需要解决如下三个问题：</p><ol><li>如何给物品分类</li><li>如何确定用户对哪些分类感兴趣，以及感兴趣的程度</li><li>对于一个分类，选择哪些物品推荐给用户，以及这些物品的权重如何</li></ol><p>隐含语义分析技术（latent variable analysis）采取基于用户行为统计的自动聚类，来实现数据自动分类。</p><h2 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h2><p>一个推荐系统好不好，可以从用户满意度、预测准确度、覆盖率、多样性、新颖性、惊喜度、信任度、实时性、健壮性、商业目标等多个角度来进行评测</p><h3 id="准确度"><a href="#准确度" class="headerlink" title="准确度"></a>准确度</h3><p>我们可以使用TopN推荐的方式来计算准确度，TopN的准确度一般通过准确率（precision）&#x2F;召回率（recall）来进行度量。令R(u)是根据用户在训练集上的行为给用户作出的推荐列表，而T(u)是用户在测试集上的行为列表。那么，推荐结果的召回率定义为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Recall</mtext><mo>&#x3D;</mo><mfrac><mrow><munder><mo data-mjx-texclass="OP">∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>U</mi></mrow></munder><mrow><mo stretchy="false">|</mo></mrow><mi>R</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>T</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></mrow><mrow><munder><mo data-mjx-texclass="OP">∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>U</mi></mrow></munder><mrow><mo stretchy="false">|</mo></mrow><mi>T</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></mrow></mfrac></math></p><p>推荐结果的准确率定义为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>Precision</mtext><mo>&#x3D;</mo><mfrac><mrow><munder><mo data-mjx-texclass="OP">∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>U</mi></mrow></munder><mrow><mo stretchy="false">|</mo></mrow><mi>R</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>T</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></mrow><mrow><munder><mo data-mjx-texclass="OP">∑</mo><mrow><mi>u</mi><mo>∈</mo><mi>U</mi></mrow></munder><mrow><mo stretchy="false">|</mo></mrow><mi>R</mi><mo stretchy="false">(</mo><mi>u</mi><mo stretchy="false">)</mo><mo stretchy="false">|</mo></mrow></mfrac></math></p><p>简单来说，R(u)代表系统推荐给用户u的Top-N列表（预测值），T(u)代表用户实际喜欢或点击过的项目（真实值），召回率和准确率公式的分子都是同时存在于推荐列表和用户喜欢列表的物品数。召回率的分母是用户喜欢的物品数，召回率是看系统有没有把用户喜欢的物品推荐出来。准确率的分母是系统推荐的物品总数，目的是看推荐有多少是对的。</p><table><thead><tr><th>指标</th><th>含义</th><th>关注点</th></tr></thead><tbody><tr><td>Recall</td><td>你真正喜欢的内容中，被系统找出来了多少</td><td>不漏掉好东西</td></tr><tr><td>Precision</td><td>系统推荐的内容中，有多少真的是你喜欢的</td><td>不乱推荐垃圾</td></tr></tbody></table><p>我们可以把召回率和准确率的计算通过如下代码实现</p><figure class="highlight python"><figcaption><span>flat</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">precision_recall</span>(<span class="params">test_data, train_data, n, recommend_func</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算推荐系统在测试集上的准确率和召回率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param test_data: dict，用户 -&gt; 测试集中真实交互物品列表</span></span><br><span class="line"><span class="string">    :param train_data: dict，用户 -&gt; 训练集中交互物品列表（用于生成推荐）</span></span><br><span class="line"><span class="string">    :param n: int，每个用户推荐的物品数量</span></span><br><span class="line"><span class="string">    :param recommend_func: function(user, n, train_data)，返回推荐物品列表</span></span><br><span class="line"><span class="string">    :return: [recall, precision]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    hit = <span class="number">0</span>  <span class="comment"># 交集</span></span><br><span class="line">    total_actual = <span class="number">0</span>  <span class="comment"># 所有用户的真实物品总数</span></span><br><span class="line">    total_recommend = <span class="number">0</span>  <span class="comment"># 所有推荐物品总数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> user, actual_items <span class="keyword">in</span> test_data.items():</span><br><span class="line">        <span class="comment"># 计算推荐物品</span></span><br><span class="line">        recommended_items = recommend_func(user, n, train_data)</span><br><span class="line">        <span class="comment"># 计算交集</span></span><br><span class="line">        hit += <span class="built_in">len</span>(<span class="built_in">set</span>(recommended_items) &amp; <span class="built_in">set</span>(actual_items))</span><br><span class="line">        <span class="comment"># 真实物品数</span></span><br><span class="line">        total_actual += <span class="built_in">len</span>(actual_items)</span><br><span class="line">        <span class="comment"># 推荐物品数</span></span><br><span class="line">        total_recommend += <span class="built_in">len</span>(recommended_items)</span><br><span class="line"></span><br><span class="line">    recall = hit / total_actual <span class="keyword">if</span> total_actual <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    precision = hit / total_recommend <span class="keyword">if</span> total_recommend <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> [recall, precision]</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10769749/">推荐系统实践</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="《推荐系统实践》">https://www.nosuchfield.com/2025/06/22/Recommender-Systems-in-Practice/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" rel="tag">推荐系统</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>