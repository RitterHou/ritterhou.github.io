<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>自己动手实现一个可以运行在JVM上的编程语言 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="编译原理,编译器,虚拟机,JVM,ANTLR4,字节码"><meta name="description" content="&lt;p&gt;众所周知，JVM虚拟机被设计为可以执行栈式指令的机器。因此任何一个语言只要编译之后得到的字节码符合JVM的标准，就可以在JVM上执行，例如Kotlin、Groovy、Scala、Clojure。&lt;/p&gt;
&lt;p&gt;我们自己设计一款语言，并命名为Jinx，它支持类定义、变量定义、变量打印。它的语法解析逻辑如下&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">自己动手实现一个可以运行在JVM上的编程语言</h1></div><div class="post-meta"><span class="post-time">2023-09-06</span></div><div class="post-content"><p>众所周知，JVM虚拟机被设计为可以执行栈式指令的机器。因此任何一个语言只要编译之后得到的字节码符合JVM的标准，就可以在JVM上执行，例如Kotlin、Groovy、Scala、Clojure。</p><p>我们自己设计一款语言，并命名为Jinx，它支持类定义、变量定义、变量打印。它的语法解析逻辑如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">grammar Jinx;</span><br><span class="line"></span><br><span class="line">@header &#123;</span><br><span class="line">package com.nosuchfield.jinx.code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jinx: CLASS ID LEFT_BR classBody RIGHT_BR EOF;</span><br><span class="line">classBody: (variable | print)*;</span><br><span class="line">variable: VARIABLE ID EQUALS value;</span><br><span class="line">print: PRINT ID;</span><br><span class="line">value: STRING | INT | DOUBLE;</span><br><span class="line"></span><br><span class="line">LEFT_BR: &#x27;&#123;&#x27;;</span><br><span class="line">RIGHT_BR: &#x27;&#125;&#x27;;</span><br><span class="line">CLASS: &#x27;class&#x27;;</span><br><span class="line">VARIABLE: &#x27;var&#x27;;</span><br><span class="line">PRINT: &#x27;print&#x27;;</span><br><span class="line">EQUALS: &#x27;=&#x27;;</span><br><span class="line">STRING: &#x27;&quot;&#x27; (&#x27;\\&quot;&#x27; | ~&#x27;&quot;&#x27;)+ &#x27;&quot;&#x27;;</span><br><span class="line">DOUBLE: [0-9]+ &#x27;.&#x27; [0-9]+;</span><br><span class="line">INT: [0-9]+;</span><br><span class="line">// 这个ID不能放在前面，不然会被提前解析，导致print等字符串被解析为ID</span><br><span class="line">ID: [a-zA-Z] [a-zA-Z0-9]*;</span><br><span class="line"></span><br><span class="line">WS: [\n\r\t ]+ -&gt; skip;</span><br></pre></td></tr></table></figure><p>Jinx的最外层是类class，class的内部可以包含变量的定义和打印，变量的值支持字符串、整数和小数。有了ANTLR4的解析逻辑之后，我们就可以处理程序的语法树了，语法树的解析如下</p><figure class="highlight java"><figcaption><span>flat</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Loader</span> <span class="keyword">extends</span> <span class="title class_">JinxBaseListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变量表，以变量名为key，包括：变量索引idx、变量类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ImmutablePair&lt;Integer, Integer&gt;&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指令列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Instruction&gt; instructions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterJinx</span><span class="params">(JinxParser.JinxContext ctx)</span> &#123;</span><br><span class="line">        className = ctx.ID().getText();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitVariable</span><span class="params">(JinxParser.VariableContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 变量名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ctx.ID().getText();</span><br><span class="line">        JinxParser.<span class="type">ValueContext</span> <span class="variable">variable</span> <span class="operator">=</span> ctx.value();</span><br><span class="line">        <span class="comment">// 变量值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> variable.getText();</span><br><span class="line">        <span class="comment">// 变量类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> variable.getStart().getType();</span><br><span class="line">        <span class="comment">// 变量索引（在局部变量表中这是第几个变量）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> variables.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把这个变量保存在内存，方便后面知道这个变量的索引和类型</span></span><br><span class="line">        variables.put(name, ImmutablePair.of(idx, type));</span><br><span class="line">        <span class="comment">// 创建保存这个变量的指令</span></span><br><span class="line">        instructions.add(<span class="keyword">new</span> <span class="title class_">VariableInstruction</span>(idx, type, text));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitPrint</span><span class="params">(JinxParser.PrintContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ctx.ID().getText();</span><br><span class="line">        <span class="keyword">if</span> (!variables.containsKey(name)) &#123;</span><br><span class="line">            System.err.printf(<span class="string">&quot;variable %s not exist\n&quot;</span>, name);</span><br><span class="line">            System.exit(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> variables.get(name).getLeft();</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> variables.get(name).getRight();</span><br><span class="line">        <span class="comment">// 创建打印的指令</span></span><br><span class="line">        instructions.add(<span class="keyword">new</span> <span class="title class_">PrintInstruction</span>(idx, type));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Instruction&gt; <span class="title function_">getInstructions</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instructions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的语法树解析中，我们会解析每一个变量的定义语法和打印语法。</p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>我们会在定义每个变量的时候记录下变量的类型和索引，并把记录的数据关联到这个变量的名字上。此外，我们还会针对这个变量的类型、索引和值生成JVM保存变量的指令。</p><h3 id="变量打印"><a href="#变量打印" class="headerlink" title="变量打印"></a>变量打印</h3><p>在打印程序的解析中，我们会先通过变量的名称从关联表中取出变量的类型和索引（如果不存在就报错），之后根据变量的类型和索引创建JVM打印的指令。</p><p>上面的语法树解析最终生成了一个指令列表instructions，我们接下来根据这个指令列表生成JVM所需要的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] generateBytecode(List&lt;Instruction&gt; instructions, String className) &#123;</span><br><span class="line">    <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(ClassWriter.COMPUTE_FRAMES);</span><br><span class="line">    classWriter.visit(V1_8, ACC_PUBLIC + ACC_SUPER, className, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// main方法</span></span><br><span class="line">    <span class="type">MethodVisitor</span> <span class="variable">methodVisitor</span> <span class="operator">=</span> classWriter.visitMethod(ACC_PUBLIC + ACC_STATIC, <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span> (Instruction instruction : instructions) &#123;</span><br><span class="line">        instruction.apply(methodVisitor);</span><br><span class="line">    &#125;</span><br><span class="line">    methodVisitor.visitInsn(RETURN);</span><br><span class="line">    methodVisitor.visitMaxs(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 设置COMPUTE_FRAMES后会自动计算，但是此处设置不能省略</span></span><br><span class="line">    methodVisitor.visitEnd();</span><br><span class="line">    classWriter.visitEnd();</span><br><span class="line">    <span class="keyword">return</span> classWriter.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上我们根据指令和类名使用<a target="_blank" rel="noopener" href="https://asm.ow2.io/">ASM</a>生成了字节码数据，它生成了一个包含main方法的类，并且把我们的指令放在main方法中。每个指令都调用了其<code>apply</code>方法，接下来我们具体看一下变量定义和变量打印的<code>apply</code>方法是如何实现的。</p><h3 id="变量定义-1"><a href="#变量定义-1" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(MethodVisitor mv)</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> JinxLexer.DOUBLE -&gt; &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">val</span> <span class="operator">=</span> Double.parseDouble(value);</span><br><span class="line">        <span class="comment">// 常量池的数据推到栈顶</span></span><br><span class="line">        mv.visitLdcInsn(val);</span><br><span class="line">        <span class="comment">// 栈顶double值存入本地局部变量，idx代表索引</span></span><br><span class="line">        mv.visitVarInsn(DSTORE, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> JinxLexer.INT -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Integer.parseInt(value);</span><br><span class="line">        mv.visitLdcInsn(val);</span><br><span class="line">        mv.visitVarInsn(ISTORE, idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> JinxLexer.STRING -&gt; &#123;</span><br><span class="line">        mv.visitLdcInsn(Utils.removeFirstAndLastChar(value));</span><br><span class="line">        mv.visitVarInsn(ASTORE, idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的定义很简单，都是先把变量的值从常量池取出，然后推到操作数栈的顶部。之后从操作数栈顶取数据，根据变量的idx把变量保存到局部变量表的指定索引位置。区别在于浮点型的保存指令是<code>DSTORE</code>，整型是<code>ISTORE</code>，字符串是<code>ASTORE</code>。</p><h3 id="变量打印-1"><a href="#变量打印-1" class="headerlink" title="变量打印"></a>变量打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(MethodVisitor mv)</span> &#123;</span><br><span class="line">    mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;java/lang/System&quot;</span>, <span class="string">&quot;out&quot;</span>, <span class="string">&quot;Ljava/io/PrintStream;&quot;</span>);</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> JinxLexer.INT -&gt; &#123;</span><br><span class="line">            mv.visitVarInsn(ILOAD, idx);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(I)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JinxLexer.DOUBLE -&gt; &#123;</span><br><span class="line">            mv.visitVarInsn(DLOAD, idx);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(D)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JinxLexer.STRING -&gt; &#123;</span><br><span class="line">            mv.visitVarInsn(ALOAD, idx);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/io/PrintStream&quot;</span>, <span class="string">&quot;println&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量的打印会先使用<code>System.out</code>变量，之后从局部变量表中根据变量的idx取出变量的值，然后执行<code>println</code>方法，入参分别为整型、浮点型和字符串。</p><p>有了以上这些指令，我们就可以正常生成字节码了，我们进行语法分析生成instructions，并使用instructions最终生成字节码文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compile0</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 词法分析</span></span><br><span class="line">    <span class="type">JinxLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JinxLexer</span>(CharStreams.fromFileName(file));</span><br><span class="line">    <span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">    <span class="comment">// 语法分析</span></span><br><span class="line">    <span class="type">JinxParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JinxParser</span>(tokens);</span><br><span class="line">    parser.removeErrorListeners();</span><br><span class="line">    parser.addErrorListener(<span class="keyword">new</span> <span class="title class_">ErrorHandler</span>()); <span class="comment">// 语法分析错误处理</span></span><br><span class="line">    <span class="type">ParseTree</span> <span class="variable">tree</span> <span class="operator">=</span> parser.jinx();</span><br><span class="line">    <span class="comment">// 语法树遍历</span></span><br><span class="line">    <span class="type">ParseTreeWalker</span> <span class="variable">parseTreeWalker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseTreeWalker</span>();</span><br><span class="line">    <span class="type">Loader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Loader</span>();</span><br><span class="line">    parseTreeWalker.walk(loader, tree);</span><br><span class="line">    <span class="comment">// 遍历语法树生成Java指令</span></span><br><span class="line">    List&lt;Instruction&gt; instructions = loader.getInstructions();</span><br><span class="line">    <span class="comment">// 生成Java.class文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> loader.getClassName();</span><br><span class="line">    <span class="type">String</span> <span class="variable">classFile</span> <span class="operator">=</span> Paths.get(<span class="keyword">new</span> <span class="title class_">File</span>(file).getParent(), className + <span class="string">&quot;.class&quot;</span>).toString();</span><br><span class="line">    writeByteArrayToFile(classFile, generateBytecode(instructions, className));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的最后一行就是根据指令列表和类名生成字节码，并把字节码保存到文件中。我们创建一个源代码</p><pre><code>class Test &#123;
    var name = &quot;Mike&quot;
    var salary = 2370
    print name
    print salary
    var number = 1.1
    print number
&#125;
</code></pre><p>使用编译器解析如上代码并最终生成一个字节码文件Test.class，运行这个字节码文件可以打印出变量的值</p><pre><code>$ java Test
Mike
2370
1.1
</code></pre><p>我们也可以查看字节码的信息如下</p><pre><code>$ javap -verbose Test
Classfile /src/main/resources/jinx/Test.class
Last modified Jan 3, 2023; size 342 bytes
MD5 checksum fff7d9ac9c044299ffd5a6194c452502
public class Test
minor version: 0
major version: 52
flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
#1 = Utf8               Test
#2 = Class              #1             // Test
#3 = Utf8               java/lang/Object
#4 = Class              #3             // java/lang/Object
#5 = Utf8               main
#6 = Utf8               ([Ljava/lang/String;)V
#7 = Utf8               Mike
#8 = String             #7             // Mike
#9 = Integer            2370
#10 = Utf8               java/lang/System
#11 = Class              #10            // java/lang/System
#12 = Utf8               out
#13 = Utf8               Ljava/io/PrintStream;
#14 = NameAndType        #12:#13        // out:Ljava/io/PrintStream;
#15 = Fieldref           #11.#14        // java/lang/System.out:Ljava/io/PrintStream;
#16 = Utf8               java/io/PrintStream
#17 = Class              #16            // java/io/PrintStream
#18 = Utf8               println
#19 = Utf8               (Ljava/lang/String;)V
#20 = NameAndType        #18:#19        // println:(Ljava/lang/String;)V
#21 = Methodref          #17.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V
#22 = Utf8               (I)V
#23 = NameAndType        #18:#22        // println:(I)V
#24 = Methodref          #17.#23        // java/io/PrintStream.println:(I)V
#25 = Double             1.1d
#27 = Utf8               (D)V
#28 = NameAndType        #18:#27        // println:(D)V
#29 = Methodref          #17.#28        // java/io/PrintStream.println:(D)V
#30 = Utf8               Code
&#123;
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
    stack=3, locals=4, args_size=1
        0: ldc           #8                  // String Mike
        2: astore_0
        3: ldc           #9                  // int 2370
        5: istore_1
        6: getstatic     #15                 // Field java/lang/System.out:Ljava/io/PrintStream;
        9: aload_0
        10: invokevirtual #21                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        13: getstatic     #15                 // Field java/lang/System.out:Ljava/io/PrintStream;
        16: iload_1
        17: invokevirtual #24                 // Method java/io/PrintStream.println:(I)V
        20: ldc2_w        #25                 // double 1.1d
        23: dstore_2
        24: getstatic     #15                 // Field java/lang/System.out:Ljava/io/PrintStream;
        27: dload_2
        28: invokevirtual #29                 // Method java/io/PrintStream.println:(D)V
        31: return
&#125;
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://github.com/RitterHou/test-antlr4/blob/b6a5e73261e41313b81e072497d9281a8998caeb/src/main/resources/jinx/Jinx.g4">ANTLR4表达式</a><br><a target="_blank" rel="noopener" href="https://github.com/RitterHou/test-antlr4/tree/b6a5e73261e41313b81e072497d9281a8998caeb/src/main/java/com/nosuchfield/jinx">Java代码</a><br><a target="_blank" rel="noopener" href="https://lsieun.github.io/java/asm/index.html">Java ASM系列</a><br><a target="_blank" rel="noopener" href="https://github.com/JakubDziworski/Enkel-JVM-language">Enkel-JVM-language</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="自己动手实现一个可以运行在JVM上的编程语言">https://www.nosuchfield.com/2023/09/06/Implementing-a-Programming-Language-Running-on-the-JVM/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/ANTLR4/" rel="tag">ANTLR4</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E7%A0%81/" rel="tag">字节码</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" rel="tag">编译器</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>