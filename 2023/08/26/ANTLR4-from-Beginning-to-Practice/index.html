<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>ANTLR4从入门到实践 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="词法分析,语法分析,编译原理,编译器"><meta name="description" content="&lt;p&gt;&lt;a href=&#34;https://www.antlr.org/&#34;&gt;ANTLR&lt;/a&gt;（ANother Tool for Language Recognition）是一个强大的解析器生成器，用于读取、处理、执行或翻译结构化文本或二进制文档。它被广泛用于构建语言、工具和框架。ANTLR根据语法定义生成解析器，解析器可以构建和遍历解析树。&lt;/p&gt;
&lt;h2 id=&#34;安装&#34;&gt;&lt;a href=&#34;#安装&#34; class=&#34;headerlink&#34; title=&#34;安装&#34;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;以Linux系统为例，我们首先&lt;a href=&#34;https://techviewleo.com/install-java-17-openjdk-17-on-linux-mint/?expand_article=1&#34;&gt;安装Java17&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;~ java -version
java version &amp;quot;17.0.6&amp;quot; 2023-01-17 LTS
Java(TM) SE Runtime Environment (build 17.0.6+9-LTS-190)"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">ANTLR4从入门到实践</h1></div><div class="post-meta"><span class="post-time">2023-08-26</span></div><div class="post-content"><p><a target="_blank" rel="noopener" href="https://www.antlr.org/">ANTLR</a>（ANother Tool for Language Recognition）是一个强大的解析器生成器，用于读取、处理、执行或翻译结构化文本或二进制文档。它被广泛用于构建语言、工具和框架。ANTLR根据语法定义生成解析器，解析器可以构建和遍历解析树。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>以Linux系统为例，我们首先<a target="_blank" rel="noopener" href="https://techviewleo.com/install-java-17-openjdk-17-on-linux-mint/?expand_article=1">安装Java17</a></p><pre><code>~ java -version
java version &quot;17.0.6&quot; 2023-01-17 LTS
Java(TM) SE Runtime Environment (build 17.0.6+9-LTS-190)
Java HotSpot(TM) 64-Bit Server VM (build 17.0.6+9-LTS-190, mixed mode, sharing)
</code></pre><p>随后我们下载antlr4的完整依赖包</p><pre><code>wget https://www.antlr.org/download/antlr-4.13.0-complete.jar
</code></pre><p>并把依赖包添加到Java的CLASSPATH中，将以下命令添加到<code>~/.zshrc</code>文件中</p><pre><code>export CLASSPATH=&quot;/home/raymond/Desktop/antlr4/antlr-4.13.0-complete.jar:$CLASSPATH&quot;
</code></pre><p>之后我们就可以使用antlr4的Tool和TestRig了</p><pre><code>~ java org.antlr.v4.Tool
ANTLR Parser Generator  Version 4.13.0
-o ___              specify output directory where all output is generated
-lib ___            specify location of grammars, tokens files
-atn                generate rule augmented transition network diagrams
-encoding ___       specify grammar file encoding; e.g., euc-jp
-message-format ___ specify output style for messages in antlr, gnu, vs2005
-long-messages      show exception details when available for errors and warnings
-listener           generate parse tree listener (default)
-no-listener        don&#39;t generate parse tree listener
-visitor            generate parse tree visitor
-no-visitor         don&#39;t generate parse tree visitor (default)
-package ___        specify a package/namespace for the generated code
-depend             generate file dependencies
-D&lt;option&gt;=value    set/override a grammar-level option
-Werror             treat warnings as errors
-XdbgST             launch StringTemplate visualizer on generated code
-XdbgSTWait         wait for STViz to close before continuing
-Xforce-atn         use the ATN simulator for all predictions
-Xlog               dump lots of logging info to antlr-timestamp.log
-Xexact-output-dir  all output goes into -o dir regardless of paths/package

~ java org.antlr.v4.gui.TestRig
java org.antlr.v4.gui.TestRig GrammarName startRuleName
[-tokens] [-tree] [-gui] [-ps file.ps] [-encoding encodingname]
[-trace] [-diagnostics] [-SLL]
[input-filename(s)]
Use startRuleName=&#39;tokens&#39; if GrammarName is a lexer grammar.
Omitting input-filename makes rig read from stdin.
</code></pre><p>可以在<code>~/.zshrc</code>中添加如下别名</p><pre><code>alias antlr4=&#39;java org.antlr.v4.Tool&#39;
alias grun=&#39;java org.antlr.v4.gui.TestRig&#39;
</code></pre><p>后面就可以直接使用antlr4和grun命令了</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>我们从一个最简单的例子来看antlr4，创建一个名为Hello.g4的文件并输入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grammar Hello;              // 语法名称，必须要和文件名称一样</span><br><span class="line"></span><br><span class="line">r  : &#x27;hello&#x27; ID ;           // 表示匹配字符串hello和ID这个token，语法名称用小写字母定义</span><br><span class="line">ID : [a-z]+ ;               // ID这个token的定义只允许小写字母，词法名称用大写字母定义</span><br><span class="line">WS : [ \t\r\n]+ -&gt; skip ;   // 忽略一些字符</span><br></pre></td></tr></table></figure><p>随后执行<code>antlr4 Hello.g4 -o code</code>命令将语法文件转化为Java的代码，具体生成的文件如下</p><pre><code>HelloBaseListener.java
Hello.interp
HelloLexer.interp
HelloLexer.java
HelloLexer.tokens
HelloListener.java
HelloParser.java
Hello.tokens
</code></pre><p>之后执行命令<code>javac *.java</code>将所有的Java代码进行编译，编译完了之后执行命令<code>grun Hello r -tree</code>并输入相关文本内容，之后输入EOF（Linux上面是Ctrl + D）可以得到解析结果</p><pre><code>➜  grun Hello r -tree
hello antlr
&lt;EOF&gt;
(r hello antlr)
</code></pre><p>其中Hello是语法文件的名称，r则是语法的名称，-tree表示以lisp语法展示语法，我们也可以使用-gui选项展示语法树。</p><p>Visual Studio Code提供了antlr4的<a target="_blank" rel="noopener" href="https://marketplace.visualstudio.com/items?itemName=mike-lischke.vscode-antlr4">插件</a>，可以方便的进行语法高亮和格式化等操作。IntelliJ Idea也提供了<a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7358-antlr-v4">插件</a>，具有快速生成代码、设置生成代码的参数以及查看语法树等功能。</p><h2 id="使用antlr4构建一个计算器"><a href="#使用antlr4构建一个计算器" class="headerlink" title="使用antlr4构建一个计算器"></a>使用antlr4构建一个计算器</h2><p>首先我们创建一个Calc.g4文件，具体内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">grammar Calc;       // 语法的名称，要和文件名称一致</span><br><span class="line"></span><br><span class="line">calc: (expr)* EOF;  // 一个或多个表达式</span><br><span class="line"></span><br><span class="line">expr:</span><br><span class="line">    BRACKET_L expr BRACKET_R                    // 圆括号</span><br><span class="line">    | (ADD | SUB)? (NUMBER | PERCENT_NUMBER)    // 正负数字和百分数</span><br><span class="line">    | expr (MUL | DIV) expr                     // 乘除法</span><br><span class="line">    | expr (ADD | SUB) expr;                    // 加减法</span><br><span class="line"></span><br><span class="line">PERCENT_NUMBER: NUMBER PERCENT; // 百分数</span><br><span class="line">NUMBER: DIGIT (POINT DIGIT)?;   // 小数</span><br><span class="line"></span><br><span class="line">DIGIT: [0-9]+;  // 数字</span><br><span class="line">BRACKET_L: &#x27;(&#x27;; // 左括号</span><br><span class="line">BRACKET_R: &#x27;)&#x27;; // 右括号</span><br><span class="line">ADD: &#x27;+&#x27;;</span><br><span class="line">SUB: &#x27;-&#x27;;</span><br><span class="line">MUL: &#x27;*&#x27;;</span><br><span class="line">DIV: &#x27;/&#x27;;</span><br><span class="line">PERCENT: &#x27;%&#x27;;</span><br><span class="line">POINT: &#x27;.&#x27;;</span><br><span class="line"></span><br><span class="line">WS: [ \t\r\n]+ -&gt; skip; // 跳过空格换行等字符</span><br></pre></td></tr></table></figure><p>执行命令<code>antlr4 Calc.g4 -o code</code>来生成代码，并将生成的代码放到<code>code</code>文件夹中。进入code文件夹，执行<code>javac *.java</code>命令编译代码。编译完代码之后，就可以执行测试程序了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜ grun Calc calc -tree</span><br><span class="line">1 + 2 * (3 + 4) - 5 / 6       </span><br><span class="line">(calc (<span class="built_in">expr</span> (<span class="built_in">expr</span> (<span class="built_in">expr</span> 1) + (<span class="built_in">expr</span> (<span class="built_in">expr</span> 2) * (<span class="built_in">expr</span> ( (<span class="built_in">expr</span> (<span class="built_in">expr</span> 3) + (<span class="built_in">expr</span> 4)) )))) - (<span class="built_in">expr</span> (<span class="built_in">expr</span> 5) / (<span class="built_in">expr</span> 6))) &lt;EOF&gt;)</span><br><span class="line"></span><br><span class="line">➜ grun Calc calc -tokens</span><br><span class="line">1 + 2 * (3 + 4) - 5 / 6       </span><br><span class="line">[@0,0:0=<span class="string">&#x27;1&#x27;</span>,&lt;NUMBER&gt;,1:0]</span><br><span class="line">[@1,2:2=<span class="string">&#x27;+&#x27;</span>,&lt;<span class="string">&#x27;+&#x27;</span>&gt;,1:2]</span><br><span class="line">[@2,4:4=<span class="string">&#x27;2&#x27;</span>,&lt;NUMBER&gt;,1:4]</span><br><span class="line">[@3,6:6=<span class="string">&#x27;*&#x27;</span>,&lt;<span class="string">&#x27;*&#x27;</span>&gt;,1:6]</span><br><span class="line">[@4,8:8=<span class="string">&#x27;(&#x27;</span>,&lt;<span class="string">&#x27;(&#x27;</span>&gt;,1:8]</span><br><span class="line">[@5,9:9=<span class="string">&#x27;3&#x27;</span>,&lt;NUMBER&gt;,1:9]</span><br><span class="line">[@6,11:11=<span class="string">&#x27;+&#x27;</span>,&lt;<span class="string">&#x27;+&#x27;</span>&gt;,1:11]</span><br><span class="line">[@7,13:13=<span class="string">&#x27;4&#x27;</span>,&lt;NUMBER&gt;,1:13]</span><br><span class="line">[@8,14:14=<span class="string">&#x27;)&#x27;</span>,&lt;<span class="string">&#x27;)&#x27;</span>&gt;,1:14]</span><br><span class="line">[@9,16:16=<span class="string">&#x27;-&#x27;</span>,&lt;<span class="string">&#x27;-&#x27;</span>&gt;,1:16]</span><br><span class="line">[@10,18:18=<span class="string">&#x27;5&#x27;</span>,&lt;NUMBER&gt;,1:18]</span><br><span class="line">[@11,20:20=<span class="string">&#x27;/&#x27;</span>,&lt;<span class="string">&#x27;/&#x27;</span>&gt;,1:20]</span><br><span class="line">[@12,22:22=<span class="string">&#x27;6&#x27;</span>,&lt;NUMBER&gt;,1:22]</span><br><span class="line">[@13,31:30=<span class="string">&#x27;&lt;EOF&gt;&#x27;</span>,&lt;EOF&gt;,2:0]</span><br><span class="line"></span><br><span class="line">➜ grun Calc calc -gui</span><br><span class="line">1 + 2 * (3 + 4) - 5 / 6</span><br></pre></td></tr></table></figure><p>第一个命令是生成Lisp风格的语法树，第二个命令是查看相应的token，第三个命令生成的语法树如下所示</p><p><img src="/images/20230826/1.png"></p><h3 id="通过Java代码调用生成的Lexer和Parser"><a href="#通过Java代码调用生成的Lexer和Parser" class="headerlink" title="通过Java代码调用生成的Lexer和Parser"></a>通过Java代码调用生成的Lexer和Parser</h3><p>还是以上面的例子为例，这次我们把词法分析和语法分析的内容分开来，分别创建<code>CalcLexerRules.g4</code>和<code>Calc.g4</code>文件，它们的内容分别如下</p><p>CalcLexerRules.g4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lexer grammar CalcLexerRules;</span><br><span class="line"></span><br><span class="line">PERCENT_NUMBER: NUMBER PERCENT;</span><br><span class="line">NUMBER: DIGIT (POINT DIGIT)?;</span><br><span class="line"></span><br><span class="line">DIGIT: [0-9]+;</span><br><span class="line">BRACKET_L: &#x27;(&#x27;;</span><br><span class="line">BRACKET_R: &#x27;)&#x27;;</span><br><span class="line">ADD: &#x27;+&#x27;;</span><br><span class="line">SUB: &#x27;-&#x27;;</span><br><span class="line">MUL: &#x27;*&#x27;;</span><br><span class="line">DIV: &#x27;/&#x27;;</span><br><span class="line">PERCENT: &#x27;%&#x27;;</span><br><span class="line">POINT: &#x27;.&#x27;;</span><br><span class="line"></span><br><span class="line">WS: [ \t\r\n]+ -&gt; skip;</span><br></pre></td></tr></table></figure><p>Calc.g4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grammar Calc;</span><br><span class="line">import CalcLexerRules;  // 引入CalcLexerRules的词法规则</span><br><span class="line"></span><br><span class="line">calc: (expr)* EOF;</span><br><span class="line"></span><br><span class="line">expr:</span><br><span class="line">    BRACKET_L expr BRACKET_R</span><br><span class="line">    | (ADD | SUB)? (NUMBER | PERCENT_NUMBER)</span><br><span class="line">    | expr (MUL | DIV) expr</span><br><span class="line">    | expr (ADD | SUB) expr;</span><br></pre></td></tr></table></figure><p>创建这两个文件之后，执行命令<code>antlr4 Calc.g4 -o code</code>生成代码，antlr会自动把CalcLexerRules.g4的内容引入进来。在生成代码的code文件夹下创建Java文件<code>CalcTest.java</code>，并使用Java代码调用生成的Lexer和Parser类中的方法</p><p>CalcTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CommonTokenStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.tree.ParseTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalcTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CalcLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcLexer</span>(CharStreams.fromString(<span class="string">&quot;1 + 2 * (3 + 4) - 5 / 6&quot;</span>));</span><br><span class="line">        <span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">        <span class="type">CalcParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcParser</span>(tokens);</span><br><span class="line">        <span class="type">ParseTree</span> <span class="variable">tree</span> <span class="operator">=</span> parser.calc();</span><br><span class="line">        System.out.println(tree.toStringTree(parser));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了如上的类之后，执行命令<code>javac *.java</code>编译源码文件，之后执行命令<code>java CalcTest</code>来运行Java代码，得到结果如下</p><pre><code>(calc (expr (expr (expr 1) + (expr (expr 2) * (expr ( (expr (expr 3) + (expr 4)) )))) - (expr (expr 5) / (expr 6))) &lt;EOF&gt;)
</code></pre><p>运行结果和上面的grun的测试结果是一致的。</p><h3 id="通过Visitor访问代码"><a href="#通过Visitor访问代码" class="headerlink" title="通过Visitor访问代码"></a>通过Visitor访问代码</h3><p>上面我们使用Java代码调用了CalcLexer和CalcParser类，接下来我们实现一个Visitor，通过Visitor来访问我们所需要访问的AST节点，并执行计算器的计算功能。</p><p>这里我们使用Idea的<a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/7358-antlr-v4">ANTLR v4</a>插件来生成代码，上面的词法文件CalcLexerRules.g4不需要任何改变，而语法文件Calc.g4修改如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grammar Calc;</span><br><span class="line">@header &#123;</span><br><span class="line">package com.nosuchfield.calc.code;</span><br><span class="line">&#125;</span><br><span class="line">import CalcLexerRules; // 引入词法分析文件</span><br><span class="line"></span><br><span class="line">calc: (expr)* EOF # calculationBlock;</span><br><span class="line"></span><br><span class="line">expr:</span><br><span class="line">    BRACKET_L expr BRACKET_R                                # expressionWithBr</span><br><span class="line">    | sign = (ADD | SUB)? num = (NUMBER | PERCENT_NUMBER)   # expressionNumeric</span><br><span class="line">    | expr op = (MUL | DIV) expr                            # expressionMulOrDiv</span><br><span class="line">    | expr op = (ADD | SUB) expr                            # expressionAddOrSub;</span><br></pre></td></tr></table></figure><p>这里我们添加了<code>@header</code>标记，表示在生成代码的时候在代码头部生成我们所需要的内容，如上就是在代码头部放上了类的package声明。</p><p>我们还在每个语法后面使用井号#设置了一个标记名称，这个名称在生成Visitor代码的时候会生成相应名称的方法。此外我们还给表达式的参数设置了名称，例如sign、num和op，这样当生成代码的时候，我们就可以用参数num取到NUMBER或者PERCENT_NUMBER的值。</p><p>我们在Calc.g4文件上右击并选择Configure ANTLR选项</p><p><img src="/images/20230826/2.png"></p><p>之后设置代码的生成目录为<code>src/main/java/com/nosuchfield/calc/code</code>，并且去掉生成listener的选项，同时选择生成visitor的选项</p><p><img src="/images/20230826/3.png"></p><p>设置好了之后我们右击Calc.g4文件并右击选择Generate ANTLR Recognizer选项，即可在<code>com/nosuchfield/calc/code</code>文件夹下生成相关的代码</p><p><img src="/images/20230826/4.png"></p><p>接下来我们自定义一个继承自CalcBaseVisitor类的CalculateVisitor，具体如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nosuchfield.calc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nosuchfield.calc.code.CalcBaseVisitor;</span><br><span class="line"><span class="keyword">import</span> com.nosuchfield.calc.code.CalcLexer;</span><br><span class="line"><span class="keyword">import</span> com.nosuchfield.calc.code.CalcParser;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.math.MathContext;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculateVisitor</span> <span class="keyword">extends</span> <span class="title class_">CalcBaseVisitor</span>&lt;BigDecimal&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于设置BigDecimal的计算精度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MathContext</span> <span class="variable">MATH_CONTEXT</span> <span class="operator">=</span> MathContext.DECIMAL128;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * calc语法，包含了多个expr，返回最后一个expr的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">visitCalculationBlock</span><span class="params">(CalcParser.CalculationBlockContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">calcResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (CalcParser.ExprContext expr : ctx.expr()) &#123;</span><br><span class="line">            calcResult = visit(expr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> calcResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左右括号，取出括号中的表达式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">visitExpressionWithBr</span><span class="params">(CalcParser.ExpressionWithBrContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> visit(ctx.expr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘除法，返回左右两个元素的计算结果</span></span><br><span class="line"><span class="comment">     * 其中op属性是在语法文件中自定义的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">visitExpressionMulOrDiv</span><span class="params">(CalcParser.ExpressionMulOrDivContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">left</span> <span class="operator">=</span> visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">right</span> <span class="operator">=</span> visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">switch</span> (ctx.op.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CalcParser.MUL:</span><br><span class="line">                <span class="keyword">return</span> left.multiply(right, MATH_CONTEXT);</span><br><span class="line">            <span class="keyword">case</span> CalcParser.DIV:</span><br><span class="line">                <span class="keyword">return</span> left.divide(right, MATH_CONTEXT);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;unsupported operator type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加减法，返回左右两个元素的计算结果</span></span><br><span class="line"><span class="comment">     * 其中op属性是在语法文件中自定义的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">visitExpressionAddOrSub</span><span class="params">(CalcParser.ExpressionAddOrSubContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">left</span> <span class="operator">=</span> visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">right</span> <span class="operator">=</span> visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">switch</span> (ctx.op.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CalcParser.ADD:</span><br><span class="line">                <span class="keyword">return</span> left.add(right, MATH_CONTEXT);</span><br><span class="line">            <span class="keyword">case</span> CalcParser.SUB:</span><br><span class="line">                <span class="keyword">return</span> left.subtract(right, MATH_CONTEXT);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;unsupported operator type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数值，num属性是在语法文件中定义的</span></span><br><span class="line"><span class="comment">     * 如果数值前有负号就取负值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">visitExpressionNumeric</span><span class="params">(CalcParser.ExpressionNumericContext ctx)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">numeric</span> <span class="operator">=</span> numberOrPercent(ctx.num);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(ctx.sign) &amp;&amp; ctx.sign.getType() == CalcLexer.SUB) &#123;</span><br><span class="line">            <span class="keyword">return</span> numeric.negate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numeric;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将文本内容转化为BigDecimal，包含数字和百分数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal <span class="title function_">numberOrPercent</span><span class="params">(Token num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">numberStr</span> <span class="operator">=</span> num.getText();</span><br><span class="line">        <span class="keyword">switch</span> (num.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CalcLexer.NUMBER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(numberStr);</span><br><span class="line">            <span class="keyword">case</span> CalcLexer.PERCENT_NUMBER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(numberStr.substring(<span class="number">0</span>, numberStr.length() - <span class="number">1</span>).trim())</span><br><span class="line">                        .divide(BigDecimal.valueOf(<span class="number">100</span>), MATH_CONTEXT);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;unsupported number type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自定义的Visitor中我们实现了计算逻辑，可以看到，这里重写了类CalcBaseVisitor的5个方法，分别对应了语法文件中的5个标记以及它们定义的名称，而属性的定义如num则对应了方法中入参的属性。以expressionNumeric语法为例，它对应的了方法visitExpressionNumeric，我们可以通过方法入参ExpressionNumericContext取到sign和num属性，之后通过这两个属性来定义数字的值。而expressionMulOrDiv语法就是通过op取到运算符，之后对两边的数字根据运算符来进行相应的计算。</p><p>有了visitor之后，我们用一个测试类来测试计算结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nosuchfield.calc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nosuchfield.calc.code.CalcLexer;</span><br><span class="line"><span class="keyword">import</span> com.nosuchfield.calc.code.CalcParser;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStream;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CharStreams;</span><br><span class="line"><span class="keyword">import</span> org.antlr.v4.runtime.CommonTokenStream;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> junit.framework.TestCase.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCalculate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCalculate</span><span class="params">()</span> &#123;</span><br><span class="line">        String[][] sources = <span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;</span><br><span class="line">                &#123;<span class="string">&quot;1 + 2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;3 - 2&quot;</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;2 * 3&quot;</span>, <span class="string">&quot;6&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;6 / 3&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;6 / (1 + 2)&quot;</span>, <span class="string">&quot;2&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;50%&quot;</span>, <span class="string">&quot;0.5&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;100 * 30%&quot;</span>, <span class="string">&quot;30.0&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;1 + 2 * (3 - 4) / 5&quot;</span>, <span class="string">&quot;0.6&quot;</span>&#125;,</span><br><span class="line">                &#123;<span class="string">&quot;-8 + 8 * 2 - 8&quot;</span>, <span class="string">&quot;0&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (String[] source : sources) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> source[<span class="number">0</span>].trim();</span><br><span class="line">            <span class="type">BigDecimal</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(source[<span class="number">1</span>].trim());</span><br><span class="line">            assertEquals(calculate(input), result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算表达式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expression 表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal <span class="title function_">calculate</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="type">CharStream</span> <span class="variable">cs</span> <span class="operator">=</span> CharStreams.fromString(expression);</span><br><span class="line">        <span class="type">CalcLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcLexer</span>(cs);</span><br><span class="line">        <span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">        <span class="type">CalcParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcParser</span>(tokens);</span><br><span class="line">        CalcParser.<span class="type">CalcContext</span> <span class="variable">context</span> <span class="operator">=</span> parser.calc();</span><br><span class="line">        <span class="type">CalculateVisitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalculateVisitor</span>();</span><br><span class="line">        <span class="keyword">return</span> visitor.visit(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们构建的计算器已经成功的计算出了正确结果。</p><h2 id="ANTLR4的工作流程"><a href="#ANTLR4的工作流程" class="headerlink" title="ANTLR4的工作流程"></a>ANTLR4的工作流程</h2><p>在上面的例子中我们已经了解到，使用antlr4的一般流程如下</p><ol><li>书写antlr4的词法和文法规则</li><li>使用antlr4的生成工具处理写好的规则，以生成指定语言的Lexer和Parser代码</li><li>调用生成的Lexer和Parser类，书写相应的逻辑代码，将原始输入文本转化为一个抽象语法树</li><li>使用antlr4的visitor来解析语法树，实现各种功能</li></ol><p>实际上，除了visitor之外，antlr4还提供了另一种解析语法树方式，叫做Listener。Listener是antlr4默认解析语法树的方式，它和visitor一样都可以实现对ParseTree的解析。如果开启了visitor或listener，那么antlr4除了会生成Lexer和Parser代码，还会生成相应的Visitor和Listener代码。</p><p>Listener和Visitor区别如下<sup><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/20714492/antlr4-listeners-and-visitors-which-to-implement" title="在stackoverflow上查看相关的讨论">注</a></sup></p><table><thead><tr><th align="left"></th><th align="left">Listener</th><th align="left">Visitor</th></tr></thead><tbody><tr><td align="left">是否访问所有节点</td><td align="left">访问所有节点</td><td align="left">只访问手动指定的节点</td></tr><tr><td align="left">访问节点方式</td><td align="left">通过enter和exit方法</td><td align="left">通过visit方法</td></tr><tr><td align="left">方法是否有返回值</td><td align="left">没有返回值</td><td align="left">有返回值</td></tr></tbody></table><p>了解了Listener和Visitor的区别之后，我们可以总结出antlr4的大致工作流程如下</p><p><img src="/images/20230826/5.png"></p><p>如上左边的<strong>点线流程</strong>代表了通过ANTLR4，将原始的<code>.g4</code>规则转化为Lexer、Parser、Listener和Visitor。右边的<strong>虚线流程</strong>代表了将原始的输入流通过Lexer转化为Tokens，再将Tokens通过Parser转化为语法树，最后通过Listener或Visitor遍历ParseTree得到最终结果。</p><h2 id="解析CSV文件"><a href="#解析CSV文件" class="headerlink" title="解析CSV文件"></a>解析CSV文件</h2><p>我们已经使用Visitor构建过一个计算器，接下来我们使用Listener实现对CSV的解析。<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Comma-separated_values">Comma-separated values (CSV)</a>文件是一种使用英文逗号 <code>,</code> 来分割字段的文件格式。文件分为多行，每行又被逗号分割为多列，第一行的内容可以当作字段的名称。下面是一个例子</p><pre><code>省份,城市,区县,描述
江苏,南京,雨花台,外包大道
浙江,杭州,西湖,太美丽啦！西湖
,上海,黄浦,&quot;as it says: &quot;&quot;hello, shanghai&quot;&quot;&quot;
</code></pre><p>分析这个格式，首先是一行头部，之后跟着多行数据，因此可以很容易的得出如下的语法规则</p><pre><code>csv: hdr row*;
</code></pre><p>而头部也是一样的数据格式，因此有如下规则</p><pre><code>hdr: row;
</code></pre><p>数据是一些由逗号分割的字段，因此可以定义数据如下。其中<code>\n</code>是Mac和Linux的换行符，<code>\r\n</code>则是Windows下的换行符，因此<code>\r</code>是可选的</p><pre><code>row: field (&#39;,&#39; field)* &#39;\r&#39;? &#39;\n&#39;;
</code></pre><p>接下来只需要定义field的词法即可，因为换行和逗号都是CSV中的格式符号，不允许在字符中存在。因此可以很容易的得到</p><pre><code>field: ~[\n,\r]+;
</code></pre><p><code>~</code>代表取反，也就是除了换行和逗号之外的其它多个字符。</p><p>有了上面这个规则还不够，因为CSV标准规定了，如果有特殊字符，可以用双引号包起来。例如一个逗号如果被包含在双引号里面，那么就是一个字段的组成部分而不是字段的分隔符。如果双引号包裹的内容中又有双引号，那么需要将这个字段内部的双引号用两个双引号进行替代。<br>因此我们还需要一个规则</p><pre><code>field: &#39;&quot;&#39; (&#39;&quot;&quot;&#39; | ~&#39;&quot;&#39;)* &#39;&quot;&#39;;
</code></pre><p>如上规则表示用双引号包裹的内容，可以是两个双引号或者除了单个双引号之外的其它任意内容。</p><p>CSV还允许空字段</p><pre><code>field: ;
</code></pre><p>整理如上规则，并添加包配置和相关的标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">grammar Csv;</span><br><span class="line"></span><br><span class="line">@header &#123;</span><br><span class="line">package com.nosuchfield.csv.code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">csv: hdr row*;</span><br><span class="line">hdr: row;</span><br><span class="line">row: field (&#x27;,&#x27; field)* &#x27;\r&#x27;? &#x27;\n&#x27;;</span><br><span class="line">field: TEXT # text | STRING # string | # empty;</span><br><span class="line"></span><br><span class="line">TEXT: ~[\n,\r]+;</span><br><span class="line">STRING: &#x27;&quot;&#x27; (&#x27;&quot;&quot;&#x27; | ~&#x27;&quot;&#x27;)* &#x27;&quot;&#x27;;</span><br></pre></td></tr></table></figure><p>之后配置代码生成目录为<code>com/nosuchfield/csv/code</code>，并去掉生成Visitor的选项，勾选生成Listener的选项，使用antlr4生成代码，生成的Java代码如下</p><pre><code>CsvBaseListener.java
CsvLexer.java
CsvListener.java
CsvParser.java
</code></pre><p>可以看到除了Lexer和Parser，还生成了相应的Listener代码。我们创建一个继承自CsvBaseListener的类如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nosuchfield.csv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.nosuchfield.csv.code.CsvBaseListener;</span><br><span class="line"><span class="keyword">import</span> com.nosuchfield.csv.code.CsvParser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CsvListener</span> <span class="keyword">extends</span> <span class="title class_">CsvBaseListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CSV的多行数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Map&lt;String, String&gt;&gt; rows = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CSV的头部</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一行CSV数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; row;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进入一行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterRow</span><span class="params">(CsvParser.RowContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个list用来保存这一行的数据</span></span><br><span class="line">        row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 离开TEXT</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitText</span><span class="params">(CsvParser.TextContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加这一列的数据</span></span><br><span class="line">        row.add(ctx.TEXT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitString</span><span class="params">(CsvParser.StringContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取字符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> ctx.STRING().getText();</span><br><span class="line">        <span class="comment">// 移除头部和尾部的双引号</span></span><br><span class="line">        field = field.substring(<span class="number">1</span>, field.length() - <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 因为CSV在双引号中用两个双引号代表单引号，这里转回来</span></span><br><span class="line">        field = field.replaceAll(<span class="string">&quot;\&quot;\&quot;&quot;</span>, <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">        row.add(field);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitEmpty</span><span class="params">(CsvParser.EmptyContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加空字符串</span></span><br><span class="line">        row.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 离开某一行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitRow</span><span class="params">(CsvParser.RowContext ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.getParent() <span class="keyword">instanceof</span> CsvParser.HdrContext) &#123;</span><br><span class="line">            <span class="comment">// 如果某一行的父节点是header头部</span></span><br><span class="line">            <span class="comment">// 那么就把header的值设置成这一行的数据</span></span><br><span class="line">            header = row;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, String&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 某一行已经遍历完毕，将这一行的数据和header组合起来，构成一个map</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row.size(); i++) &#123;</span><br><span class="line">            data.put(header.get(i), row.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将这一行数据添加到数据集中</span></span><br><span class="line">        rows.add(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map&lt;String, String&gt;&gt; <span class="title function_">getRows</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上的Listener在进入行的时候初始化容器，在退出字段的时候将字段的数据保存到容器中，并在退出行的时候最终保存所有的字段。我们通过Lexer和Parser来解析上面的CSV数据，最终生成一个ParseTree，并调用Listener遍历ParseTree来解析生成的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCsv</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 从文件中取得CSV数据流，并生成lexer</span></span><br><span class="line">    <span class="type">CsvLexer</span> <span class="variable">lexer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CsvLexer</span>(CharStreams.fromFileName(<span class="string">&quot;src/main/resources/csv/city.csv&quot;</span>));</span><br><span class="line">    <span class="comment">// 根据lexer生成token</span></span><br><span class="line">    <span class="type">CommonTokenStream</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonTokenStream</span>(lexer);</span><br><span class="line">    <span class="comment">// 将token交给parser</span></span><br><span class="line">    <span class="type">CsvParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CsvParser</span>(tokens);</span><br><span class="line">    <span class="comment">// 生成语法树</span></span><br><span class="line">    <span class="type">ParseTree</span> <span class="variable">tree</span> <span class="operator">=</span> parser.csv();</span><br><span class="line">    <span class="comment">// 打印语法树</span></span><br><span class="line">    System.out.println(tree.toStringTree(parser));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建语法树遍历器</span></span><br><span class="line">    <span class="type">ParseTreeWalker</span> <span class="variable">parseTreeWalker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParseTreeWalker</span>();</span><br><span class="line">    <span class="comment">// 语法树监听器</span></span><br><span class="line">    <span class="type">CsvListener</span> <span class="variable">listener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CsvListener</span>();</span><br><span class="line">    <span class="comment">// 遍历语法树</span></span><br><span class="line">    parseTreeWalker.walk(listener, tree);</span><br><span class="line">    <span class="comment">// 打印生成的结果</span></span><br><span class="line">    System.out.println(listener.getRows());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面的代码得到结果如下，可以看到完整的打印出了CSV的数据</p><pre><code>(csv (hdr (row (field 省份) , (field 城市) , (field 区县) , (field 描述) \r \n)) (row (field 江苏) , (field 南京) , (field 雨花台) , (field 外包大道) \r \n) (row (field 浙江) , (field 杭州) , (field 西湖) , (field 太美丽啦！西湖) \r \n) (row field , (field 上海) , (field 黄浦) , (field &quot;as it says: &quot;&quot;hello, shanghai&quot;&quot;&quot;) \r \n))
[&#123;省份=江苏, 描述=外包大道, 城市=南京, 区县=雨花台&#125;, &#123;省份=浙江, 描述=太美丽啦！西湖, 城市=杭州, 区县=西湖&#125;, &#123;省份=, 描述=as it says: &quot;hello, shanghai&quot;, 城市=上海, 区县=黄浦&#125;]
</code></pre><h2 id="通过Listener构建一个计算器"><a href="#通过Listener构建一个计算器" class="headerlink" title="通过Listener构建一个计算器"></a>通过Listener构建一个计算器</h2><p>在上面的例子中，我们已经使用了Visitor实现了一个计算器，实际上通过Listener也可以实现相同的功能。在Visitor中我们通过方法的返回值来存储计算结果，在Listener中方法没有返回值，那我们就需要通过另一种方式来进行计算并存储计算结果 —— 栈。</p><p>还是使用上面的词法分析和语法分析规则，这次我们勾选生成Listener选项，之后再次生成代码，这次会生成<code>CalcListener</code>接口和<code>CalcBaseListener</code>类，我们实现一个继承自<code>CalcBaseListener</code>的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculateListener</span> <span class="keyword">extends</span> <span class="title class_">CalcBaseListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MathContext</span> <span class="variable">MATH_CONTEXT</span> <span class="operator">=</span> MathContext.DECIMAL128;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;BigDecimal&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal result;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enterCalculationBlock</span><span class="params">(CalcParser.CalculationBlockContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建新的栈</span></span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitCalculationBlock</span><span class="params">(CalcParser.CalculationBlockContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 取出栈顶元素作为结果</span></span><br><span class="line">        result = stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitExpressionMulOrDiv</span><span class="params">(CalcParser.ExpressionMulOrDivContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 将栈顶的两个元素取出来做乘除法，将结果压回栈</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        BigDecimal z;</span><br><span class="line">        <span class="keyword">switch</span> (ctx.op.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CalcLexer.MUL:</span><br><span class="line">                z = y.multiply(x, MATH_CONTEXT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CalcLexer.DIV:</span><br><span class="line">                z = y.divide(x, MATH_CONTEXT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;unsupported operator type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitExpressionAddOrSub</span><span class="params">(CalcParser.ExpressionAddOrSubContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 将栈顶两个元素取出来做加减法，将结果压回栈</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        BigDecimal z;</span><br><span class="line">        <span class="keyword">switch</span> (ctx.op.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CalcLexer.ADD:</span><br><span class="line">                z = y.add(x, MATH_CONTEXT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CalcLexer.SUB:</span><br><span class="line">                z = y.subtract(x, MATH_CONTEXT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;unsupported operator type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exitExpressionNumeric</span><span class="params">(CalcParser.ExpressionNumericContext ctx)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算数字</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">numeric</span> <span class="operator">=</span> numberOrPercent(ctx.num);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(ctx.sign) &amp;&amp; ctx.sign.getType() == CalcLexer.SUB) &#123;</span><br><span class="line">            numeric = numeric.negate();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(numeric);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal <span class="title function_">numberOrPercent</span><span class="params">(Token num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">numberStr</span> <span class="operator">=</span> num.getText();</span><br><span class="line">        <span class="keyword">switch</span> (num.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> CalcLexer.NUMBER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(numberStr);</span><br><span class="line">            <span class="keyword">case</span> CalcLexer.PERCENT_NUMBER:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(numberStr.substring(<span class="number">0</span>, numberStr.length() - <span class="number">1</span>).trim())</span><br><span class="line">                        .divide(BigDecimal.valueOf(<span class="number">100</span>), MATH_CONTEXT);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;unsupported number type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取计算结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码和Visitor非常相似，区别在于针对加减法和乘除法的计算，Visitor是直接拿方法参数计算，并将结果作为返回值返回。而Listener是从栈的顶部取出两个元素进行计算，并将计算结果压回栈。</p><p>如果你了解方法调用的一般方式，就应该知道其实方法调用的一般方式也是通过栈来存储方法的入参和出参的。在方法调用前，将方法入参的值压入栈中，之后运行方法，如果方法中还有方法调用，继续将入参压入栈。当方法开始执行时，将方法的入参弹出，等到方法执行完毕，将执行完毕的方法返回值压入栈，如此往复就形成了方法调用。</p><p>因此我们可以知道，计算Visitor和Listener的逻辑基本一致，都是使用栈来存储计算的数值和计算的结果。区别在于Visitor的值是存储在当前运行线程的栈上的，如果值过多，可能因为栈空间不够导致StackOverflow错误。而Listener的值是保存在我们自定义的位于堆内存的栈数据结构上的，可以存储更多的数据内容。</p><p>完整的代码位于<a target="_blank" rel="noopener" href="https://github.com/RitterHou/test-antlr4">https://github.com/RitterHou/test-antlr4</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/27082372/">ANTLR 4权威指南</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7018521754125467661">语法解析器ANTLR4从入门到实践</a><br><a target="_blank" rel="noopener" href="https://juejin.cn/post/7088991644594208782">从一个小例子理解Antlr4</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/546679086">Antlr4系列（二）：实现一个计算器</a><br><a target="_blank" rel="noopener" href="https://decaf-lang.github.io/minidecaf-tutorial/docs/step1/antlr.html">ANTLR 使用——以表达式语法为例</a><br><a target="_blank" rel="noopener" href="https://iamazy.github.io/2020/02/12/antlr4-jiao-cheng/">Antlr4教程</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="ANTLR4从入门到实践">https://www.nosuchfield.com/2023/08/26/ANTLR4-from-Beginning-to-Practice/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%99%A8/" rel="tag">编译器</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">词法分析</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" rel="tag">语法分析</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>