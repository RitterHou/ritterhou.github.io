<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>一次网络超时的排查 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="分布式系统,网络,TCP协议"><meta name="description" content="&lt;p&gt;最近在测试一个分布式组件的时候，发现节点之间会频繁的出现网络传输超时的情况。组件的工作原理如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点1向节点2发送心跳包，发送之后等待节点2的回应&lt;/li&gt;
&lt;li&gt;节点2在收到心跳包之后做一些处理，随后发送回复报文给节点1&lt;/li&gt;
&lt;li&gt;节点1收到节点2回复的报文并退出等待，一次数据传输结束&lt;/li&gt;
&lt;li&gt;节点1如果一段时间内没有收到节点2的回应就会发生超时异常&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们遇到的问题就是节点1总是在运行一段时间之后（很短，大约几秒钟），发送给节点2的数据就无法及时的得到回应，随后节点1报出超时异常。问题在于我们用于测试的机器应该都在同一个机房，而我们设置的超时时间为50ms，同一个机房的节点延迟怎么会超过50ms呢？&lt;/p&gt;
&lt;h3 id=&#34;日志&#34;&gt;&lt;a href=&#34;#日志&#34; class=&#34;headerlink&#34; title=&#34;日志&#34;&gt;&lt;/a&gt;日志&lt;/h3&gt;&lt;p&gt;因为是分布式系统，并且涉及到网络传输，我们基本上没有办法使用DEBUG来进行调试，所以日志成为了排解问题的唯一线索。顺便说一句，在写代码的时候日志应该越详细越好，"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">一次网络超时的排查</h1></div><div class="post-meta"><span class="post-time">2019-08-14</span></div><div class="post-content"><p>最近在测试一个分布式组件的时候，发现节点之间会频繁的出现网络传输超时的情况。组件的工作原理如下</p><ol><li>节点1向节点2发送心跳包，发送之后等待节点2的回应</li><li>节点2在收到心跳包之后做一些处理，随后发送回复报文给节点1</li><li>节点1收到节点2回复的报文并退出等待，一次数据传输结束</li><li>节点1如果一段时间内没有收到节点2的回应就会发生超时异常</li></ol><p>我们遇到的问题就是节点1总是在运行一段时间之后（很短，大约几秒钟），发送给节点2的数据就无法及时的得到回应，随后节点1报出超时异常。问题在于我们用于测试的机器应该都在同一个机房，而我们设置的超时时间为50ms，同一个机房的节点延迟怎么会超过50ms呢？</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>因为是分布式系统，并且涉及到网络传输，我们基本上没有办法使用DEBUG来进行调试，所以日志成为了排解问题的唯一线索。顺便说一句，在写代码的时候日志应该越详细越好，日志除了打印变量数据，还应该附带好详细的上下文信息。</p><p>我们在发送数据和接收数据的地方都打上日志，此外应该对所使用的节点的时间进行校对，我们在分析问题时很依赖于日志中记录的时间信息。</p><p>我们执行程序获取日志如下</p><p>发送端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019/08/14 15:18:45.703679 node.go:233: 202(me) send AppendEntries to 92</span><br><span class="line">2019/08/14 15:18:45.753927 node.go:259: 202(me) to 92 AppendEntries timeout and retry</span><br><span class="line">2019/08/14 15:18:45.763991 node.go:233: 202(me) send AppendEntries to 92</span><br><span class="line">2019/08/14 15:18:45.814221 node.go:259: 202(me) to 92 AppendEntries timeout and retry</span><br><span class="line">2019/08/14 15:18:45.824193 node.go:233: 202(me) send AppendEntries to 92</span><br><span class="line">2019/08/14 15:18:45.874455 node.go:259: 202(me) to 92 AppendEntries timeout and retry</span><br></pre></td></tr></table></figure><p>我们观察以上日志发现确实发送端在发送了心跳50ms后因为没有收到响应随即超时了，接下来我们再观察接收端的日志。根据上面的日志我们已经知道了异常发生在 703ms ~ 874ms 之间，所以我们在观察接收端的日志时应该重点关注703、763、824这三个发送了心跳的时间点，接收端有如下日志信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2019/08/14 15:18:45.655403 connection.go:387: AppendEntries</span><br><span class="line"></span><br><span class="line">2019/08/14 15:18:45.655477 connection.go:95: Read Start</span><br><span class="line">2019/08/14 15:18:45.895077 connection.go:99: Read End</span><br><span class="line">2019/08/14 15:18:45.895112 connection.go:100: Read 1 bytes and cost 239ms 239574218ns</span><br><span class="line">2019/08/14 15:18:45.895379 connection.go:387: AppendEntries</span><br><span class="line"></span><br><span class="line">2019/08/14 15:18:45.895439 connection.go:95: Read Start</span><br><span class="line">2019/08/14 15:18:45.895452 connection.go:99: Read End</span><br><span class="line">2019/08/14 15:18:45.895464 connection.go:100: Read 1 bytes and cost 0ms 4203ns</span><br><span class="line">2019/08/14 15:18:45.895711 connection.go:387: AppendEntries</span><br><span class="line"></span><br><span class="line">2019/08/14 15:18:45.895766 connection.go:95: Read Start</span><br><span class="line">2019/08/14 15:18:45.895779 connection.go:99: Read End</span><br><span class="line">2019/08/14 15:18:45.895791 connection.go:100: Read 1 bytes and cost 0ms 3862ns</span><br><span class="line">2019/08/14 15:18:45.896082 connection.go:387: AppendEntries</span><br></pre></td></tr></table></figure><p>观察接收端的日志我们发现在655ms的时候接收端接收到最后一次正常的心跳，随后就被阻塞在read调用上，下一次读取到心跳信息则是在895ms，并且随后很快的就读完了三次心跳的数据。很显然，895 远大于 703、763、824，那么是什么原因导致了发送端在这三个时间点发送的报文一直到200多毫秒之后才被接收端成功的读取到呢？</p><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><p>我们使用tcpdump工具来获取网络报文信息，从而了解数据的传输情况。因为我们的组件使用6300端口进行数据传输，所以在两个节点上面都要执行如下命令来抓取通过6300端口的报文</p><pre><code>tcpdump tcp port 6300
</code></pre><p>我在上一步执行程序的时候已经打开了tcpdump命令，所以现在我们已经可以观察tcpdump的输出信息了。首先观察发送端发送的信息，同样我们只关注 703ms ~ 874ms 之间的信息。该时间段的信息如下，需要注意有一些网络数据报文与我们要关注的内容无关，直接忽略即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">15:18:45.643425 IP lin-21-34-202.bmc-grx &gt; 172.21.3.92.57619: Flags [P.], seq 525:546, ack 164, win 114, options [nop,nop,TS val 3450638986 ecr 3259647687], length 21</span><br><span class="line">15:18:45.664930 IP 172.21.3.92.57619 &gt; lin-21-34-202.bmc-grx: Flags [P.], seq 164:170, ack 546, win 115, options [nop,nop,TS val 3259647744 ecr 3450638986], length 6</span><br><span class="line">15:18:45.703607 IP lin-21-34-202.bmc-grx &gt; 172.21.3.92.57619: Flags [P.], seq 546:567, ack 170, win 114, options [nop,nop,TS val 3450639047 ecr 3259647744], length 21</span><br><span class="line">15:18:45.763909 IP lin-21-34-202.bmc-grx &gt; 172.21.3.92.57619: Flags [P.], seq 567:588, ack 170, win 114, options [nop,nop,TS val 3450639107 ecr 3259647744], length 21</span><br><span class="line">15:18:45.784473 IP 172.21.3.92.57619 &gt; lin-21-34-202.bmc-grx: Flags [.], ack 546, win 115, options [nop,nop,TS val 3259647863 ecr 3450638986,nop,nop,sack 1 &#123;567:588&#125;], length 0</span><br><span class="line">15:18:45.824084 IP lin-21-34-202.bmc-grx &gt; 172.21.3.92.57619: Flags [P.], seq 588:609, ack 170, win 114, options [nop,nop,TS val 3450639167 ecr 3259647863], length 21</span><br><span class="line">15:18:45.840677 IP 172.21.3.92.57619 &gt; lin-21-34-202.bmc-grx: Flags [.], ack 546, win 115, options [nop,nop,TS val 3259647920 ecr 3450638986,nop,nop,sack 1 &#123;567:609&#125;], length 0</span><br><span class="line">15:18:45.869809 IP 172.21.3.92.57619 &gt; lin-21-34-202.bmc-grx: Flags [P.], seq 170:183, ack 546, win 115, options [nop,nop,TS val 3259647948 ecr 3450638986,nop,nop,sack 1 &#123;567:609&#125;], length 13</span><br><span class="line">15:18:45.870435 IP lin-21-34-202.bmc-grx &gt; 172.21.3.92.57619: Flags [P.], seq 609:615, ack 183, win 114, options [nop,nop,TS val 3450639213 ecr 3259647948], length 6</span><br><span class="line">15:18:45.884354 IP lin-21-34-202.bmc-grx &gt; 172.21.3.92.57619: Flags [P.], seq 615:636, ack 183, win 114, options [nop,nop,TS val 3450639227 ecr 3259647948], length 21</span><br><span class="line">15:18:45.886702 IP 172.21.3.92.57619 &gt; lin-21-34-202.bmc-grx: Flags [.], ack 546, win 115, options [nop,nop,TS val 3259647966 ecr 3450638986,nop,nop,sack 1 &#123;567:615&#125;], length 0</span><br><span class="line">15:18:45.886732 IP lin-21-34-202.bmc-grx &gt; 172.21.3.92.57619: Flags [P.], seq 546:567, ack 183, win 114, options [nop,nop,TS val 3450639230 ecr 3259647948], length 21</span><br><span class="line">15:18:45.902699 IP 172.21.3.92.57619 &gt; lin-21-34-202.bmc-grx: Flags [.], ack 546, win 115, options [nop,nop,TS val 3259647981 ecr 3450638986,nop,nop,sack 1 &#123;567:636&#125;], length 0</span><br><span class="line">15:18:45.903892 IP 172.21.3.92.57619 &gt; lin-21-34-202.bmc-grx: Flags [.], ack 636, win 115, options [nop,nop,TS val 3259647983 ecr 3450639230], length 0</span><br></pre></td></tr></table></figure><p>其中<code>lin-21-34-202</code>是节点1，<code>172.21.3.92.57619</code>是节点2，即心跳是由<code>lin-21-34-202</code>发送给<code>172.21.3.92</code>的。Flags中的 P 代表 PUSH， . 代表 ACK。</p><p>已知我们心跳的长度为12，由上面的报文以及前面的日志我们可以推测出来，第一行的信息代表了最后一次节点1给节点2发送的正常心跳信息。</p><p>随后节点1发送了seq为 <code>546:567</code> 和 <code>567:588</code> 的两条心跳包，这就是第3第4行的信息。奇怪的是在第5行所代表的节点2回复的ACK中，只表示收到了 <code>567:588</code> 的的数据包，没有 <code>546:567</code>。第6第7行表示了发送的第三个心跳包 <code>588:609</code> 以及相应的ACK <code>567:609</code>。</p><p>节点1发现节点2迟迟不回复 <code>546:567</code> 的ACK，就对 <code>546:567</code> 进行了重发，这就是第12行的信息。这一次节点2终于回复了ACK（第14行），我们可以认为 <code>546:567</code> 确定被发送到节点2了。</p><p>随后我们再看一下接收端的报文信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">15:18:45.654608 IP 172.21.34.202.bmc-grx &gt; lin-21-3-92.57619: Flags [P.], seq 525:546, ack 164, win 114, options [nop,nop,TS val 3450638986 ecr 3259647687], length 21</span><br><span class="line">15:18:45.655249 IP lin-21-3-92.57619 &gt; 172.21.34.202.bmc-grx: Flags [P.], seq 164:170, ack 546, win 115, options [nop,nop,TS val 3259647744 ecr 3450638986], length 6</span><br><span class="line">15:18:45.774317 IP 172.21.34.202.bmc-grx &gt; lin-21-3-92.57619: Flags [P.], seq 567:588, ack 170, win 114, options [nop,nop,TS val 3450639107 ecr 3259647744], length 21</span><br><span class="line">15:18:45.774348 IP lin-21-3-92.57619 &gt; 172.21.34.202.bmc-grx: Flags [.], ack 546, win 115, options [nop,nop,TS val 3259647863 ecr 3450638986,nop,nop,sack 1 &#123;567:588&#125;], length 0</span><br><span class="line">15:18:45.831770 IP 172.21.34.202.bmc-grx &gt; lin-21-3-92.57619: Flags [P.], seq 588:609, ack 170, win 114, options [nop,nop,TS val 3450639167 ecr 3259647863], length 21</span><br><span class="line">15:18:45.831795 IP lin-21-3-92.57619 &gt; 172.21.34.202.bmc-grx: Flags [.], ack 546, win 115, options [nop,nop,TS val 3259647920 ecr 3450638986,nop,nop,sack 1 &#123;567:609&#125;], length 0</span><br><span class="line">15:18:45.859801 IP lin-21-3-92.57619 &gt; 172.21.34.202.bmc-grx: Flags [P.], seq 170:183, ack 546, win 115, options [nop,nop,TS val 3259647948 ecr 3450638986,nop,nop,sack 1 &#123;567:609&#125;], length 13</span><br><span class="line">15:18:45.877852 IP 172.21.34.202.bmc-grx &gt; lin-21-3-92.57619: Flags [P.], seq 609:615, ack 183, win 114, options [nop,nop,TS val 3450639213 ecr 3259647948], length 6</span><br><span class="line">15:18:45.877870 IP lin-21-3-92.57619 &gt; 172.21.34.202.bmc-grx: Flags [.], ack 546, win 115, options [nop,nop,TS val 3259647966 ecr 3450638986,nop,nop,sack 1 &#123;567:615&#125;], length 0</span><br><span class="line">15:18:45.892884 IP 172.21.34.202.bmc-grx &gt; lin-21-3-92.57619: Flags [P.], seq 615:636, ack 183, win 114, options [nop,nop,TS val 3450639227 ecr 3259647948], length 21</span><br><span class="line">15:18:45.892901 IP lin-21-3-92.57619 &gt; 172.21.34.202.bmc-grx: Flags [.], ack 546, win 115, options [nop,nop,TS val 3259647981 ecr 3450638986,nop,nop,sack 1 &#123;567:636&#125;], length 0</span><br><span class="line">15:18:45.894971 IP 172.21.34.202.bmc-grx &gt; lin-21-3-92.57619: Flags [P.], seq 546:567, ack 183, win 114, options [nop,nop,TS val 3450639230 ecr 3259647948], length 21</span><br><span class="line">15:18:45.894989 IP lin-21-3-92.57619 &gt; 172.21.34.202.bmc-grx: Flags [.], ack 636, win 115, options [nop,nop,TS val 3259647983 ecr 3450639230], length 0</span><br></pre></td></tr></table></figure><p>接收端的报文基本上就是发送端的镜像，但是有趣的是接收端的报文只有13条，而发送端则发送了14条报文。仔细对比就发现发送端的 <code>seq 546:567</code> 在接收端不存在，看来这个报文在网络传输中丢失了没能成功到达节点2。节点2在节点1再次重传后才最终获取了 <code>546:567</code> 的报文信息，即接收端的第12行，此时时间点为 <code>15:18:45.894971</code>，最后节点2返回给节点1 ACK。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>观察上面接收端收到重传数据的时间为 <code>15:18:45.894971</code>，日志中接收端用户态成功读取到报文的时间为 <code>15:18:45.895077</code>，那结果就明显了。</p><p>节点1发送给节点2的第一个心跳包丢失了，因为TCP协议中数据的有序性，所以虽然后面的数据成功到达也不能将这些数据返回给用户态程序。一直到节点1因为没能得到ACK而进行超时重传，节点2最终获取了心跳包1，此时数据已经完整可以返回给用户态程序。这一顿操作也导致这部分数据从节点1的用户态到节点2的用户态之间产生了 894 - 703 约200ms的延迟，因而节点1产生了超时。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>咦，为什么同一个机房的两个机器之间会丢包呢，难道路由器出问题了？经过检查之后发现是我们自己搞错了，在申请机器的时候我们第一次申请的机器在南京，第二次申请的机器在杭州，所以这两个机器其实并不是在一个机房并且之间隔了接近300km，产生丢包的现象也就可以理解了。虽然问题产生的原因很囧，但是这次耗时两天的问题排查还是让我很有收获的，切换了负载之后问题也就成功解决了。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="一次网络超时的排查">https://www.nosuchfield.com/2019/08/14/Network-timeout-troubleshooting/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/TCP%E5%8D%8F%E8%AE%AE/" rel="tag">TCP协议</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="tag">分布式系统</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>