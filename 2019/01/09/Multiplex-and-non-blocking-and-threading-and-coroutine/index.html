<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>多路复用、非阻塞、线程与协程 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="操作系统,网络编程"><meta name="description" content="&lt;h3 id=&#34;线程与阻塞&#34;&gt;&lt;a href=&#34;#线程与阻塞&#34; class=&#34;headerlink&#34; title=&#34;线程与阻塞&#34;&gt;&lt;/a&gt;线程与阻塞&lt;/h3&gt;&lt;p&gt;在传统的blockIO中，一个TCP连接的可读事件与用户的实际读取操作是糅合在一起的。用户想要读取数据只需要调用read系统调用，之后当前线程会阻塞在这里直到当前连接的读缓冲区有数据可读，此时操作系统会调度让此线程退出阻塞状态继续执行，在用户态我们就可以实现读取数据的操作了。&lt;/p&gt;
&lt;p&gt;此时的读取操作都是阻塞的，不过因为用户直接用一个线程来实现一个连接的读写，当前线程的阻塞并不会对其它的连接产生影响，所以阻塞也无所谓。&lt;/p&gt;
&lt;p&gt;后来因为C10k问题，也就是如何让一个操作系统能同时维护10k个连接的问题的提出，传统的blockIO模型已经不能符合人们此时的需求。因为在传统的IO模型中，TCP连接的可读可写事件以及读写操作本身都被实现在READ和WRITE系统调用中，而读写事件本身会阻塞当前线程，这也就导致了我们必须要给每一个读写操作分配一个单独的线程。&lt;/p&gt;
&lt;p&gt;因为传统IO需要一个连接对应着一个线程，所以当连接"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">多路复用、非阻塞、线程与协程</h1></div><div class="post-meta"><span class="post-time">2019-01-09</span></div><div class="post-content"><h3 id="线程与阻塞"><a href="#线程与阻塞" class="headerlink" title="线程与阻塞"></a>线程与阻塞</h3><p>在传统的blockIO中，一个TCP连接的可读事件与用户的实际读取操作是糅合在一起的。用户想要读取数据只需要调用read系统调用，之后当前线程会阻塞在这里直到当前连接的读缓冲区有数据可读，此时操作系统会调度让此线程退出阻塞状态继续执行，在用户态我们就可以实现读取数据的操作了。</p><p>此时的读取操作都是阻塞的，不过因为用户直接用一个线程来实现一个连接的读写，当前线程的阻塞并不会对其它的连接产生影响，所以阻塞也无所谓。</p><p>后来因为C10k问题，也就是如何让一个操作系统能同时维护10k个连接的问题的提出，传统的blockIO模型已经不能符合人们此时的需求。因为在传统的IO模型中，TCP连接的可读可写事件以及读写操作本身都被实现在READ和WRITE系统调用中，而读写事件本身会阻塞当前线程，这也就导致了我们必须要给每一个读写操作分配一个单独的线程。</p><p>因为传统IO需要一个连接对应着一个线程，所以当连接数过多时线程数也很多，现代操作系统在线程过多时运行效率会明显降低，这主要是因为两个原因</p><ol><li>操作系统需要为每一个线程存储一些meta信息（包括线程的当前上下文状态等等），当线程数过多时，会对内存造成一定的压力。</li><li>操作系统的线程切换操作是十分耗费系统资源的，当线程数过多时，线程切换的频率大大增加，线程切换次数变多会导致整个系统的吞吐量降低，因而会影响用户程序的执行效率。</li></ol><p>现代操作系统使用多路复用和非阻塞来解决C10K问题，它们的核心在于细化了对连接的管理方式。以前我们管理连接只能使用READ和WRITE，然后无脑开个线程，让操作系统来帮助我们管理连接的可读可写事件。为了解决这些问题，我们开始需要自己管理连接的读写事件。</p><p>首先我们把连接的操作进行拆分，不再像以前那样READ和WRITE一把梭，而是把<strong>可读可写</strong>和<strong>读写操作本身</strong>进行拆分。我们之前说过，我们之所以要给每一个连接创建一个线程，是为了能让操作系统帮助我们管理每一个连接的读写事件。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>我们把一个连接的可读可写事件剥离出来，使用单独的线程来对其进行管理，这里的关键点在于此线程不仅可以管理一个线程的可读可写事件，事实上这个线程中我们可以管理多个连接的可读可写事件，这个线程中实现的操作就叫<strong>多路复用</strong>，多路复用需要操作系统提供相应的syscall才可以使用。</p><p>有了多路复用器，连接与线程之间的紧密联系被拆开。不再需要太多的线程，我们可以在仅一个线程中就维护着数百万个连接的读写事件，C10k问题被解决。</p><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>多路复用解决的是维护大量TCP连接的状态以及它们的可读可写事件的问题，这是我们在连接的可读可写事件上进行的优化，接下来我们需要对连接数据的读写操作本身进行优化。</p><p>一般来说，在从多路复用器得到了一个连接可读或者可写的讯息之后，我们就需要对这个连接进行读写操作了。因为多路复用器所在的线程可能会阻塞，所以我们一般会把这些连接的读写操作放到新的线程中。因为读写操作本身也可能导致线程阻塞（例如读取数据的数量还不满足要求），所以此时我们仍然需要为每一个连接的读写操作开辟新的线程（也可以使用线程池），这在读写连接较少的情况下没什么问题，但是在有大量连接都需要进行读写操作时仍然会产生大量的线程，降低系统吞吐量。</p><p>解决办法是使用非阻塞IO，即一旦当前连接读缓冲区中的数据已被读完或当前连接的写缓冲区中的数据已满，则READ或WRITE系统调用立即返回，而不是阻塞住当前线程。有了非阻塞IO，我们就可以在一个线程中进行多个连接的读写操作而不用担心某一个连接会导致当前线程阻塞，这样我们就能降低读写操作所需要的线程的数量了。</p><table><thead><tr><th>传统IO</th><th>多路复用</th><th>非阻塞</th></tr></thead><tbody><tr><td>读写事件被绑定在读写操作上，读写操作本身是阻塞的</td><td>把读写事件剥离出读写操作本身，单个线程可以管理数百万个连接的读写事件，读写操作本身还是阻塞的</td><td>读写操作本身是非阻塞的，可以在少量线程中实现大量连接的读写操作</td></tr></tbody></table><p>这三种类型的IO模型的使用情况如下图：</p><p><img src="/images/20190109/io.png"></p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是用户态层面的代码执行管理单元，可以类比操作系统的线程。</p><table><thead><tr><th>类型</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>被调度时meta数据的存储区域</td><td>内核态内存空间</td><td>用户态内存空间</td></tr><tr><td>切换操作</td><td>需要调用操作系统内核提供的syscall</td><td>简单的现场保存和恢复即可</td></tr><tr><td>调度机制</td><td>现代操作系统都是抢占式的，由内核实现</td><td>依赖当前协程主动让出（yield）CPU资源</td></tr></tbody></table><p>由于多路复用与非阻塞的使用，导致单个连接的状态管理不再像BlockIO时那样的简单，而且因为线程不会阻塞在读写操作、尤其是读操作上，所以此时我们一般使用回调函数的方式来实现读操作。简单来说就是在读取时，如果已经读取的数据还不满足需求，程序就暂时把这些数据读取并保存在用户态的内存中，待数据读取满足要求之后就调用回调函数，通过异步的方式把数据交给相应的处理函数。</p><p>异步的问题在于不便于程序员的理解，人类更加习惯于同步的操作行为，异步的操作总是会显得晦涩而又难以理解，这会提升代码的复杂度。</p><p>我们可以使用协程对多路复用和非阻塞进行改造来实现同步的IO操作。首先我们在协程中调用我们自己实现的方法 <code>READ0</code>，该方法为阻塞方法，此时该协程被阻塞。在语言内部我们使用多路复用和非阻塞来管理连接和数据，一旦数据满足了要求，我们再次调度到该协程，此时 <code>READ0</code> 方法返回，在用户看来整个 <code>READ0</code> 方法就是同步阻塞的，非常易于程序员的使用。</p><p>此外，由于协程的数据都存储在用户态的内存空间且不需要通过syscall即可以调度，所以协程的调度相较于线程是非常轻量级的，事实上在go语言中我们可以开数十万个协程而不会有性能问题，而同样的机器上运行数千个线程就已经很吃力了。</p><p>协程和线程不存在相互替代的关系，它们都是对一个指定的逻辑流的抽象，它们之间是互补的关系。协程和线程的发展历史大致如下：</p><ol><li>早期一台计算机上面只能执行一个程序</li><li>一台机器上只执行一个程序太浪费CPU资源了，我们可以写一个控制程序，当某个程序执行IO时就让出CPU资源交给另一个程序执行，这就是协程的思想</li><li>在多任务操作系统中，为了避免某个程序一直霸占CPU资源，抢占式的操作系统被发明，由操作系统内核对CPU的资源进行管理和分配（事实上不仅仅是CPU，现代操作系统实现了对计算机所有的硬件资源的高效的管理）</li><li>多核CPU被发明，我们可以直接在操作系统层面支持多核，面向程序员的线程模型无需改变</li><li>线程的切换需要内核的帮助，比较耗费系统资源。为了避免大量的使用线程，我们可以在单个进程中模拟早期的调度程序的行为，从而实现多个逻辑流的执行，这就是协程</li></ol><p>在操作系统层面，线程实现了抢占式多任务处理以及对多核CPU的支持；在用户层面，协程提供了统一的逻辑流的抽象，并向上提供编程模型。协程和线程之间是互补的关系，它们本质上都只是对一些的状态的维护。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/08.1.html">https://tiancaiamao.gitbooks.io/go-internals/content/zh/08.1.html</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="多路复用、非阻塞、线程与协程">https://www.nosuchfield.com/2019/01/09/Multiplex-and-non-blocking-and-threading-and-coroutine/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">网络编程</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>