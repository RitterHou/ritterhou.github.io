<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>ES数据节点对JVM进程的内存限制 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="操作系统,ElasticSearch"><meta name="description" content="&lt;h3 id=&#34;Filesystem-Cache&#34;&gt;&lt;a href=&#34;#Filesystem-Cache&#34; class=&#34;headerlink&#34; title=&#34;Filesystem Cache&#34;&gt;&lt;/a&gt;Filesystem Cache&lt;/h3&gt;&lt;p&gt;Elasticsearch高度依赖操作系统的filesystem cache来提升其数据读取效率，如果我们将大量的系统内存分配给JVM进程（例如将堆内存设置的很大），那么将导致操作系统无法得到足够的内存来作为filesystem cache，这会严重的影响Elasticsearch的性能。&lt;/p&gt;
&lt;p&gt;我们知道现代操作系统中的内存都是按页分配的，操作系统在把某些数据从外存读取到内存中的页面上时，会把紧邻在被读取数据后面的几个页面的数据也读到内存中，这叫做&lt;strong&gt;文件预读&lt;/strong&gt;，文件预读会极大的提升硬盘的顺序读取速度。除此之外，数据在被读取到内存中之后，即使用户已经使用完毕，操作系统也不会立即把这些数据所占用的内存给释放掉，这些数据会暂时的保存在内存中，如果此时用户开始读取硬盘上的同一块数据，操作系统会立即从内存中把该"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">ES数据节点对JVM进程的内存限制</h1></div><div class="post-meta"><span class="post-time">2019-03-25</span></div><div class="post-content"><h3 id="Filesystem-Cache"><a href="#Filesystem-Cache" class="headerlink" title="Filesystem Cache"></a>Filesystem Cache</h3><p>Elasticsearch高度依赖操作系统的filesystem cache来提升其数据读取效率，如果我们将大量的系统内存分配给JVM进程（例如将堆内存设置的很大），那么将导致操作系统无法得到足够的内存来作为filesystem cache，这会严重的影响Elasticsearch的性能。</p><p>我们知道现代操作系统中的内存都是按页分配的，操作系统在把某些数据从外存读取到内存中的页面上时，会把紧邻在被读取数据后面的几个页面的数据也读到内存中，这叫做<strong>文件预读</strong>，文件预读会极大的提升硬盘的顺序读取速度。除此之外，数据在被读取到内存中之后，即使用户已经使用完毕，操作系统也不会立即把这些数据所占用的内存给释放掉，这些数据会暂时的保存在内存中，如果此时用户开始读取硬盘上的同一块数据，操作系统会立即从内存中把该数据返回给用户而不需要再去操作硬盘进行数据读取操作，这部分暂时留存在内存中的数据就叫做<strong>页缓存</strong>(<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Page_cache">page cache</a>)。</p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>cache并不会影响进程的正常运行，一旦操作系统发现物理内存不够用，会立即从cache中分配内存页给进程使用。内存页的更新会使用LRU算法，LRU即Least Recent Used，该算法会淘汰最不经常使用的缓存页，其核心原则为“如果一个缓存页在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小”。</p><p>首先我们构建一个页面地址到实际页面的映射关系，我们可以根据这个地址对页面进行读取，这个映射关系我们使用哈希表进行存储。</p><table><thead><tr><th align="center">内存地址</th><th align="center">内存页</th></tr></thead><tbody><tr><td align="center">0x010000</td><td align="center">page1</td></tr><tr><td align="center">0x014096</td><td align="center">page2</td></tr><tr><td align="center">0x018192</td><td align="center">page3</td></tr><tr><td align="center">0x022288</td><td align="center">page4</td></tr><tr><td align="center">0x026384</td><td align="center">page5</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><p>内存页本身我们使用一个双向链表进行存储，其核心原理如下</p><ul><li>一旦一个页面被读取，则把这个页面移动到链表的头部</li><li>如果内存空间不足，则删除链表尾部的页面以换取充足的空间</li></ul><p>下面是一个go语言实现的LRU算法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Page <span class="keyword">struct</span> &#123;</span><br><span class="line">	prev  *Page</span><br><span class="line">	next  *Page</span><br><span class="line">	addr  <span class="type">int</span></span><br><span class="line">	value []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	table    = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*Page) <span class="comment">// 存储页面地址和页面之间的映射关系</span></span><br><span class="line">	head     = Page&#123;addr: <span class="number">-1</span>&#125;      <span class="comment">// 头部节点的前一个节点</span></span><br><span class="line">	tail     = Page&#123;addr: <span class="number">-1</span>&#125;      <span class="comment">// 尾部节点的后一个节点</span></span><br><span class="line">	capacity = <span class="number">10</span>                  <span class="comment">// 内存最多容纳的页数，默认为10</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据地址获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(addr <span class="type">int</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> addr &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;addr can&#x27;t be negative number&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不在内存中则需要去硬盘上读取</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := table[addr]; !ok &#123;</span><br><span class="line">		table[addr] = getFromDisk(addr)</span><br><span class="line">	&#125;</span><br><span class="line">	page, _ := table[addr]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果不位于头部则需要移动到头部</span></span><br><span class="line">	<span class="keyword">if</span> page.addr != head.next.addr &#123;</span><br><span class="line">		<span class="comment">// 删除此节点</span></span><br><span class="line">		<span class="keyword">if</span> page.prev != <span class="literal">nil</span> &amp;&amp; page.next != <span class="literal">nil</span> &#123;</span><br><span class="line">			page.prev.next = page.next</span><br><span class="line">			page.next.prev = page.prev</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 移动此节点到头部</span></span><br><span class="line">		page.next = head.next</span><br><span class="line">		page.next.prev = page</span><br><span class="line"></span><br><span class="line">		page.prev = &amp;head</span><br><span class="line">		head.next = page</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果超出容量限制则需要移除最后一个节点</span></span><br><span class="line">	<span class="keyword">if</span> getSize() &gt; capacity &#123;</span><br><span class="line">		<span class="built_in">delete</span>(table, tail.prev.addr)</span><br><span class="line"></span><br><span class="line">		tail.prev.prev.next = &amp;tail</span><br><span class="line">		tail.prev = tail.prev.prev</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟从硬盘上面获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFromDisk</span><span class="params">(addr <span class="type">int</span>)</span></span> *Page &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Page&#123;addr: addr&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页面数量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSize</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	size := <span class="number">0</span></span><br><span class="line">	page := head.next</span><br><span class="line">	<span class="keyword">for</span> page.addr &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		size += <span class="number">1</span></span><br><span class="line">		page = page.next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印双向链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pretty</span><span class="params">()</span></span> &#123;</span><br><span class="line">	page := head.next</span><br><span class="line">	value := strconv.Itoa(page.addr)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		page = page.next</span><br><span class="line">		<span class="keyword">if</span> page.addr &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		value += <span class="string">&quot;\t⇄\t&quot;</span> + strconv.Itoa(page.addr)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomNum</span><span class="params">(min <span class="type">int</span>, max <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> rand.Intn(max-min) + min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	head.next = &amp;tail</span><br><span class="line">	tail.prev = &amp;head</span><br><span class="line"></span><br><span class="line">	capacity = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">	rand.Seed(time.Now().UTC().UnixNano())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">15</span>; i++ &#123;</span><br><span class="line">		get(randomNum(<span class="number">0</span>, <span class="number">15</span>))</span><br><span class="line">		pretty()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到Elasticsearch的问题，假设我们有一个16g内存的机器，如果我们分配了14g内存给JVM进程，那么操作系统就无法充分使用内存作为filesystem cache来为磁盘的读取加速，具体表现就是Elasticsearch的查询变得缓慢。</p><h3 id="关闭缓存"><a href="#关闭缓存" class="headerlink" title="关闭缓存"></a>关闭缓存</h3><p>在Linux中页缓存是默认开启的，在Linux2.6之后你也可以使用 <code>O_DIRECT</code> 选项来关闭文件读取时的页缓存，这在某些特殊的情况下是有用的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://www.linuxatemyram.com/">Help! Linux ate my RAM!</a><br><a target="_blank" rel="noopener" href="http://0xffffff.org/2017/05/01/41-linux-io/">聊聊Linux IO</a><br><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/heap-sizing.html">堆内存:大小和交换 | Elasticsearch: 权威指南 | Elastic</a><br><a target="_blank" rel="noopener" href="https://elasticsearch.cn/article/32">ES内存那点事</a><br><a target="_blank" rel="noopener" href="https://blog.bcmeng.com/post/lru-lfu.html">LRU和LFU缓存置换算法</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="ES数据节点对JVM进程的内存限制">https://www.nosuchfield.com/2019/03/25/Memory-limit-of-the-ES-data-node-to-the-JVM-process/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/ElasticSearch/" rel="tag">ElasticSearch</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>