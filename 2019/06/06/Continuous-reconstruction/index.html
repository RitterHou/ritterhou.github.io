<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>持续重构 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="软件工程,重构"><meta name="description" content="&lt;p&gt;我们在写代码的时候需要避免的两种比较极端的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写代码时字字斟酌，过早的进行代码优化&lt;/li&gt;
&lt;li&gt;写代码随心所欲，直到使得项目代码变成一座“屎山”而没有人想去维护&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似于“持续集成”和“持续部署”的理念，我认为我们在写代码时应该可以做到&lt;strong&gt;持续重构&lt;/strong&gt;。持续重构的好处在于我们在写代码时不需要过分的去关注代码结构和性能优化，此时我们以最快的速度来实现功能，这样的好处是可以提高开发效率；在一个小模块开发完成之后要立即进行重构，由于代码的基础逻辑已经完成，此时只需要在原有的代码上进行性能和结构优化的重构，这样比一开始就直接写出最优的代码要轻松的多。如果在最开始就开始考虑写出最优的代码，那么写代码的时候就需要同时考虑多个方面的内容，这样不仅影响开发效率，也会导致模块开发整体性的缺失。&lt;/p&gt;
&lt;p&gt;持续重构的核心思想和持续集成一致，即我们无法做到完整的、正确的去完成一个事情，那么我们就把这个事情拆分为一个个小块的、可以被完成的事情，这样再去做就降低了事情复杂度。具体到重构就是我们有时候无法对一个巨大的"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">持续重构</h1></div><div class="post-meta"><span class="post-time">2019-06-06</span></div><div class="post-content"><p>我们在写代码的时候需要避免的两种比较极端的情况：</p><ul><li>写代码时字字斟酌，过早的进行代码优化</li><li>写代码随心所欲，直到使得项目代码变成一座“屎山”而没有人想去维护</li></ul><p>类似于“持续集成”和“持续部署”的理念，我认为我们在写代码时应该可以做到<strong>持续重构</strong>。持续重构的好处在于我们在写代码时不需要过分的去关注代码结构和性能优化，此时我们以最快的速度来实现功能，这样的好处是可以提高开发效率；在一个小模块开发完成之后要立即进行重构，由于代码的基础逻辑已经完成，此时只需要在原有的代码上进行性能和结构优化的重构，这样比一开始就直接写出最优的代码要轻松的多。如果在最开始就开始考虑写出最优的代码，那么写代码的时候就需要同时考虑多个方面的内容，这样不仅影响开发效率，也会导致模块开发整体性的缺失。</p><p>持续重构的核心思想和持续集成一致，即我们无法做到完整的、正确的去完成一个事情，那么我们就把这个事情拆分为一个个小块的、可以被完成的事情，这样再去做就降低了事情复杂度。具体到重构就是我们有时候无法对一个巨大的模块做修改与重构，那么在完成一个个小模块的时候就立即重构，这样事情就变得简单的多。</p><p>重构必须要以单元测试为前提，不然无法对代码的正确性做出保证；一般来说重构同时也需要辅以版本控制，不然可能会导致代码混乱。持续重构既避免了代码最终会变成一个不可维护的泥潭，也保证了开发效率，在实际开发中应该多多实践。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="持续重构">https://www.nosuchfield.com/2019/06/06/Continuous-reconstruction/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag">软件工程</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E9%87%8D%E6%9E%84/" rel="tag">重构</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>