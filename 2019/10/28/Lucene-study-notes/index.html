<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>Lucene学习笔记 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="Java,搜索引擎"><meta name="description" content="&lt;p&gt;Lucene是由Doug Cutting大神开发的，这哥们同时还创立了Nutch和Hadoop，他和QEMU、FFmpeg、tinycc、QuickJS的发明者Fabrice Bellard一样多产且开发的东西都十分牛逼。&lt;/p&gt;
&lt;p&gt;Lucene是一个Java开发的搜索引擎，其全文检索基于Inverted Index实现。此文章所使用的代码都可以在&lt;a href=&#34;https://github.com/RitterHou/test_lucene&#34;&gt;RitterHou&amp;#x2F;test_lucene&lt;/a&gt;中找到。&lt;/p&gt;
&lt;h2 id=&#34;基础使用&#34;&gt;&lt;a href=&#34;#基础使用&#34; class=&#34;headerlink&#34; title=&#34;基础使用&#34;&gt;&lt;/a&gt;基础使用&lt;/h2&gt;&lt;p&gt;首先我们对数据进行索引操作，这里我们选择了把数据存储在RAM中，但是要知道Lucene也支持把数据存储在磁盘上。&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/spa"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">Lucene学习笔记</h1></div><div class="post-meta"><span class="post-time">2019-10-28</span></div><div class="post-content"><p>Lucene是由Doug Cutting大神开发的，这哥们同时还创立了Nutch和Hadoop，他和QEMU、FFmpeg、tinycc、QuickJS的发明者Fabrice Bellard一样多产且开发的东西都十分牛逼。</p><p>Lucene是一个Java开发的搜索引擎，其全文检索基于Inverted Index实现。此文章所使用的代码都可以在<a target="_blank" rel="noopener" href="https://github.com/RitterHou/test_lucene">RitterHou&#x2F;test_lucene</a>中找到。</p><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>首先我们对数据进行索引操作，这里我们选择了把数据存储在RAM中，但是要知道Lucene也支持把数据存储在磁盘上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">index</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">directory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RAMDirectory</span>();</span><br><span class="line">    <span class="type">Analyzer</span> <span class="variable">analyzer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IKAnalyzer</span>();</span><br><span class="line">    <span class="type">IndexWriterConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriterConfig</span>(analyzer);</span><br><span class="line">    <span class="type">IndexWriter</span> <span class="variable">indexWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriter</span>(directory, config);</span><br><span class="line"></span><br><span class="line">    addDoc(indexWriter, <span class="string">&quot;游戏编程算法与技巧&quot;</span>, <span class="string">&quot;9787121276453&quot;</span>);</span><br><span class="line">    addDoc(indexWriter, <span class="string">&quot;计算机程序的构造和解释(原书第2版) : 原书第2版&quot;</span>, <span class="string">&quot;9787111135104&quot;</span>);</span><br><span class="line">    addDoc(indexWriter, <span class="string">&quot;编码 : 隐匿在计算机软硬件背后的语言&quot;</span>, <span class="string">&quot;9787121106101&quot;</span>);</span><br><span class="line">    addDoc(indexWriter, <span class="string">&quot;计算机网络（第5版）&quot;</span>, <span class="string">&quot;9787302274629&quot;</span>);</span><br><span class="line">    addDoc(indexWriter, <span class="string">&quot;Python网络编程攻略&quot;</span>, <span class="string">&quot;9787115372697&quot;</span>);</span><br><span class="line">    addDoc(indexWriter, <span class="string">&quot;UNIX网络编程&quot;</span>, <span class="string">&quot;9787302119746&quot;</span>);</span><br><span class="line">    addDoc(indexWriter, <span class="string">&quot;算法导论（原书第3版）&quot;</span>, <span class="string">&quot;9787111407010&quot;</span>);</span><br><span class="line"></span><br><span class="line">    indexWriter.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addDoc</span><span class="params">(IndexWriter w, String title, String isbn)</span> &#123;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">    <span class="comment">// TextField表示使用配置中分词器对字符串进行分词</span></span><br><span class="line">    doc.add(<span class="keyword">new</span> <span class="title class_">TextField</span>(<span class="string">&quot;title&quot;</span>, title, Field.Store.YES));</span><br><span class="line">    <span class="comment">// StringField则保存原始字符串而不进行分词</span></span><br><span class="line">    doc.add(<span class="keyword">new</span> <span class="title class_">StringField</span>(<span class="string">&quot;isbn&quot;</span>, isbn, Field.Store.YES));</span><br><span class="line">    w.addDocument(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码包含了</p><ul><li>创建内存Dir</li><li>创建IKAnalyzer分词器，这是一个中文分词器；把该分词器放到config对象中</li><li>创建IndexWriter对象</li><li>将数据创建为一条条的Document（文档）并进行存储</li></ul><p>上一步操作中数据已经被保存成功，下面进行数据检索的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Directory</span> <span class="variable">directory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RAMDirectory</span>();</span><br><span class="line"><span class="type">Query</span> <span class="variable">q</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryParser</span>(<span class="string">&quot;title&quot;</span>, <span class="keyword">new</span> <span class="title class_">IKAnalyzer</span>()).parse(input);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">hitsPerPage</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">IndexReader</span> <span class="variable">reader</span> <span class="operator">=</span> DirectoryReader.open(directory);</span><br><span class="line"><span class="type">IndexSearcher</span> <span class="variable">searcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexSearcher</span>(reader);</span><br><span class="line"><span class="type">TopDocs</span> <span class="variable">docs</span> <span class="operator">=</span> searcher.search(q, hitsPerPage);</span><br><span class="line">ScoreDoc[] hits = docs.scoreDocs;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Found &quot;</span> + hits.length + <span class="string">&quot; hits.&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hits.length; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">docId</span> <span class="operator">=</span> hits[i].doc;</span><br><span class="line">    <span class="type">Document</span> <span class="variable">d</span> <span class="operator">=</span> searcher.doc(docId);</span><br><span class="line">    System.out.println((i + <span class="number">1</span>) + <span class="string">&quot;. &quot;</span> + d.get(<span class="string">&quot;isbn&quot;</span>) + <span class="string">&quot;\t&quot;</span> + d.get(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>和IndexWriter使用同一个Dir</li><li>创建查询语句，我们这里是根据<code>title</code>字段查询，因为这是一个TextField所以用于查询的字符串也需要先使用IKAnalyzer进行分词</li><li>根据查询语句查询出<code>hits</code></li><li>根据<code>hits</code>中的<code>docId</code>取回数据</li></ul><p>基础查询的完整代码位于<a target="_blank" rel="noopener" href="https://github.com/RitterHou/test_lucene/blob/master/src/main/java/com/nosuchfield/lucene/SimpleTest.java">SimpleTest.java</a></p><h2 id="NRT查询"><a href="#NRT查询" class="headerlink" title="NRT查询"></a>NRT查询</h2><p>我们知道Lucene存储引擎使用的是LSM Tree形式，关于LSM Tree可以参考我之前的文章<a href="/2019/06/17/Log-structured-merge-tree/">Log structured merge tree</a>，简而言之Lucene会把数据写到一个个的段（Segment）中。所谓NRT查询即Near Real Time查询，这意味着我们写到Lucene的数据是不能够被立即查询到的，原因如下</p><blockquote><p>Segment在被flush或commit之前，数据保存在内存中，是不可被搜索的，这也就是为什么Lucene被称为提供近实时而非实时查询的原因。读了它的代码后，发现它并不是不能实现数据写入即可查，只是实现起来比较复杂。原因是Lucene中数据搜索依赖构建的索引（例如倒排依赖Term Dictionary），Lucene中对数据索引的构建会在Segment flush时，而非实时构建，目的是为了构建最高效索引。当然它可引入另外一套索引机制，在数据实时写入时即构建，但这套索引实现会与当前Segment内索引不同，需要引入额外的写入时索引以及另外一套查询机制，有一定复杂度。 —— <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35469104" style="color:#777">Lucene解析 - 基本概念</a></p></blockquote><p>上面解释了Lucene不能实现实时查询的原因，下面我们看一看如何能实现NRT查询</p><p>首先还是创建配置等这一套代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Analyzer</span> <span class="variable">analyzer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IKAnalyzer</span>();</span><br><span class="line"><span class="type">RAMDirectory</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RAMDirectory</span>();</span><br><span class="line"><span class="type">IndexWriterConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriterConfig</span>(analyzer);</span><br><span class="line"><span class="keyword">final</span> <span class="type">IndexWriter</span> <span class="variable">indexWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexWriter</span>(index, config);</span><br></pre></td></tr></table></figure><p>随后是NRT的配置以及开启NRT的定时刷新线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NRT查询的相关配置</span></span><br><span class="line"><span class="type">TrackingIndexWriter</span> <span class="variable">trackingIndexWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrackingIndexWriter</span>(indexWriter);</span><br><span class="line"><span class="keyword">final</span> ReferenceManager&lt;IndexSearcher&gt; searcherManager = <span class="keyword">new</span> <span class="title class_">SearcherManager</span>(indexWriter, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NRT查询的定时刷新线程</span></span><br><span class="line">ControlledRealTimeReopenThread&lt;IndexSearcher&gt; nrtReopenThread = <span class="keyword">new</span> <span class="title class_">ControlledRealTimeReopenThread</span>&lt;&gt;(trackingIndexWriter, searcherManager, <span class="number">1.0</span>, <span class="number">0.1</span>);</span><br><span class="line">nrtReopenThread.setName(<span class="string">&quot;NRT Reopen Thread&quot;</span>);</span><br><span class="line">nrtReopenThread.setPriority(Math.min(Thread.currentThread().getPriority() + <span class="number">2</span>, Thread.MAX_PRIORITY));</span><br><span class="line">nrtReopenThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">nrtReopenThread.start();</span><br></pre></td></tr></table></figure><p>其中最重要的就是<code>ControlledRealTimeReopenThread</code>类的<code>1.0</code>和<code>0.1</code>这两个参数</p><ul><li>targetMaxStaleSec: reader的最大open间隔</li><li>targetMinStaleSec: reader的最小可open间隔</li></ul><p>有了以上这些设置，我们就能实现不重新打开reader也可以读到最新的数据了，当然读取的数据对应写入的数据并不是实时的。</p><p>完整代码位于<a target="_blank" rel="noopener" href="https://github.com/RitterHou/test_lucene/blob/master/src/main/java/com/nosuchfield/lucene/NRTTest.java">NRTTest.java</a></p><h2 id="相关度打分"><a href="#相关度打分" class="headerlink" title="相关度打分"></a>相关度打分</h2><p>一般的数据库的查询中，某一条数据针对指定查询条件只存在<strong>符合要求</strong>或者<strong>不</strong>符合要求这两种情况；而搜索引擎则还需要提供某条数据与查询条件有<strong>多大程度相似</strong>的这种情况，这种比较相似度的需求就是通过相似度打分的计算来实现的。在搜索引擎进行查询的同时也会计算指定文档与查询条件的相似度得分，得分高的一般来说就需要优先展示。</p><p>Lucene内部包含了多种相似度算法，其中最经典的就是TF&#x2F;IDF算法，Lucene的TF&#x2F;IDF计算实现位于 <code>org.apache.lucene.search.similarities.TFIDFSimilarity</code> 类中。除了TF和IDF，Lucene在该类中计算得分时还会使用到一些其它的参数</p><table><thead><tr><th align="left">计算因子</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">coord</td><td align="left">指定文档中命中的查询关键词个数 ÷ 所有的查询关键词个数</td></tr><tr><td align="left">TF</td><td align="left">term在指定文档中出现的次数，次数越多得分越高</td></tr><tr><td align="left">IDF</td><td align="left">term在全部文档中出现的次数，次数越多得分越低</td></tr><tr><td align="left">boost</td><td align="left">一个影响因子，供用户在查询时修改以影响最终得分</td></tr><tr><td align="left">queryNorm</td><td align="left">常数</td></tr><tr><td align="left">norms</td><td align="left">文档的长度，长度越短权重越高</td></tr></tbody></table><p>coord实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implemented as &lt;code&gt;overlap / maxOverlap&lt;/code&gt;. */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">coord</span><span class="params">(<span class="type">int</span> overlap, <span class="type">int</span> maxOverlap)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> overlap / (<span class="type">float</span>)maxOverlap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TF的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implemented as &lt;code&gt;sqrt(freq)&lt;/code&gt;. */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">tf</span><span class="params">(<span class="type">float</span> freq)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">float</span>)Math.sqrt(freq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDF的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implemented as &lt;code&gt;log(numDocs/(docFreq+1)) + 1&lt;/code&gt;. */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">idf</span><span class="params">(<span class="type">long</span> docFreq, <span class="type">long</span> numDocs)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">float</span>)(Math.log(numDocs/(<span class="type">double</span>)(docFreq+<span class="number">1</span>)) + <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算最终得分的公式如下（公式来自<a target="_blank" rel="noopener" href="https://lucene.apache.org/core/5_5_5/core/org/apache/lucene/search/similarities/TFIDFSimilarity.html">Lucene官方文档</a>）</p><p><img src="/images/20191028/function.png"></p><h2 id="提升搜索速度"><a href="#提升搜索速度" class="headerlink" title="提升搜索速度"></a>提升搜索速度</h2><p>我们知道Lucene使用反向索引存储数据，例如针对如下数据</p><table><thead><tr><th align="center">id</th><th align="left">标题</th><th align="left">isbn</th></tr></thead><tbody><tr><td align="center">1</td><td align="left">游戏编程算法与技巧</td><td align="left">9787121276453</td></tr><tr><td align="center">2</td><td align="left">计算机程序的构造和解释(原书第2版) : 原书第2版</td><td align="left">9787111135104</td></tr><tr><td align="center">3</td><td align="left">编码 : 隐匿在计算机软硬件背后的语言</td><td align="left">9787121106101</td></tr><tr><td align="center">4</td><td align="left">计算机网络（第5版）</td><td align="left">9787302274629</td></tr><tr><td align="center">5</td><td align="left">Python网络编程攻略</td><td align="left">9787115372697</td></tr><tr><td align="center">6</td><td align="left">UNIX网络编程</td><td align="left">9787302119746</td></tr><tr><td align="center">7</td><td align="left">算法导论（原书第3版）</td><td align="left">9787111407010</td></tr></tbody></table><p>针对上面的数据我们可以构建的部分反向索引结构如下</p><p>标题的反向索引：</p><table><thead><tr><th align="left">关键词</th><th align="left">doc_ids</th></tr></thead><tbody><tr><td align="left">算法</td><td align="left">[1, 7]</td></tr><tr><td align="left">编程</td><td align="left">[1, 5, 6]</td></tr><tr><td align="left">计算机</td><td align="left">[2, 3, 4]</td></tr></tbody></table><p>isbn的反向索引：</p><table><thead><tr><th align="left">关键词</th><th align="left">doc_ids</th></tr></thead><tbody><tr><td align="left">9787121106101</td><td align="left">3</td></tr><tr><td align="left">9787115372697</td><td align="left">5</td></tr></tbody></table><p>根据上表我们知道Lucene需要构造一个 <code>关键词 -&gt; doc_id</code> 之前的关系映射，如果让我自己实现一个映射关系那我很可能会选择使用哈希表，即<strong>关键词</strong>使用哈希表的方式进行查找。Lucene选择了使用一个类似于trie树叫做FST(Finite State Transducer)的数据结构来保存关键词，虽然FST在写入和查找速度上都不及哈希表，但是它在前缀查找等方式上却有着巨大的优势，此外FST十分的节省空间，这使得我们可以把FST全部放在内存中以提高数据操作速度。关于FST可以参考<a target="_blank" rel="noopener" href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/">这篇文章</a>。</p><p>Lucene的数据存储架构如下</p><p><img src="/images/20191028/ast.png"></p><p>上面我们介绍的FST其实是Term dict index这一部分，通过Term dict index我们可以找到Term dict中的相应term，例如上面我们提到的 计算机 或者 9787121106101 等等。找到了相应的term之后我们可以继续根据term找到相应的Inverted Index，Inverted Index使用SkipList保存，SkipList可以让多个term的查询结果合并速度更快。顺便提一下，Elasticsearch会对filter类型的查询结果使用bitset进行缓存，如果下次查询缓存命中则可以直接通过bitset的缓存进行结果合并，速度更快。</p><h3 id="生成正向索引"><a href="#生成正向索引" class="headerlink" title="生成正向索引"></a>生成正向索引</h3><p>我们上面提到的都是<strong>数据检索阶段</strong>的工作，也看到了Inverted Index在数据检索上十分优秀，但是当我们已经取回了数据需要对数据做<strong>进一步的排序或聚合</strong>时，反向索引就显得力不从心了。Lucene需要把取回的数据通过计算再生成一份正向索引，之后使用正向索引实现排序或聚合等操作，生成正向索引十分耗费资源，因此Lucene4之后对这些生成的正向索引做了缓存即fieldcache，这样这些正向索引的结果就会被缓存在内存中，fieldcache的命中可以大大提高数据排序或聚合的速度。</p><p>fieldcache对内存是一个很大的挑战，如果缓存数据过多会导致内存占用过高。新版的Lucene中引入了DocValues概念，Lucene会在数据索引阶段就生成一份列式存储的正向索引，即DocValues。DocValues因为是在索引阶段生成的，又被保存在磁盘上，所以避免了fieldcache会产生的一些问题。当然，DocValues会增加磁盘空间的使用，所以Lucene允许我们只针对某些需要排序或聚合的字段使用DocValues，这样就节省了部分的磁盘空间。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://www.lucenetutorial.com/index.html">Welcome to Lucene Tutorial.com - Lucene Tutorial.com</a><br><a target="_blank" rel="noopener" href="http://codepub.cn/2017/12/12/lucene-near-real-time-search/">Lucene 近实时搜索 | IT草根</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35469104">Lucene解析 - 基本概念</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/forfuture1978/category/300665.html">Lucene原理与代码分析 - 随笔分类</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yjf512/p/4860134.html">lucene 的评分机制</a><br><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/ejEG02VRoeGVaLw4j_LL">Lucene 查询原理及解析</a></p><p><a target="_blank" rel="noopener" href="https://lanffy.github.io/2019/05/08/Elasticsearch-Search-Score-Algorithm">Lucene中的文本相似度算法</a><br><a target="_blank" rel="noopener" href="https://fjdu.github.io/coding/2017/03/16/bm25-elasticsearch-lucene.html">Okapi BM25, TF-IDF, 以及 ElasticSearch&#x2F;Lucene 搜索结果的分数</a><br><a target="_blank" rel="noopener" href="https://github.com/RitterHou/elasticsearch-full/tree/master/%E6%94%B6%E8%97%8F%E5%A5%BD%E6%96%87">elasticsearch-full</a><br><a target="_blank" rel="noopener" href="https://www.amazingkoala.com.cn/Lucene/Search/2019/0820/86.html">Lucene查询原理</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/5d624368e51d45621479ad05">ElasticSearch 查询的秘密</a><br><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules.html">Elasticsearch Modules</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="Lucene学习笔记">https://www.nosuchfield.com/2019/10/28/Lucene-study-notes/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/" rel="tag">搜索引擎</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>