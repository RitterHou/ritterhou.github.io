<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>Let’s Build A Simple Interpreter - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="编译原理"><meta name="description" content="&lt;p&gt;&lt;a href=&#34;https://ruslanspivak.com/lsbasi-part1/&#34;&gt;Let’s Build A Simple Interpreter.&lt;/a&gt;是一个用Python实现了语言解释器的系列文章。我对这个系列的每一篇文章都做了一个简要的介绍，如果你打算看这系列的文章，可以把我的这些简介作为这系列文章的提纲或者目录，帮助你快速的抓住每篇文章的核心内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://ruslanspivak.com/lsbasi-part1/&#34;&gt;https://ruslanspivak.com/lsbasi-part1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 讲了编译器的基本概念，以及一个实现了计算3+5的最简单的解释器。通过这个解释器，简单的介绍了一下词法分析以及通过 &lt;code&gt;eat&lt;/code&gt; 函数来实现了语法分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://ruslanspivak.com/lsbasi-part2/&#34;&gt;https://ruslanspivak.com/lsbasi-part2/&lt;/"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">Let’s Build A Simple Interpreter</h1></div><div class="post-meta"><span class="post-time">2017-08-26</span></div><div class="post-content"><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part1/">Let’s Build A Simple Interpreter.</a>是一个用Python实现了语言解释器的系列文章。我对这个系列的每一篇文章都做了一个简要的介绍，如果你打算看这系列的文章，可以把我的这些简介作为这系列文章的提纲或者目录，帮助你快速的抓住每篇文章的核心内容。</p><ol><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part1/">https://ruslanspivak.com/lsbasi-part1/</a></p><p>讲了编译器的基本概念，以及一个实现了计算3+5的最简单的解释器。通过这个解释器，简单的介绍了一下词法分析以及通过 <code>eat</code> 函数来实现了语法分析。</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part2/">https://ruslanspivak.com/lsbasi-part2/</a></p><p>语法分析增加了对空格的处理，词法分析增加了对多个数字组成的数字的识别。增加了减法操作。</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part3/">https://ruslanspivak.com/lsbasi-part3/</a></p><p>介绍了使用 Syntax diagrams 来描述语法信息；事实上个人更喜欢BNF范式的描述方式，而不是很喜欢这种用图像来描述语法的方式。细化了语法分析的代码，根据给定的 Syntax diagrams 图的语法来构建代码，把数字的识别部分单独提升为一个函数。</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part4/">https://ruslanspivak.com/lsbasi-part4/</a></p><p>介绍 EBNF 范式，并且用此范式来描述文法；介绍了终结符、非终结符、起始符号的概念。介绍了4种把EBNF范式转化为方法的套路：</p><ul><li>对于每一个产生式，都应该定义一个方法来与之对应；</li><li>选择符号 <code>|</code> 对应代码 <code>if...elif...else...</code></li><li>对于 <code>(...)*</code> 这种重复符号，使用代码 <code>while</code></li><li>对于每一个非终结符（Token），都使用 <code>eat()</code> 方法来进行语法分析，判断当前token和语法定义中的是否一致，不一致则应该报错</li></ul></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part5/">https://ruslanspivak.com/lsbasi-part5/</a></p><p>介绍了算术表达式的“左关联”的特性，和引入了操作的“优先级”的概念。高优先级总是比低优先级先执行，同样的优先级则执行“左关联”（即从左向右执行）。为了符合高优先级先执行的特性，则需要把高优先级作为一个完整的non-terminal，使其在AST的靠近下方的位置。例如：</p><pre><code> expr: term((+|-)term)*
 term: factor((*|/)factor)*
 factor: num
</code></pre><p>这样书写产生式的目的在于要让高优先级的产生式先执行</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part6/">https://ruslanspivak.com/lsbasi-part6/</a></p><p>引入了括号的优先级概念，并且这种语法将产生递归操作。例如：</p><pre><code> expr: term((+|-)term)*
 term: factor((*|/)factor)*
 factor: num|LPAREN expr RPAREN
</code></pre><p>因为相加、相乘（即运算符）操作的可能对应的是数字，也有可能是一个括号整体。</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part7/">https://ruslanspivak.com/lsbasi-part7/</a></p><p>引入了中间表示（IR）、分析树和抽象语法树（AST）的概念。</p><p>分析树用来记录输入程序的解析操作，</p><ul><li>分析树的根节点是 start symbol</li><li>分析树的内部节点都是非终结符，代表了一个产生式规则</li><li>分析树的叶子节点都是终结符，其实是一个个的token</li></ul><p>分析树和AST的主要区别：</p><ul><li>AST使用操作符作为根节点和内部节点，使用操作数作为它们的子节点</li><li>和分析树不同，AST不使用内部节点来代表语法</li><li>AST不会描述真实语法中的所有的细节；例如，没有规则节点，没有括号</li><li>对于同样的语法结构，AST和分析树是很相似的</li></ul><p>AST的定义：对一个语法结构的抽象；其中根节点和内部节点代表___操作符___，它们的子节点代表___操作数___。<br>对于高优先级操作，只需要把它放到AST靠下的位置即可。</p><p>后面还介绍了如何构建一棵抽象语法树，以及在解释器中使用后序遍历和观察者模式来对树进行解析。（解析的时候用了Python的一个小trick：getattr函数）</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part8/">https://ruslanspivak.com/lsbasi-part8/</a></p><p>给表达式添加了一元操作符（+、-），一元操作符作为操作数的父节点来构造AST。</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part9/">https://ruslanspivak.com/lsbasi-part9/</a></p><p>介绍了Pascal的语法；更新了lexer、parser、和interpreter来适应Pascal的语法。利用递归下降分析算法进行了语法分析。</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part10/">https://ruslanspivak.com/lsbasi-part10/</a></p><p>进一步完善了对Pascal语法的支持，增加了包申明、变量类型管理、整除操作，等等。</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part11/">https://ruslanspivak.com/lsbasi-part11/</a></p><p>对前面的所有内容做了一个回复和总结。介绍了使用符号表，使得在进行AST解析的时候能够得到正确的解析，符号表就是用来保存一些编译AST的时候的信息的。</p><blockquote><p>在这个过程中, 根据语言的语义规则来识别语义错误, 要识别语义错误 就必须编译 AST, 因为是树的遍历, 假如你先遍历到了 int a 这个节点, 接着又遍历到了一个表达式 a &#x3D; 4 这个节点, 你需要检查变量 a 有没有声明啊, 变量 a 和 4 的类型批不匹配呢? 这时你如果没有保存变量 a 的信息, 那么你怎么检查? 所以就需要符号表来保存这些信息了。</p></blockquote></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part12/">https://ruslanspivak.com/lsbasi-part12/</a></p><p>介绍了Pascal的过程描述语法，把此语法添加进来，进一步完善了编译器和解释器。</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part13/">https://ruslanspivak.com/lsbasi-part13/</a></p><p>引入了语义分析的概念，更加深入的对语义分析进行了讨论。</p></li><li><p><a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part14/">https://ruslanspivak.com/lsbasi-part14/</a></p><p>引入了变量作用域，等等的概念，进一步完善了编译器。</p></li></ol></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="Let’s Build A Simple Interpreter">https://www.nosuchfield.com/2017/08/26/Let%E2%80%99s-Build-A-Simple-Interpreter/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>