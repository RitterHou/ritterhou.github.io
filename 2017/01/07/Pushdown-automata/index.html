<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>计算机的计算（二） - 下推自动机 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="计算,计算机"><meta name="description" content="&lt;p&gt;本文是&lt;a href=&#34;/2017/01/05/Computation-of-computers/&#34;&gt;计算机的计算&lt;/a&gt;系列的第二篇。&lt;/p&gt;
&lt;h3 id=&#34;1-下推自动机&#34;&gt;&lt;a href=&#34;#1-下推自动机&#34; class=&#34;headerlink&#34; title=&#34;1. 下推自动机&#34;&gt;&lt;/a&gt;1. 下推自动机&lt;/h3&gt;&lt;p&gt;自带栈的有限状态机叫作下推自动机（PushDown Automaton，PDA）。&lt;/p&gt;
&lt;p&gt;上面给出了下推自动机的概念，那么为什么我们要在有限自动机的基础上给其增加一个栈来构建下推自动机呢？其根本原因在于有限状态机本身无法存储数据，而加上了栈之后的下推自动机则具有了数据存储能力。具有了存储能力之后，下推自动机的计算能力相较于有限自动机得到了进一步的增强。&lt;/p&gt;
&lt;p&gt;我们已经知道，有限自动机在进行状态转移的时候，需要读取一个输入，然后根据当前状态已经输入来进行状态转移。下推自动机在进行状态转移的时候同样要依赖于当前状态和输入，不过，因为下推自动机有了栈的概念，所以在进行状态转移的时候我们还需要一点别的东西——读栈和写栈操作。例如下图这样的一个下推自"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">计算机的计算（二） - 下推自动机</h1></div><div class="post-meta"><span class="post-time">2017-01-07</span></div><div class="post-content"><p>本文是<a href="/2017/01/05/Computation-of-computers/">计算机的计算</a>系列的第二篇。</p><h3 id="1-下推自动机"><a href="#1-下推自动机" class="headerlink" title="1. 下推自动机"></a>1. 下推自动机</h3><p>自带栈的有限状态机叫作下推自动机（PushDown Automaton，PDA）。</p><p>上面给出了下推自动机的概念，那么为什么我们要在有限自动机的基础上给其增加一个栈来构建下推自动机呢？其根本原因在于有限状态机本身无法存储数据，而加上了栈之后的下推自动机则具有了数据存储能力。具有了存储能力之后，下推自动机的计算能力相较于有限自动机得到了进一步的增强。</p><p>我们已经知道，有限自动机在进行状态转移的时候，需要读取一个输入，然后根据当前状态已经输入来进行状态转移。下推自动机在进行状态转移的时候同样要依赖于当前状态和输入，不过，因为下推自动机有了栈的概念，所以在进行状态转移的时候我们还需要一点别的东西——读栈和写栈操作。例如下图这样的一个下推自动机：</p><p><img src="/images/20170107/20170107235144.png" alt="下推自动机"></p><p>我们可以把这个下推自动机用这样的转移列表列出来，注意这里的 <code>$</code> 符号，因为栈为空的状态并不是很好判断，所以我们添加了这个字符来代表栈为空，也就是说栈的最底部永远应该保持有 <code>$</code> 这个字符。最下面的虚线代表着当栈为空且状态为2时（我们使用虚线来代表<strong>不需要有输入</strong>的转移情形，即<strong>自由移动</strong>），此时不需要任何输入，栈会自动的弹出 <code>$</code> 然后再压入 <code>$</code>，随后状态从2变为1。</p><table><thead><tr><th align="center">当前状态</th><th align="center">输入字符</th><th align="center">转移状态</th><th align="center">栈顶字符（读入&#x2F;弹出）</th><th align="center">压入字符</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">(</td><td align="center">2</td><td align="center">$</td><td align="center">b$</td></tr><tr><td align="center">2</td><td align="center">(</td><td align="center">2</td><td align="center">b</td><td align="center">bb</td></tr><tr><td align="center">2</td><td align="center">)</td><td align="center">2</td><td align="center">b</td><td align="center">不压入</td></tr><tr><td align="center">2</td><td align="center">无输入</td><td align="center">1</td><td align="center">$</td><td align="center">$</td></tr></tbody></table><p>相对于有限自动机，下推自动机只是增加了一个入栈和出栈的操作，可以说并不复杂，但是需要提醒的一点是：对于下推自动机，栈顶的元素也是转移的规则之一。怎么理解这句话呢？下面我通过一个小例子来说明。</p><p>有如下两个转移规则</p><table><thead><tr><th align="center">当前状态</th><th align="center">输入字符</th><th align="center">转移状态</th><th align="center">栈顶字符（读入&#x2F;弹出）</th><th align="center">压入字符</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td><td align="center">2</td><td align="center">x</td><td align="center">$</td></tr><tr><td align="center">1</td><td align="center">a</td><td align="center">3</td><td align="center">y</td><td align="center">$</td></tr></tbody></table><p>当在状态1读到输入a的时候，此时并不能决定到底要转移到那一个状态，而是要根据此时的栈顶元素（x或是y）来判断要进行哪一种的转移操作，所以说<strong>栈顶元素也是转移的规则之一</strong>。《计算的本质》中是这样描述这个特性的：</p><blockquote><p>在某种程度上，下推自动机还能控制自己。在规则和栈之间有一个反馈环——栈的内容影响机器应该遵守的规则，而按照某个规则执行也会影响栈的内容——这允许PDA在栈中存储一些信息，这些信息可以影响它将来的执行。</p></blockquote><p>因为下推自动机是有限自动机的扩充，所以下推自动机也分为确定性下推自动机和非确定性下推自动机，下面将会详细介绍。</p><h3 id="2-确定性下推自动机"><a href="#2-确定性下推自动机" class="headerlink" title="2. 确定性下推自动机"></a>2. 确定性下推自动机</h3><p>什么是确定性？即 <strong>无冲突</strong>、<strong>无遗漏</strong>。</p><ul><li>对于无冲突，我们只要保证下推自动机在进行状态转移的时候不会产生模棱两可的规则即可；</li><li>而无遗漏这个要求操作起来就比较的棘手，因为下推自动机一般很难把所有的转移规则都覆盖到，所以一般的做法是忽略这个约束并允许DPDA（确定性下推自动机，Deterministic PushDown Automaton）只定义完成工作所需的规则，并且假定一台DPDA在没有规则可用时将进入停滞状态。</li></ul><p>了解DPDA的定义后，就开始使用Python来模拟一个下推自动机吧，代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">确定性下推自动机，Deterministic PushDown Automaton</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始时栈底的元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, init</span>):</span><br><span class="line">        self.__storage = init</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__storage[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="comment"># 压入的内容做遍历，靠近后面的内容应该先被压入</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(p):</span><br><span class="line">            self.__storage.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__storage.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 名词[配置]表示一个状态和一个栈的组合，其实上相当于以前的[一个状态]</span></span><br><span class="line"><span class="comment"># 为什么要定义[配置]呢？目的在于把状态和栈这两种元素组合起来形成一个整体，方便使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDAConfiguration</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, stack</span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.stack = stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># DDPA的转移规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDARule</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 参数：当前状态，输入，下一个状态，（栈）弹出字符，压入字符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, character, next_state, pop_character, push_characters</span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.character = character</span><br><span class="line">        self.next_state = next_state</span><br><span class="line">        self.pop_character = pop_character</span><br><span class="line">        self.push_characters = push_characters</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下一个配置：1. 下一个状态就是 next_state 参数，2. 下一个配置的栈由方法 next_stack 根据当前的栈信息算出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">follow</span>(<span class="params">self, configuration</span>):</span><br><span class="line">        <span class="keyword">return</span> PDAConfiguration(self.next_state, self.__next_stack(configuration.stack))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断指定配置执行指定输入时是否可用当前的转移规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">applies_to</span>(<span class="params">self, configuration, character</span>):</span><br><span class="line">        <span class="keyword">return</span> self.state == configuration.state \</span><br><span class="line">               <span class="keyword">and</span> self.pop_character == configuration.stack.top() <span class="keyword">and</span> self.character == character</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下一个栈的计算，先弹出再压入即可</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next_stack</span>(<span class="params">self, stack</span>):</span><br><span class="line">        stack.pop()  <span class="comment"># 弹出</span></span><br><span class="line">        stack.push(self.push_characters)  <span class="comment"># 压入</span></span><br><span class="line">        <span class="keyword">return</span> stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转移规则集合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DPDARulebook</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rule_set</span>):</span><br><span class="line">        self.ruleSet = rule_set</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于获取下一个配置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_configuration</span>(<span class="params">self, configuration, character</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__rule_for(configuration, character).follow(configuration)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据当前的配置和输入来查找对应的转移规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__rule_for</span>(<span class="params">self, configuration, character</span>):</span><br><span class="line">        <span class="keyword">for</span> rule <span class="keyword">in</span> self.ruleSet:</span><br><span class="line">            <span class="keyword">if</span> rule.applies_to(configuration, character):</span><br><span class="line">                <span class="keyword">return</span> rule</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;找不到可供使用的规则 ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rulebook = DPDARulebook([</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="string">&#x27;(&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;$&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;$&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">2</span>, <span class="string">&#x27;(&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">2</span>, <span class="string">&#x27;)&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, []),</span><br><span class="line">    PDARule(<span class="number">2</span>, <span class="literal">None</span>, <span class="number">1</span>, <span class="string">&#x27;$&#x27;</span>, [<span class="string">&#x27;$&#x27;</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DPDA</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 参数：初始配置，接受状态，规则集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, current_configuration, accept_states, rule_book</span>):</span><br><span class="line">        self.current_configuration = current_configuration</span><br><span class="line">        self.accept_states = accept_states</span><br><span class="line">        self.rule_book = rule_book</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断当前的状态是否是接受状态</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accepting</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.current_configuration.state <span class="keyword">in</span> self.accept_states</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_character</span>(<span class="params">self, character</span>):</span><br><span class="line">        self.current_configuration = self.rule_book.next_configuration(self.current_configuration, character)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 同样为了简化操作，方便连续输入</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_string</span>(<span class="params">self, string</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">            self.current_configuration = self.rule_book.next_configuration(self.current_configuration, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dpda = DPDA(PDAConfiguration(<span class="number">1</span>, Stack([<span class="string">&#x27;$&#x27;</span>])), [<span class="number">1</span>], rulebook)</span><br><span class="line">    <span class="built_in">print</span>(dpda.accepting())</span><br><span class="line">    dpda.read_string(<span class="string">&#x27;(()&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(dpda.accepting())</span><br></pre></td></tr></table></figure><p>虽然代码的实现看上去挺复杂的，但是我们只需要牢记两点：</p><ol><li>下推自动机只是有限自动机增加了一个栈而已，所以我们只是增加了栈的压入和弹出操作</li><li>下推自动机的转移规则还需要指定栈顶元素，栈顶元素不一样的不能算为同样的转移规则</li></ol><h3 id="3-非确定性下推自动机"><a href="#3-非确定性下推自动机" class="headerlink" title="3. 非确定性下推自动机"></a>3. 非确定性下推自动机</h3><p>在介绍非确定性下推自动机之前，我们写来了解一下使用非确定性下推自动机有什么好处。观察下面这张图，这是一个用来检测一个输入是否是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%96%87%E6%95%B0">回文</a>的确定性下推自动机。</p><p><img src="/images/20170107/20170108211654.png"></p><ol><li>处于状态1且输入了a或者b的时候，每输入一个输入就会在栈顶把这个输入加上去（和之前不一样，我们在这里把直接把输入入栈了，也就是把输入和栈联系了起来。在之前，输入和栈内元素我们都是区分开来的）；</li><li>在输入了 <code>m</code> 之后，又会把栈内元素根据输入顺序弹出来（也就是当栈顶为a时，我们必须输入a，之后a被弹出，下一个元素继续进行同样的操作）。</li></ol><p>在有了这种机器之后，我们就能识别出类似于 <code>babbamabbab</code> 这样的回文了。但是我们还需要一个额外的 <code>m</code> 来进行分割的操作，这样感觉并不是很优美。我们可以使用非确定性下推自动机来完成同样的操作（出于简单考虑，该自动机只支持偶数个字母的判断）：</p><p><img src="/images/20170107/20170108214024.png" alt="非确定性下推自动机"></p><p>上面这个机器除了状态1到状态2的转移操作和之前的DPDA不一样，其余完全一样。也就是说从状态1到状态2的转移不需要任何的确定性的约束，这种没有确定性约束的下推自动机叫作非确定性下推自动机。下面就是一个非确定性下推自动机的模拟：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">非确定性下推自动机</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始时栈底的元素</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, init</span>):</span><br><span class="line">        self.__storage = init</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__storage[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, p</span>):</span><br><span class="line">        <span class="comment"># 压入的内容做遍历，靠近后面的内容应该先被压入</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(p):</span><br><span class="line">            self.__storage.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__storage.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 相当于 Java 的 toString 方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.__storage)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 名词[配置]表示一个状态和一个栈的组合，其实上相当于以前的[一个状态]</span></span><br><span class="line"><span class="comment"># 为什么要定义[配置]呢？目的在于把状态和栈这两种元素组合起来形成一个整体，方便使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDAConfiguration</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, stack</span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.stack = stack</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.state) + <span class="string">&#x27;:&#x27;</span> + <span class="built_in">str</span>(self.stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># DDPA的转移规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PDARule</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 参数：当前状态，输入，下一个状态，（栈）弹出字符，压入字符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, character, next_state, pop_character, push_characters</span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.character = character</span><br><span class="line">        self.next_state = next_state</span><br><span class="line">        self.pop_character = pop_character</span><br><span class="line">        self.push_characters = push_characters</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下一个配置：1. 下一个状态就是 next_state 参数，2. 下一个配置的栈由方法 next_stack 根据当前的栈信息算出</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">follow</span>(<span class="params">self, configuration</span>):</span><br><span class="line">        <span class="keyword">return</span> PDAConfiguration(self.next_state, self.__next_stack(configuration.stack))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断指定配置执行指定输入时是否可用当前的转移规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">applies_to</span>(<span class="params">self, configuration, character</span>):</span><br><span class="line">        <span class="keyword">return</span> self.state == configuration.state \</span><br><span class="line">               <span class="keyword">and</span> self.pop_character == configuration.stack.top() <span class="keyword">and</span> self.character == character</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下一个栈的计算，先弹出再压入即可</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next_stack</span>(<span class="params">self, stack</span>):</span><br><span class="line">        stack.pop()  <span class="comment"># 弹出</span></span><br><span class="line">        stack.push(self.push_characters)  <span class="comment"># 压入</span></span><br><span class="line">        <span class="comment"># print(stack)</span></span><br><span class="line">        <span class="keyword">return</span> stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">↑↑↑ 上面内容和 DPDA 完全一样 ↑↑↑</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非确定性下推自动机转移规则集合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPDARulebook</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rule_set</span>):</span><br><span class="line">        self.ruleSet = rule_set</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于获取下面的多个配置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_configurations</span>(<span class="params">self, configuration, character</span>):</span><br><span class="line">        configurations = []</span><br><span class="line">        <span class="keyword">for</span> config <span class="keyword">in</span> configuration:</span><br><span class="line">            rules = self.__rules_for(config, character)</span><br><span class="line">            <span class="keyword">for</span> rule <span class="keyword">in</span> rules:</span><br><span class="line">                configurations.append(rule.follow(config))</span><br><span class="line">        <span class="keyword">return</span> configurations</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据当前的[配置]和[输入]来查找对应的转移规则</span></span><br><span class="line">    <span class="comment"># 与 DPDA 不同，这里可能会对应多个不同的转移规则，我们用集合来存放这些转移规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__rules_for</span>(<span class="params">self, configuration, character</span>):</span><br><span class="line">        rules = []</span><br><span class="line">        <span class="keyword">for</span> rule <span class="keyword">in</span> self.ruleSet:</span><br><span class="line">            <span class="keyword">if</span> rule.applies_to(configuration, character):</span><br><span class="line">                rules.append(rule)</span><br><span class="line">        <span class="keyword">return</span> rules</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rulebook = NPDARulebook([</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;$&#x27;</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;$&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;$&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;$&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="literal">None</span>, <span class="number">2</span>, <span class="string">&#x27;$&#x27;</span>, [<span class="string">&#x27;$&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="literal">None</span>, <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>, [<span class="string">&#x27;a&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">1</span>, <span class="literal">None</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;b&#x27;</span>]),</span><br><span class="line">    PDARule(<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>, []),</span><br><span class="line">    PDARule(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, []),</span><br><span class="line">    PDARule(<span class="number">2</span>, <span class="literal">None</span>, <span class="number">3</span>, <span class="string">&#x27;$&#x27;</span>, [<span class="string">&#x27;$&#x27;</span>])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NPDA</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 参数：初始配置，接受状态，规则集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, current_configuration, accept_states, rule_book</span>):</span><br><span class="line">        self.current_configuration = [current_configuration]</span><br><span class="line">        self.accept_states = accept_states</span><br><span class="line">        self.rule_book = rule_book</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断当前的状态是否是接受状态</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accepting</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> current_config <span class="keyword">in</span> self.current_configuration:</span><br><span class="line">            <span class="keyword">if</span> current_config.state <span class="keyword">in</span> self.accept_states:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输入</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_character</span>(<span class="params">self, character</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.current_configuration:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="comment"># 转移到下一个配置</span></span><br><span class="line">        self.current_configuration = self.rule_book.next_configurations(self.current_configuration, character)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 同样为了简化操作，方便连续输入</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_string</span>(<span class="params">self, string</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">            self.read_character(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    dpda = NPDA(PDAConfiguration(<span class="number">1</span>, Stack([<span class="string">&#x27;$&#x27;</span>])), [<span class="number">3</span>], rulebook)</span><br><span class="line">    <span class="built_in">print</span>(dpda.accepting())</span><br><span class="line">    dpda.read_string(<span class="string">&#x27;babba&#x27;</span>)</span><br><span class="line">    dpda.read_character(<span class="literal">None</span>)</span><br><span class="line">    dpda.read_string(<span class="string">&#x27;abbab&#x27;</span>)</span><br><span class="line">    dpda.read_character(<span class="literal">None</span>)</span><br><span class="line">    <span class="built_in">print</span>(dpda.accepting())</span><br></pre></td></tr></table></figure><p>我们同样使用集合来保存非确定性下推自动机的配置的可能情况，具体的思想可以参考DFA到NFA的转化方式。</p><h3 id="4-不等价"><a href="#4-不等价" class="headerlink" title="4. 不等价"></a>4. 不等价</h3><p>我们已经了解了任意的一个NFA都可以转化为一个与其等价的DFA，那么任意一个NPDA都可以转化为一个与其等价的DPDA吗？非常遗憾，答案是否定的。</p><p>所以不幸的是，我们的 NPDA 模拟的行为并不像一台 DPDA，也不存在 NDPA 到 DPDA<br>的算法。无标记的回文问题就是这样一个例子，NPDA 能完成这个问题，但 DPDA 不能，<br>因此非确定性下推自动机确实比确定性的能力要强。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="计算机的计算（二） - 下推自动机">https://www.nosuchfield.com/2017/01/07/Pushdown-automata/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97/" rel="tag">计算</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>