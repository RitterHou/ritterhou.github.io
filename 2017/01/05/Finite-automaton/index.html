<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>计算机的计算（一） - 有限自动机 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="计算,计算机"><meta name="description" content="&lt;p&gt;本文是&lt;a href=&#34;/2017/01/05/Computation-of-computers/&#34;&gt;计算机的计算&lt;/a&gt;系列的第一篇。&lt;/p&gt;
&lt;h3 id=&#34;1-有限自动机&#34;&gt;&lt;a href=&#34;#1-有限自动机&#34; class=&#34;headerlink&#34; title=&#34;1. 有限自动机&#34;&gt;&lt;/a&gt;1. 有限自动机&lt;/h3&gt;&lt;p&gt;有限自动机（finite automaton），也叫有限状态机（finite state machine），是一台极简的计算机模型。下面是一个非常简单的有限自动机：&lt;br&gt;&lt;img src=&#34;/images/20170105/20170105225404.png&#34; alt=&#34;简单的有限自动机&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a被称之为&lt;strong&gt;输入&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;圆圈1和2我们称之为&lt;strong&gt;状态&lt;/strong&gt;，其中1为起始状态，2为接受状态；&lt;/li&gt;
&lt;li&gt;在状态1的时候输入了a，此时会转移到状态2，这种转移我们可以称之为&lt;strong&gt;转移规则&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如果一系列的输入能够使得一台"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">计算机的计算（一） - 有限自动机</h1></div><div class="post-meta"><span class="post-time">2017-01-05</span></div><div class="post-content"><p>本文是<a href="/2017/01/05/Computation-of-computers/">计算机的计算</a>系列的第一篇。</p><h3 id="1-有限自动机"><a href="#1-有限自动机" class="headerlink" title="1. 有限自动机"></a>1. 有限自动机</h3><p>有限自动机（finite automaton），也叫有限状态机（finite state machine），是一台极简的计算机模型。下面是一个非常简单的有限自动机：<br><img src="/images/20170105/20170105225404.png" alt="简单的有限自动机"></p><ul><li>a被称之为<strong>输入</strong>；</li><li>圆圈1和2我们称之为<strong>状态</strong>，其中1为起始状态，2为接受状态；</li><li>在状态1的时候输入了a，此时会转移到状态2，这种转移我们可以称之为<strong>转移规则</strong>；</li><li>如果一系列的输入能够使得一台有限自动机最终处于接受状态，那么这个输入是可以被这台有限自动机接受的，这个输入的内容可以称之为这台有限自动机的正则语言；否则，这种输入就是被该有限自动机<strong>拒绝</strong>的；</li></ul><p>下面是一台稍微复杂点的有限自动机，对照上面的概念，自己看看能不能理解这些概念：<br><img src="/images/20170105/20170105230850.png"></p><p>如上所示：</p><ol><li>这台有限自动机一共有1、2、3三种状态，其中1是输入状态，3是接受状态；</li><li>一共有两种输入，即a和b；</li><li>转移规则如下表所示：</li></ol><table><thead><tr><th align="center">当前状态</th><th align="center">输入</th><th align="center">目标状态</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td><td align="center">2</td></tr><tr><td align="center">1</td><td align="center">b</td><td align="center">1</td></tr><tr><td align="center">2</td><td align="center">a</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">3</td></tr><tr><td align="center">3</td><td align="center">a</td><td align="center">3</td></tr><tr><td align="center">3</td><td align="center">b</td><td align="center">3</td></tr></tbody></table><p>怎么样，很简单吧。OK，我们已经理解了有限自动机的概念了，接下来我们聊聊有限自动机下的两个不同类型：确定性有限自动机和非确定性有限自动机。</p><h3 id="2-确定性有限自动机"><a href="#2-确定性有限自动机" class="headerlink" title="2. 确定性有限自动机"></a>2. 确定性有限自动机</h3><p>具有以下这两个性质的有限自动机可以称为确定性有限自动机：</p><ul><li>没有冲突：一个状态对于同样的输入，不能有多个规则，即每个输入只能有一个转移规则；</li><li>没有遗漏：每个状态都必须针对每个可能的输入字符有至少一个规则；</li></ul><p>说的通俗点就是一个状态对应一个输入只会有一个转移规则；而每个状态都必须包含有所有输入的转移规则，不可以有遗漏；这就是确定性有限自动机。</p><p>理解了什么是确定性有限自动机了，接下来就让我们用代码来实现它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">DFA，确定性有限自动机</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了一个转移规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FARule</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, character, next_state</span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.character = character</span><br><span class="line">        self.nextState = next_state</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过判断当前的状态和输入和此规则是否相等来决定是否应该使用该种规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">applies</span>(<span class="params">self, state, character</span>):</span><br><span class="line">        <span class="keyword">return</span> self.state == state <span class="keyword">and</span> self.character == character</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取下一个规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_state</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.nextState</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果上面的类是一个转移规则，那么这里就是存储了一个有限自动机的转移规则的集合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FARuleBook</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rule_set</span>):</span><br><span class="line">        self.ruleSet = rule_set</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rules</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.ruleSet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个有限自动机的规则集合</span></span><br><span class="line">rulebook = FARuleBook([</span><br><span class="line">    FARule(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">    FARule(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    FARule(<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">    FARule(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个确定性有限自动机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DFA</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化有限自动机时包含了初始状态、接受状态和转移规则的集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, current_state, accept_state, rule_book</span>):</span><br><span class="line">        self.currentState = current_state</span><br><span class="line">        self.acceptState = accept_state</span><br><span class="line">        self.ruleBook = rule_book.rules()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当输入一个字符时，根据当前状态和输入去转移规则中寻找对应的转移规则，</span></span><br><span class="line">    <span class="comment"># 根据规则获取下一个状态，并把下一个状态置为当前状态</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">input_character</span>(<span class="params">self, character</span>):</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> self.ruleBook:</span><br><span class="line">            <span class="keyword">if</span> r.applies(self.currentState, character):</span><br><span class="line">                self.currentState = r.next_state()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据当前状态来判断是否是输入状态</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_accept</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.currentState == self.acceptState</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了方便操作，同时也提供了一个可以输入字符串的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">input_string</span>(<span class="params">self, string</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">            self.input_character(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个DFA</span></span><br><span class="line">dfa = DFA(<span class="number">1</span>, <span class="number">2</span>, rulebook)</span><br><span class="line"><span class="comment"># 读入字符串</span></span><br><span class="line">dfa.input_string(<span class="string">&#x27;aaaaaaaaaaaaaaaaaaab&#x27;</span>)</span><br><span class="line"><span class="comment"># 判断当前是否处于接受状态</span></span><br><span class="line"><span class="built_in">print</span>(dfa.is_accept())</span><br></pre></td></tr></table></figure><p>上面就是一个用Python模拟的DFA了，很简单吧。</p><h3 id="3-非确定性有限自动机"><a href="#3-非确定性有限自动机" class="headerlink" title="3. 非确定性有限自动机"></a>3. 非确定性有限自动机</h3><p>所谓非确定性有限自动机（NFA），就是没有了DFA那两条限制的机器，即：</p><ul><li>对于某一个状态，读入某一个输入的时候，可能会有多种转移规则；</li><li>对于某一个状态，它可能会缺少对应某种输入的转移规则；</li></ul><p>说的再多不如示意图来的直观，下面就是一个NFA：<br><img src="/images/20170105/20170106225253.png" alt="NFA"></p><p>通过观察上图可以发现，在状态1输入b的时候，可能跳转到状态1，也可能跳转到状态2；而状态4则对任何输入不会有转移。这样的机器就是NFA。</p><p>OK，了解NFA的定义之后我们同样可以用Python来对其进行模拟。因为NFA的状态转移可能会对应多种的转移结果，所以与确定性有限自动机不一样，在非确定性有限自动机中我们用一个<strong>集合</strong>来保存所有可能转移到的状态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">NFA，非确定性有限自动机</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义了一个转移规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FARule</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, character, next_state</span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.character = character</span><br><span class="line">        self.nextState = next_state</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过判断当前的状态和输入和此规则是否相等来决定是否应该使用该种规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">applies</span>(<span class="params">self, state, character</span>):</span><br><span class="line">        <span class="keyword">return</span> self.state == state <span class="keyword">and</span> self.character == character</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取下一个规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_state</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.nextState</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样，我们需要一个规则转移的集合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FARuleBook</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 传入一个规则集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rule_set</span>):</span><br><span class="line">        self.ruleSet = rule_set</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过当前的状态集合和输入，根据转移规则集合，计算出所有可能的输出状态</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_next_states</span>(<span class="params">self, current_states, character</span>):</span><br><span class="line">        next_states = []</span><br><span class="line">        rule_set = self.ruleSet</span><br><span class="line">        <span class="keyword">for</span> current_state <span class="keyword">in</span> current_states:</span><br><span class="line">            <span class="keyword">for</span> rule <span class="keyword">in</span> rule_set:</span><br><span class="line">                <span class="keyword">if</span> rule.applies(current_state, character):</span><br><span class="line">                    next_states.append(rule.next_state())</span><br><span class="line">        <span class="comment"># 使用 set 有助于去除重复的集合</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(next_states)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化一个NFA的规则集合</span></span><br><span class="line">rulebook = FARuleBook([</span><br><span class="line">    FARule(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    FARule(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>),</span><br><span class="line">    FARule(<span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>),</span><br><span class="line">    FARule(<span class="number">2</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">    FARule(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>),</span><br><span class="line">    FARule(<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">4</span>),</span><br><span class="line">    FARule(<span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">4</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非确定性有限自动机</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NFA</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化包括初始状态、接受状态、规则转移集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, current_state, accept_state, rule_book</span>):</span><br><span class="line">        self.current_state = current_state</span><br><span class="line">        self.accept_state = accept_state</span><br><span class="line">        self.rule_book = rule_book</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过判断接受状态是否处于当前状态之中来测试当前是否可能处于接受状态</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">applies</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.accept_state <span class="keyword">in</span> self.current_state</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读入一个输入，根据当前状态获取到所有的可能的输出状态的集合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_character</span>(<span class="params">self, character</span>):</span><br><span class="line">        self.current_state = self.rule_book.get_next_states(self.current_state, character)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 同理，制作一个方便读入字符串的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_string</span>(<span class="params">self, string</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">            self.read_character(c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个NFA，切记输入状态应该是一个集合</span></span><br><span class="line">nfa = NFA([<span class="number">1</span>], <span class="number">4</span>, rulebook)</span><br><span class="line"><span class="comment"># 读入 bbb</span></span><br><span class="line">nfa.read_string(<span class="string">&#x27;bbb&#x27;</span>)</span><br><span class="line"><span class="comment"># 判断输入是否可能被接受（即输入是否是该有限自动机的正则语言）</span></span><br><span class="line"><span class="built_in">print</span>(nfa.applies())</span><br></pre></td></tr></table></figure><p>如果你看懂了上面程序，其实上面的代码所模拟的就是上面图例中的NFA。</p><p>需要注意的是，NFA有一点和DFA极其不一样的地方就在于NFA存在着一种名为<strong>自由移动</strong>的操作，所谓自由移动也就是说在NFA中某一种状态可以自由的转移到另一个状态而不需要任何的输入，下图就是一个例子：</p><p><img src="/images/20170105/20170107213227.png"></p><p>从状态1到状态2或者状态4的转移操作就叫做自由移动，不需要任何的输入就可以完成状态转移的操作。如果想用代码来描述的话，方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FARule(<span class="number">1</span>, <span class="literal">None</span>, <span class="number">2</span>)</span><br><span class="line">FARule(<span class="number">1</span>, <span class="literal">None</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="4-从NFA转为DFA"><a href="#4-从NFA转为DFA" class="headerlink" title="4. 从NFA转为DFA"></a>4. 从NFA转为DFA</h3><p>我们已经了解NFA和DFA，仔细的研究NFA，思考它和DFA有什么区别吗？之后观察下图：</p><p><img src="/images/20170105/20170107002652.png"></p><p>如果我们把一个NFA用上面的这种形式表现出来，那么它是不是就变成了一个DFA了呢？答案是肯定的。通过上图的这种转化方式，我们可以将任意一个NFA转化为DFA，具体的实现就不给出了，读者有兴趣可以自己实现。如果觉得有困难，可以参考<a target="_blank" rel="noopener" href="https://book.douban.com/subject/26148763/">计算的本质</a>的3.4节。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>有限自动机是一种非常简单但是又很重要的计算模型，我们后面提到的下推自动机和图灵机都是在有限自动机的基础上构造的，所以在查看后面的文章前请务必要先理解有限自动机这种计算模型。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="计算机的计算（一） - 有限自动机">https://www.nosuchfield.com/2017/01/05/Finite-automaton/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97/" rel="tag">计算</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>