<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>通过 BIOS 中断读取磁盘数据到内存 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="操作系统"><meta name="description" content="&lt;p&gt;&lt;em&gt;本文是&lt;a href=&#34;/2017/01/12/Write-an-operating-system-from-scratch/&#34;&gt;从零开始写个操作系统吧&lt;/a&gt;的系列文章之一。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在上篇文章中我们讲到了一些基础知识，然后通过BIOS中断成功的在屏幕上打印出了一个字符。不过我之前也提到了，把kernel从磁盘读到内存中也是bootsect的任务之一，所以这一次我们就来讲一讲如何通过BIOS中断把磁盘中的数据读取内存之中。&lt;/p&gt;
&lt;h3 id=&#34;1-磁盘的构造&#34;&gt;&lt;a href=&#34;#1-磁盘的构造&#34; class=&#34;headerlink&#34; title=&#34;1. 磁盘的构造&#34;&gt;&lt;/a&gt;1. 磁盘的构造&lt;/h3&gt;&lt;p&gt;关于磁盘构造这块我不太想多说了，毕竟网上都能查到。我们需要重点观点关注就是磁盘的三个属性：磁头（Heads）、柱面(Cylinder)、扇区(Sector)，也就是一般称为CHS的东西。只要使用这三个参数，我们就能定位到一个指定的扇区，接下来我就演示一下如何使用汇编语言操纵磁盘来从磁盘中读取数据到内存中。&lt;/p&gt;
&lt;h3 id=&#34;2-通过BIOS"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">通过 BIOS 中断读取磁盘数据到内存</h1></div><div class="post-meta"><span class="post-time">2017-01-17</span></div><div class="post-content"><p><em>本文是<a href="/2017/01/12/Write-an-operating-system-from-scratch/">从零开始写个操作系统吧</a>的系列文章之一。</em></p><p>在上篇文章中我们讲到了一些基础知识，然后通过BIOS中断成功的在屏幕上打印出了一个字符。不过我之前也提到了，把kernel从磁盘读到内存中也是bootsect的任务之一，所以这一次我们就来讲一讲如何通过BIOS中断把磁盘中的数据读取内存之中。</p><h3 id="1-磁盘的构造"><a href="#1-磁盘的构造" class="headerlink" title="1. 磁盘的构造"></a>1. 磁盘的构造</h3><p>关于磁盘构造这块我不太想多说了，毕竟网上都能查到。我们需要重点观点关注就是磁盘的三个属性：磁头（Heads）、柱面(Cylinder)、扇区(Sector)，也就是一般称为CHS的东西。只要使用这三个参数，我们就能定位到一个指定的扇区，接下来我就演示一下如何使用汇编语言操纵磁盘来从磁盘中读取数据到内存中。</p><h3 id="2-通过BIOS中断读取磁盘扇区中的数据到内存中"><a href="#2-通过BIOS中断读取磁盘扇区中的数据到内存中" class="headerlink" title="2. 通过BIOS中断读取磁盘扇区中的数据到内存中"></a>2. 通过BIOS中断读取磁盘扇区中的数据到内存中</h3><p>以下为代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line"></span><br><span class="line">; 打印启动信息</span><br><span class="line">mov bx, BOOT_MESSAGE</span><br><span class="line">call print_string</span><br><span class="line"></span><br><span class="line">; 开始读取</span><br><span class="line">call disk_load</span><br><span class="line"></span><br><span class="line">; 打印成功信息</span><br><span class="line">mov bx, BOOT_SUCCESS</span><br><span class="line">call print_string</span><br><span class="line"></span><br><span class="line">; 为了验证磁盘中的数据是否已经被成功读取到内存中了，我们把内存中对应位置的数据读取出来进行查看</span><br><span class="line">mov dx, [0x9000]        ; 打印 0x9000 处的字节，也就是第二个扇区的第一个字节</span><br><span class="line">call print_hex</span><br><span class="line">mov dx, [0x9000 + 512]  ; 打印 0x9512 处的字节，也就是第三个扇区的第一个字节</span><br><span class="line">call print_hex</span><br><span class="line">jmp $</span><br><span class="line"></span><br><span class="line">disk_load:</span><br><span class="line">    mov bx, 0x9000  ; 把磁盘指定扇区中的数据加载内存中的 0x0000(ES):0x9000(BX) 处</span><br><span class="line">    mov ah, 0x02    ; BIOS 读取扇区的方法</span><br><span class="line">    mov al, 2       ; 读取 2 个扇区</span><br><span class="line">    mov ch, 0x00    ; CHS 中的 cylinder 为 0</span><br><span class="line">    mov dh, 0x00    ; CHS 中的 head 为 0</span><br><span class="line">    mov cl, 0x02    ; 从第 2 个扇区开始读（即接在 bootsect 后面的扇区）</span><br><span class="line">    int 0x13        ; 使用 BIOS 13 号中断开始从磁盘读数据到内存</span><br><span class="line">    jc disk_error   ; 中断调用时会设置 carry flag，如果未设置，则发生了错误</span><br><span class="line">    mov bl, 2</span><br><span class="line">    cmp bl, al      ; BIOS 在读取时会把真正读取到的扇区数赋给 al</span><br><span class="line">    jne disk_error  ; 如果 al 不为 2，则说明读取发生了错误</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">disk_error:</span><br><span class="line">    mov bx, DISK_ERROR_MSG</span><br><span class="line">    call print_string</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">; 为了使代码保持整洁，我们把打印函数都放到 print.asm 文件中，这里的 include 和 C 语言中 include 的功能一样。</span><br><span class="line">%include &quot;print.asm&quot;</span><br><span class="line"></span><br><span class="line">; 用于打印的字符串，0x0a 和 0x0d 分别是换行和 Enter，你可以去掉其</span><br><span class="line">; 中一个来看一下打印出来的效果，这样可以方便你对这两个字符的理解</span><br><span class="line">BOOT_MESSAGE:</span><br><span class="line">    db &#x27;Karen is booting...&#x27;, 0x0a, 0x0d, 0</span><br><span class="line">BOOT_SUCCESS:</span><br><span class="line">    db &#x27;The kernel has been loaded.&#x27;, 0x0a, 0x0d, 0</span><br><span class="line"></span><br><span class="line">DISK_ERROR_MSG db &quot;Disk read error!&quot;, 0</span><br><span class="line"></span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">dw 0xaa55</span><br><span class="line"></span><br><span class="line">; dw 是两个字节，256 * 2 个字节 = 512 个字节，也就是说在结尾我们再加上两个 512 个字节的内容，现在汇编后的文件大小</span><br><span class="line">; 是 1.5kb，占用磁盘的前三个扇区。也就是说现在我们除了存有 bootsect 的第一个扇区之外还有存有数据的第二和第三个扇区了。</span><br><span class="line">times 256 dw 0x1234</span><br><span class="line">times 256 dw 0xface</span><br></pre></td></tr></table></figure><p>下面是 <code>print.asm</code> 文件中关于打印操作的打印代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">; 打印字符串</span><br><span class="line">print_string:</span><br><span class="line">    mov ah, 0x0e</span><br><span class="line">    mov cl, [bx]</span><br><span class="line">    cmp cl, 0</span><br><span class="line">    jne bx_add</span><br><span class="line">    ret</span><br><span class="line">bx_add:</span><br><span class="line">    mov al, [bx]</span><br><span class="line">    int 0x10</span><br><span class="line">    add bx, 1</span><br><span class="line">    jmp print_string</span><br><span class="line"></span><br><span class="line">; 打印两个个字节的 16 进制（不过顺序是反的，这个我没能解决）</span><br><span class="line">print_hex:</span><br><span class="line">    cmp dx, 0       ; 需要被打印的字节存储在 dx 中</span><br><span class="line">    je  end         ; 如果 dx 为 0，说明已经打印完毕，方法返回</span><br><span class="line"></span><br><span class="line">    mov cx, dx</span><br><span class="line">    shr dx, 4       ; dx 逻辑右移 4 位</span><br><span class="line">    and cl, 0xf     ; cl = dx 的低八位，这里再通过与操作得到 cl 的低四位，也就是 dx 的低四位</span><br><span class="line">    cmp cl, 10</span><br><span class="line">    jl less_ten     ; 如果此时 cl &lt; 10，执行方法 less_then</span><br><span class="line">    cmp cl, 10</span><br><span class="line">    jge great_ten   ; 如果此时 cl &gt;= 10，执行方法 great_then</span><br><span class="line">end:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">less_ten:</span><br><span class="line">    add cl, 48      ; 数字的 ASCII 码是从 48 开始的，数字 + 48 = 数字对应的 ASCII 码</span><br><span class="line">    mov al, cl</span><br><span class="line">    mov ah, 0x0e</span><br><span class="line">    int 0x10</span><br><span class="line">    jmp print_hex   ; 继续打印下一个字符</span><br><span class="line">great_ten:</span><br><span class="line">    add cl, 55      ; 大写字母的 ASCII 码是从 55 开始的，数字 + 55 = 字母对应的 ASCII 码</span><br><span class="line">    mov al, cl</span><br><span class="line">    mov ah, 0x0e</span><br><span class="line">    int 0x10</span><br><span class="line">    jmp print_hex</span><br></pre></td></tr></table></figure><p>汇编（汇编的时候只需要使用第一个文件即可，<code>print.asm</code> 文件会自动被nasm找到并且引用进来）并且使用虚拟机运行这个文件，运行结果应该如下所示：<br><img src="/images/20170117/20170118223412.png"></p><p>在这篇文章里我们主要了解到了BIOS 13号中断的使用以及如何打印一个字节的16进制，磁盘的读取实际上是一段比较机械的代码，主要是设置从什么地方开始读取磁盘、磁盘需要读取的扇区数以及这些数据要被读取到内存中的什么位置等等，这些都设置好之后执行一下中断就可以完成相关的操作了。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="通过 BIOS 中断读取磁盘数据到内存">https://www.nosuchfield.com/2017/01/17/Reads-disk-data-into-memory-via-BIOS-interrupt/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>