<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>从16位实模式到32位保护模式 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="操作系统"><meta name="description" content="&lt;p&gt;&lt;em&gt;本文是&lt;a href=&#34;/2017/01/12/Write-an-operating-system-from-scratch/&#34;&gt;从零开始写个操作系统吧&lt;/a&gt;的系列文章之一。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，我们在bootsect中所使用的地址计算方式皆为 &lt;code&gt;段地址 * 16 + 偏移地址&lt;/code&gt; ，也就是16位实模式下的计算方式。但是接下来我们需要介绍另外一种完全不同的计算方式，即32位保护模式下的计算方式。&lt;/p&gt;
&lt;h3 id=&#34;1-32位保护模式&#34;&gt;&lt;a href=&#34;#1-32位保护模式&#34; class=&#34;headerlink&#34; title=&#34;1. 32位保护模式&#34;&gt;&lt;/a&gt;1. 32位保护模式&lt;/h3&gt;&lt;p&gt;16位保护模式很好用，并且也很简单。既然如此，那么为什么那么我们还要使用32位保护模式呢？事实上，32位保护模式主要有如下两个优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩大CPU的寻址范围&lt;/li&gt;
&lt;li&gt;提升安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;32位保护模式下的地址计算方式和16为实模式不一样，在32位保护模式下，真正的地址不再等于 &lt;cod"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">从16位实模式到32位保护模式</h1></div><div class="post-meta"><span class="post-time">2017-01-19</span></div><div class="post-content"><p><em>本文是<a href="/2017/01/12/Write-an-operating-system-from-scratch/">从零开始写个操作系统吧</a>的系列文章之一。</em></p><p>到目前为止，我们在bootsect中所使用的地址计算方式皆为 <code>段地址 * 16 + 偏移地址</code> ，也就是16位实模式下的计算方式。但是接下来我们需要介绍另外一种完全不同的计算方式，即32位保护模式下的计算方式。</p><h3 id="1-32位保护模式"><a href="#1-32位保护模式" class="headerlink" title="1. 32位保护模式"></a>1. 32位保护模式</h3><p>16位保护模式很好用，并且也很简单。既然如此，那么为什么那么我们还要使用32位保护模式呢？事实上，32位保护模式主要有如下两个优势：</p><ul><li>扩大CPU的寻址范围</li><li>提升安全性</li></ul><p>32位保护模式下的地址计算方式和16为实模式不一样，在32位保护模式下，真正的地址不再等于 <code>段地址 * 16 + 偏移地址</code>。在32位保护模式下，段寄存器中存储的地址不再叫段地址，而是叫 <code>段选择子</code>。段选择子包含如下三个部分的数据：</p><ul><li>请求特权级RPL（Requested Privilege Level）；</li><li>TI，TI&#x3D;0表示描述符在GDT中，TI&#x3D;1表示描述符在LDT中；</li><li>索引值（Index）,查询GDT的时候所使用的就是这部分的索引值;</li></ul><p><img src="/images/20170119/20170207213836.png" alt="段选择子的示意图"></p><p>我们根据段选择子的索引去查询 <code>全局描述符表</code>，可以获得 <code>段描述符</code>，段描述符中存在着一个部分叫做 <code>基地址</code>，我们获取基地址之后再加上偏移地址，就可以获取到真正的内存中的地址了。以上步骤稍微有点复杂，不过复杂的部分只在段地址的计算的部分，偏移地址部分和16位实模式并没有任何区别，所以接下来我详细的介绍一下段地址的这一系列的转化的详情。这一系列步骤可以用下图来表示：</p><p><img src="/images/20170119/20170122220332.png"></p><p>通过上面的观察可以发现，GDT（全局描述符表）在这转换之中承担了一个非常重要的角色，所以接下来我们就详细的了解一下这个表的结构。</p><h3 id="2-GDT（全局描述符表）"><a href="#2-GDT（全局描述符表）" class="headerlink" title="2. GDT（全局描述符表）"></a>2. GDT（全局描述符表）</h3><p>GDT在本质上是一个<strong>数组</strong>，而我们之前提到的段选择子就是这个数组的下标，我们可以通过段选择子去查阅这个数组从而得到数组中一个指定的段描述符。GDT存在于内存中，CPU通过一个名叫 <code>gdtr</code> 的寄存器保存GDT的位置信息，所以我们在设定好了GDT之后，要把GDT的位置信息保存在gdtr中。所以我们可以使用如下的公式来计算出段描述符的位置：</p><pre><code>段描述符的位置 = 段选择子的索引 * 一个段描述符的长度 + gdtr的值
</code></pre><p>OK，我们已经知道GDT是一个数组，并且也知道如何让CPU找到我们的GDT在内存中的位置了。下面我来详细介绍一下GDT中的每一项（即段描述符）会存储哪些东西，正是依靠这些存储的内容我们才能获取到比16位实模式更好的内存使用方式。</p><p>段描述符的大小为8个字节，主要包含了以下三个部分：</p><ul><li>基址（32位），定义了这个段在物理内存的起始地址；</li><li>段大小（20位），定义了这个段的大小；</li><li>其他各种标志位（12位），包含了特权级以及读写权限等内容。</li></ul><p>下面就是一个段描述符的图示：<br><img src="/images/20170119/20170122223516.png" alt="段描述符"></p><p>标志位包含了这个段的读写权限、特权级等等一系列重要的属性，各个标志位的具体含义以及相应数值的意义请自行查阅资料获取。</p><p>在上面我们接触到了GDT、段选择子、段描述符等概念，如果理解起来稍有困难，下面这张图清晰地揭示了<strong>这些概念之间的关系</strong>：</p><p><img src="/images/20170119/20170122230430.png"></p><p>其中查阅GDT，找到对应的段描述符的步骤就是使用了公式 <code>段描述符的位置 = 段选择子 * 一个段描述符的长度 + gdtr的值</code> 来完成的。</p><p>现在，你应该已经基本上明白了段选择子、GDT、段描述符这些概念之间的关系了，接下来我们就要进入32位保护模式的世界了，不过在进入之前，我们还需要先根据需要来初始化一个GDT以供32位保护模式下的CPU使用。</p><h3 id="3-初始化GDT"><a href="#3-初始化GDT" class="headerlink" title="3. 初始化GDT"></a>3. 初始化GDT</h3><p>GDT可以存放在内存中的任意位置，不过设置好GDT之后需要把GDT在内存中的位置（大小为32位）和长度（大小为16位）保存在gdtr中，之后CPU就可以根据gdtr寄存器中的数据来寻找GDT在内存中的位置了。</p><p>了解了一些与GDT相关的概念之后，我们开始在内存中手动的创建一个GDT，并且使用 <code>lgdt</code> 指令把GDT的属性信息（即位置和长度信息）保存在gdtr中。下面就是一个我们创建GDT并把其信息保存在gdt中的汇编实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">[org 0x7c00]</span><br><span class="line"></span><br><span class="line">lgdt [gdt_descriptor]   ; 把 gdt 的位置保存到 gdtr 中</span><br><span class="line"></span><br><span class="line">cli                     ; 屏蔽中断</span><br><span class="line"></span><br><span class="line">; 把 cr0 的最低位置为 1，开启 32 位保护模式</span><br><span class="line">mov eax, cr0</span><br><span class="line">or eax, 0x1</span><br><span class="line">mov cr0, eax</span><br><span class="line"></span><br><span class="line">; jmp CODE_SEG:init_pm    ; 进行一次远跳转来刷新 CPU 缓存，存在问题</span><br><span class="line"></span><br><span class="line">; 初始化段寄存器的值并设置栈的位置</span><br><span class="line">init_pm:</span><br><span class="line">    mov ax, DATA_SEG</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov ss, ax</span><br><span class="line">    mov es, ax</span><br><span class="line">    mov fs, ax</span><br><span class="line">    mov gs, ax</span><br><span class="line">    mov ebp, 0x90000    ; 现在栈顶指向 0x90000</span><br><span class="line">    mov esp, ebp</span><br><span class="line">    call BEGIN_PM       ; 开始执行保护模式的代码</span><br><span class="line"></span><br><span class="line">BEGIN_PM:</span><br><span class="line">    mov ebx, STRING             ; 被打印字符的地址</span><br><span class="line">    mov edx, VIDEO_MEMORY       ; 显存的初始地址</span><br><span class="line">    mov ah, WHITE_ON_BLACK      ; 设置文字的颜色</span><br><span class="line"></span><br><span class="line">    call print_string_pm</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">print_string_pm:</span><br><span class="line">    mov al, [ebx]</span><br><span class="line">    cmp al, 0</span><br><span class="line">    je done</span><br><span class="line">    mov [edx], ax               ; al 为字符，ah 为颜色，修改显存对应位置的值即可显示字符</span><br><span class="line"></span><br><span class="line">    add ebx, 1          ; 字符的位置加一</span><br><span class="line">    add edx, 2          ; 显存的地址加二</span><br><span class="line">    jmp print_string_pm</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">VIDEO_MEMORY equ 0xb8000    ; 显存位置</span><br><span class="line">WHITE_ON_BLACK equ 0x0f     ; 背景色的控制</span><br><span class="line"></span><br><span class="line">STRING db &#x27;We are in protected mode!&#x27;, 0    ; 打印的字符</span><br><span class="line"></span><br><span class="line">; ******** GDT 开始的标记 ********</span><br><span class="line">gdt_start:</span><br><span class="line">; GDT 的第一项必须为 0</span><br><span class="line">gdt_null:</span><br><span class="line">    dd 0x0      ; dd，4 个字节</span><br><span class="line">    dd 0x0</span><br><span class="line">; 代码段描述符，一段很机械的的定义，参考 Intel 手册即可</span><br><span class="line">gdt_code:</span><br><span class="line">    ; base=0x0, limit=0xfffff ,</span><br><span class="line">    ; 1st flags: (present)1 (privilege)00 (descriptor type)1 -&gt; 1001b</span><br><span class="line">    ; type flags: (code)1 (conforming)0 (readable)1 (accessed)0 -&gt; 1010b</span><br><span class="line">    ; 2nd flags: (granularity)1 (32-bit default)1 (64-bit seg)0 (AVL)0 -&gt; 1100b</span><br><span class="line">    dw 0xffff ; Limit (bits 0-15)</span><br><span class="line">    dw 0x0 ; Base (bits 0-15)</span><br><span class="line">    db 0x0 ; Base (bits 16-23)</span><br><span class="line">    db 10011010b ; 1st flags , type flags</span><br><span class="line">    db 11001111b ; 2nd flags , Limit (bits 16-19)</span><br><span class="line">    db 0x0 ; Base (bits 24-31)</span><br><span class="line">; 数据段描述符，一段很机械的的定义，参考 Intel 手册即可</span><br><span class="line">gdt_data:</span><br><span class="line">    ; Same as code segment except for the type flags:</span><br><span class="line">    ; type flags: (code)0 (expand down)0 (writable)1 (accessed)0 -&gt; 0010b</span><br><span class="line">    dw 0xffff ; Limit (bits 0-15)</span><br><span class="line">    dw 0x0 ; Base (bits 0-15)</span><br><span class="line">    db 0x0 ; Base (bits 16-23)</span><br><span class="line">    db 10010010b ; 1st flags , type flags</span><br><span class="line">    db 11001111b ; 2nd flags , Limit (bits 16-19)</span><br><span class="line">    db 0x0 ; Base (bits 24-31)</span><br><span class="line">; 在这里放置一个标记方便我们计算 gdt 的长度</span><br><span class="line">gdt_end:</span><br><span class="line"></span><br><span class="line">; GDT descriptior</span><br><span class="line">gdt_descriptor:</span><br><span class="line">dw gdt_end - gdt_start - 1 ; Size of our GDT, always less one of the true size</span><br><span class="line">dd gdt_start ; Start address of our GDT</span><br><span class="line"></span><br><span class="line">; 把描述符的位置通过常量的值保存下来</span><br><span class="line">CODE_SEG equ gdt_code - gdt_start</span><br><span class="line">DATA_SEG equ gdt_data - gdt_start</span><br><span class="line"></span><br><span class="line">times 510-($-$$) db 0</span><br><span class="line">dw 0xaa55 </span><br></pre></td></tr></table></figure><p>汇编如上的代码并运行，能够得到如下的结果，红线中的字符就是我们通过改变显存中的数据从而打印出来的：<br><img src="/images/20170119/20170207225537.png"></p><p>到这里，你大概已经对 32 位保护模式有了一定的了解了，如果想要更加详细的对此进行了解，强烈推荐阅读<a target="_blank" rel="noopener" href="https://book.douban.com/subject/3229243/">Linux内核完全剖析</a>的第四章：80X86保护模式及其编程。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>这这篇文章中，我们了解到了32位保护模式和GDT的概念，以及如何通过设置GDT来帮助我们切换到32位保护模式。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="从16位实模式到32位保护模式">https://www.nosuchfield.com/2017/01/19/From-16-bit-real-mode-to-32-bit-protected-mode/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>