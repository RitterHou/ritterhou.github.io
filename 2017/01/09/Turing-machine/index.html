<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>计算机的计算（三） - 图灵机 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="计算,计算机"><meta name="description" content="&lt;p&gt;本文是&lt;a href=&#34;/2017/01/05/Computation-of-computers/&#34;&gt;计算机的计算&lt;/a&gt;系列的第三篇。&lt;/p&gt;
&lt;h3 id=&#34;1-图灵机&#34;&gt;&lt;a href=&#34;#1-图灵机&#34; class=&#34;headerlink&#34; title=&#34;1. 图灵机&#34;&gt;&lt;/a&gt;1. 图灵机&lt;/h3&gt;&lt;p&gt;20 世纪 30 年代，阿兰·图灵（Alan Turing）想要制造出一种可以替代人来进行计算的机器，他在论文《论可计算数及其在判定性问题上的应用》中提出了一种通用的计算机器。具体做法是给一台机器配上一条无限长的空纸带（实际上是一个两端都能随需增长的一维数组），并且允许在纸带上的任意位置读写字符。一条纸带既做存储又做输入：可以在纸带上预先填满字符串当作输入，然后机器在执行过程中可以读取这些字符并在必要的时候覆盖它们。&lt;/p&gt;
&lt;p&gt;能访问一条无限长纸带的有限状态自动机叫作图灵机（Turing Machine，TM ）。和下推自动机相比，图灵机不再只被限制在一个栈中，它可以随意的读取纸带上的任意一个位置。不过传统的图灵机并没有使用随意读取纸带任意一个位置的这种方式，而是使用"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">计算机的计算（三） - 图灵机</h1></div><div class="post-meta"><span class="post-time">2017-01-09</span></div><div class="post-content"><p>本文是<a href="/2017/01/05/Computation-of-computers/">计算机的计算</a>系列的第三篇。</p><h3 id="1-图灵机"><a href="#1-图灵机" class="headerlink" title="1. 图灵机"></a>1. 图灵机</h3><p>20 世纪 30 年代，阿兰·图灵（Alan Turing）想要制造出一种可以替代人来进行计算的机器，他在论文《论可计算数及其在判定性问题上的应用》中提出了一种通用的计算机器。具体做法是给一台机器配上一条无限长的空纸带（实际上是一个两端都能随需增长的一维数组），并且允许在纸带上的任意位置读写字符。一条纸带既做存储又做输入：可以在纸带上预先填满字符串当作输入，然后机器在执行过程中可以读取这些字符并在必要的时候覆盖它们。</p><p>能访问一条无限长纸带的有限状态自动机叫作图灵机（Turing Machine，TM ）。和下推自动机相比，图灵机不再只被限制在一个栈中，它可以随意的读取纸带上的任意一个位置。不过传统的图灵机并没有使用随意读取纸带任意一个位置的这种方式，而是使用了一个更为简单的方式：</p><blockquote><p>用一个纸带头（tape head）指向纸带的一个特定位置，并且只能在那个位置读取或写入字符。每一步计算之后，纸带头都可以向左或者向右移动一个方格。</p></blockquote><p>这种只进行左移或者右移的操作并没有降低图灵机的计算能力（虽然有些降低了图灵机的执行速度，但是这种牺牲是值得的），却提高了图灵机的简单性。此外，为了进一步保持图灵机的简单，我们在纸带上只会写两个数：0和1。</p><p>现在我们已经了解了图灵机的构造及所包含的基本操作了，下面我们开始了解图灵机的转移规则，下面是一组转移规则的示例：</p><table><thead><tr><th align="center">当前状态</th><th align="center">读入当前格子的数</th><th align="center">写数字到当前的格子</th><th align="center">转移到的状态</th><th align="center">纸带头移动方向</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">2</td><td align="center">R</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">3</td><td align="center">L</td></tr></tbody></table><p>上面是个非常简单的转移规则的例子，第一条是当前状态为1，读入为1，此时向格子上写入0，然后进入状态2，接着纸带头右移；第二条则是当前状态为1，读入为0，此时向个格子上写入1，然后进入状态3，接着纸带头左移。</p><p>转移规则还是很容易理解，需要注意的是图灵机把状态机的输入和纸带中的数据联系了起来。想想在下推自动机中，自动机的输入和栈中的数据是割裂开来的，但是在图灵机中，自动机中的输入<strong>就是</strong>纸带上的数据，这种联系使得图灵机更加简单，因为我们此时只需要考虑纸带就可以，而不再去考虑一个额外的输入了。</p><p>其实这种方式有着一个更为重要的优点，也就是我们可以在上一步的转移操作中为下一步的转移操作设计好一个输入，这在下推自动机中是做不到的，因为下推自动机的输入只能由我们人类来给出，而不能由机器给出。我们为图灵机设计好一个最初始的输入和转移规则之后，图灵机可以通过自己给自己设计输入然后永远的执行下去。</p><p>同样,我们可以使用示意图来模拟一个图灵机，例如下面这个就代表了一个图灵机，它对应的规则在后面给出了。</p><p><img src="/images/20170109/20170110214505.png" alt="图灵机"></p><ul><li>处于状态 1 并且读入一个 0 时，写入一个 1，右移，然后进入状态 2；</li><li>处于状态 1 并且读入一个 1 时，写入一个 0，左移，然后保持在状态 1；</li><li>处于状态 1 并且读到一个空白时，写入一个 1，右移，然后进入状态 2；</li><li>处于状态 2 并且读到一个 0 时，写入一个 0，右移，然后保持在状态 2；</li><li>处于状态 2 并且读入一个 1 时，写入一个 1，右移，然后保持在状态 2；</li><li>处于状态 2 并且读到一个空白时，写入一个空白，左移，然后进入状态 3。</li></ul><p>到这里我们已经大致的了解了图灵机的基本构造。同样的，图灵机也分为确定型图灵机和非确定型图灵机，下面我们将分别进行讨论。</p><h3 id="2-确定型图灵机"><a href="#2-确定型图灵机" class="headerlink" title="2. 确定型图灵机"></a>2. 确定型图灵机</h3><p>确定型图灵机意味着该图灵机的转移规则不会存在冲突，同时也意味着不会有转移规则的缺失问题。对于第二点，因为较为复杂，所以我们和前面一样不予考虑，我们目前只对唯一性进行限制。下面是一个用Python所模拟的图灵机：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">能访问一条无限长纸带的有限状态自动机叫作图灵机（Turing Machine，TM ）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 纸带</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tape</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, left, middle, right, blank</span>):</span><br><span class="line">        self.left = left</span><br><span class="line">        self.middle = middle</span><br><span class="line">        self.right = right</span><br><span class="line">        self.blank = blank</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 纸带头写当前位置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">self, character</span>):</span><br><span class="line">        <span class="keyword">return</span> Tape(self.left, character, self.right, self.blank)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 纸带头左移</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move_head_left</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 让纸带可以自动扩展</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.left) == <span class="number">0</span>:</span><br><span class="line">            self.left = [<span class="string">&#x27;_&#x27;</span>]</span><br><span class="line">        <span class="comment"># -1 在右边的时候是不被包含的</span></span><br><span class="line">        <span class="keyword">return</span> Tape(self.left[:-<span class="number">1</span>], self.left[-<span class="number">1</span>], [self.middle] + self.right, self.blank)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 纸带头右移</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move_head_right</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 让纸带可以自动扩展</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.right) == <span class="number">0</span>:</span><br><span class="line">            self.right = [<span class="string">&#x27;_&#x27;</span>]</span><br><span class="line">        <span class="keyword">return</span> Tape(self.left + [self.middle], self.right[<span class="number">0</span>], self.right[<span class="number">1</span>:], self.blank)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 最后一个是空白字符的代表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.left + [<span class="string">&#x27;[&#x27;</span> + self.middle + <span class="string">&#x27;]&#x27;</span>] + self.right + [<span class="string">&#x27;&lt;&#x27;</span> + self.blank + <span class="string">&#x27;&gt;&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tape1 = Tape([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>], <span class="string">&#x27;1&#x27;</span>, [], <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(tape1)</span></span><br><span class="line"><span class="comment"># tape1 = tape1.move_head_left()</span></span><br><span class="line"><span class="comment"># print(tape1)</span></span><br><span class="line"><span class="comment"># tape1 = tape1.write(&#x27;0&#x27;)</span></span><br><span class="line"><span class="comment"># print(tape1)</span></span><br><span class="line"><span class="comment"># tape1 = tape1.move_head_right()</span></span><br><span class="line"><span class="comment"># print(tape1)</span></span><br><span class="line"><span class="comment"># tape1 = tape1.write(&#x27;0&#x27;)</span></span><br><span class="line"><span class="comment"># print(tape1)</span></span><br><span class="line"><span class="comment"># tape1 = tape1.write(&#x27;1&#x27;)</span></span><br><span class="line"><span class="comment"># print(tape1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和前面的一样，一个图灵机的配置是一个状态和一条纸带的组合</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TMConfiguration</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, tape</span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.tape = tape</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(self.state) + <span class="string">&#x27; -&gt; &#x27;</span> + <span class="built_in">str</span>(self.tape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 图灵机的一个转移规则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TMRule</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 参数：当前状态，读入纸带，下一个状态，写入纸带，纸带头移动方向</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, state, read_character, next_state, write_character, direction</span>):</span><br><span class="line">        self.state = state</span><br><span class="line">        self.read_character = read_character</span><br><span class="line">        self.next_state = next_state</span><br><span class="line">        self.write_character = write_character</span><br><span class="line">        self.direction = direction</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当一个配置的状态和它当前的读入字符与某一个转移规则的状态和读入字符相等时，</span></span><br><span class="line">    <span class="comment"># 我们可以认为此配置符合该转移规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">applies_to</span>(<span class="params">self, configuration</span>):</span><br><span class="line">        <span class="keyword">return</span> self.state == configuration.state <span class="keyword">and</span> self.read_character == configuration.tape.middle</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据当前规则，计算出当前配置的下一个配置（注：当前配置必须是已经符合当前转移规则的一个配置）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">follow</span>(<span class="params">self, configuration</span>):</span><br><span class="line">        <span class="keyword">return</span> TMConfiguration(self.next_state, self.__next_tape(configuration))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算出纸带的下一个状态</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next_tape</span>(<span class="params">self, configuration</span>):</span><br><span class="line">        written_tape = configuration.tape.write(self.write_character)</span><br><span class="line">        <span class="keyword">if</span> self.direction == <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> written_tape.move_head_left()</span><br><span class="line">        <span class="keyword">elif</span> self.direction == <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> written_tape.move_head_right()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rule1 = TMRule(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;R&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(rule1.applies_to(TMConfiguration(<span class="number">1</span>, Tape([], <span class="string">&#x27;0&#x27;</span>, [], <span class="string">&#x27;_&#x27;</span>))))</span><br><span class="line"><span class="built_in">print</span>(rule1.applies_to(TMConfiguration(<span class="number">1</span>, Tape([], <span class="string">&#x27;1&#x27;</span>, [], <span class="string">&#x27;_&#x27;</span>))))</span><br><span class="line"><span class="built_in">print</span>(rule1.applies_to(TMConfiguration(<span class="number">2</span>, Tape([], <span class="string">&#x27;0&#x27;</span>, [], <span class="string">&#x27;_&#x27;</span>))))</span><br><span class="line"><span class="built_in">print</span>(rule1.follow(TMConfiguration(<span class="number">1</span>, Tape([<span class="string">&#x27;&#x27;</span>], <span class="string">&#x27;0&#x27;</span>, [<span class="string">&#x27;&#x27;</span>], <span class="string">&#x27;_&#x27;</span>))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把一个图灵机的规则整理起来就是一个转移规则集合了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DTMRulebook</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rules</span>):</span><br><span class="line">        self.rules = rules</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据当前配置找到下一个配置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_configuration</span>(<span class="params">self, configuration</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__rule_for(configuration).follow(configuration)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据当前配置去规则集合中找符合要求的转移规则</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__rule_for</span>(<span class="params">self, configuration</span>):</span><br><span class="line">        <span class="keyword">for</span> rule <span class="keyword">in</span> self.rules:</span><br><span class="line">            <span class="keyword">if</span> rule.applies_to(configuration):</span><br><span class="line">                <span class="keyword">return</span> rule</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;找不到可供使用的规则 ...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rulebook1 = DTMRulebook([</span><br><span class="line">    TMRule(<span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;R&#x27;</span>),</span><br><span class="line">    TMRule(<span class="number">1</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;L&#x27;</span>),</span><br><span class="line">    TMRule(<span class="number">1</span>, <span class="string">&#x27;_&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;R&#x27;</span>),</span><br><span class="line">    TMRule(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;R&#x27;</span>),</span><br><span class="line">    TMRule(<span class="number">2</span>, <span class="string">&#x27;1&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;R&#x27;</span>),</span><br><span class="line">    TMRule(<span class="number">2</span>, <span class="string">&#x27;_&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;_&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">])</span><br><span class="line">configuration1 = TMConfiguration(<span class="number">1</span>, tape1)</span><br><span class="line"><span class="built_in">print</span>(configuration1)</span><br><span class="line">configuration1 = rulebook1.next_configuration(configuration1)</span><br><span class="line"><span class="built_in">print</span>(configuration1)</span><br><span class="line">configuration1 = rulebook1.next_configuration(configuration1)</span><br><span class="line"><span class="built_in">print</span>(configuration1)</span><br><span class="line">configuration1 = rulebook1.next_configuration(configuration1)</span><br><span class="line"><span class="built_in">print</span>(configuration1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对上面的图灵机进行一些封装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DTM</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, current_configuration, accept_states, rulebook</span>):</span><br><span class="line">        self.current_configuration = current_configuration</span><br><span class="line">        self.accept_states = accept_states</span><br><span class="line">        self.rulebook = rulebook</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断当前配置是否是可接受的</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accepting</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.current_configuration.state <span class="keyword">in</span> self.accept_states</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转移到下一个配置</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">self</span>):</span><br><span class="line">        self.current_configuration = self.rulebook.next_configuration(self.current_configuration)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不断的把配置转移到下一个直到处于接受状态</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.accepting():</span><br><span class="line">            self.step()</span><br><span class="line">        <span class="comment"># 直接可以接受时才返回当前的配置</span></span><br><span class="line">        <span class="keyword">return</span> self.current_configuration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dtm = DTM(TMConfiguration(<span class="number">1</span>, tape1), [<span class="number">3</span>], rulebook1)</span><br><span class="line"><span class="built_in">print</span>(dtm.current_configuration)</span><br><span class="line"><span class="built_in">print</span>(dtm.accepting())</span><br><span class="line"><span class="built_in">print</span>(dtm.step)</span><br><span class="line"><span class="built_in">print</span>(dtm.current_configuration)</span><br><span class="line"><span class="built_in">print</span>(dtm.accepting())</span><br><span class="line"><span class="built_in">print</span>(dtm.run())</span><br><span class="line"><span class="built_in">print</span>(dtm.current_configuration)</span><br><span class="line"><span class="built_in">print</span>(dtm.accepting())</span><br></pre></td></tr></table></figure><p>阅读完并理解以上代码之后你就会发现，图灵机相比于下推自动机要容易理解一点，因为“简单性”也是图灵机的重要性质之一。阿兰·图灵设计这种机器的时候特意让它们保持简单以便容易构建和推导，所以图灵机更容易被模拟出来。</p><h3 id="3-非确定型图灵机"><a href="#3-非确定型图灵机" class="headerlink" title="3. 非确定型图灵机"></a>3. 非确定型图灵机</h3><p>对于一台图灵机，“不确定性”意味着每个状态和字符的组合会允许多于一个的规则，因此从一个起始配置开始会有多个可能的执行路径，这就是我们所说的非确定型图灵机。</p><p>和NFA与DFA的关系一样，任意一台非确定型图灵机都可以用一台DTM（Deterministic Turing Machine，确定型图灵机）表示出来，所以我们说：</p><blockquote><p>非确定型图灵机并不能比DTM拥有更大的计算能力</p></blockquote><p>事实上，确定型图灵机代表了从有限计算机器到全能机器的临界点。也就是说，通过升级图灵机规范以使其更强大的任何尝试都注定失败。《计算的本质》中作者还举出了其他的一些计算模型，然而这些模型无一例外地都和图灵机的计算能力等价，因此邱奇、图灵和哥德尔提出了著名的邱奇-图灵论题：</p><blockquote><p>一切直觉上能计算的函数都可用图灵机计算，反之亦然。</p></blockquote><h3 id="4-通用图灵机"><a href="#4-通用图灵机" class="headerlink" title="4. 通用图灵机"></a>4. 通用图灵机</h3><p>通过把Tape、TMRule、DTMRulebook以及DTM重新实现成图灵机的规则，我们能设计一台图灵机，它能通过从纸带读取其规则、接受状态以及起始配置然后单步执行，模拟任何其他确定型图灵机，本质上这扮演着图灵机规则手册解释器的角色。完成这种工作的机器叫作通用图灵机（Universal Turing Machine，UTM） 。</p><p>这里需要理解的是，通用图灵机本身也是一台确定型图灵机，只是这台图灵机<strong>能够在内部模拟出其它的图灵机</strong>，正是因为其可以模拟出其它的图灵机，所以它的规则就不再是硬编码的。我们使用这台通用图灵机的时候，可以根据需要来模拟一台不同的图灵机，而这台新的图灵机的转移规则可以在模拟的时候进行规定，所以此时这台通用图灵机的操作就不再是硬编码的了，而是可以根据需要来进行创建。</p><h3 id="5-从图灵机到CPU"><a href="#5-从图灵机到CPU" class="headerlink" title="5. 从图灵机到CPU"></a>5. 从图灵机到CPU</h3><p>我假设你已经明白了类似于半加器、全加器这样的计算电路，这种电路被称之为组合逻辑电路。它的任一时刻的稳态输出，仅仅与该时刻的输入变量的取值有关，而与该时刻以前的输入变量取值无关。</p><p>与组合逻辑电路相对应的时序逻辑电路，时序逻辑电路是指电路任何时刻的稳态输出不仅取决于当前的输入，还与前一时刻输入形成的状态有关。看到了时序逻辑电路，是不觉得它和自动机的性质非常相似？事实上，给定任何确定自动机，我们都可以设计这样一个时序电路。所以我们可以根据通用图灵机的性质来设计一个时序电路，而这样的一个电路，就是CPU。</p><p>但是需要注意的是，CPU不一定非要是由电路构成，因为通用图灵机本身是一个抽象的模型，所以我们自然可以通过各种来实现这个抽象模型。事实上，第一个把计算和电子元件联系起来的人是香农，他在论文《对继电器和开关电路中的符号分析》中首次提出通过电器元件来进行数学计算，并证明了可以通过继电器电路来实现布尔代数的逻辑运算。</p><p>现代CPU的执行流程主要包括如下几步（CSAPP 4.3.1节）：</p><ol><li>取指（fetch）</li><li>译码（decode）</li><li>执行（execute）</li><li>访存（memory）</li><li>写回（write back）</li><li>更新PC（PC update）</li></ol><p>这几个步骤大致相当于图灵机的：</p><ol><li>读纸带</li><li>寻找对应的转移规则</li><li>找到规则，执行</li><li>向纸带上写回数据</li><li>更新状态</li><li>读写头向左或向右移动</li></ol><p>下面可以通过一个表格来进行更直观的对比：</p><table><thead><tr><th align="left">CPU</th><th align="left">图灵机</th></tr></thead><tbody><tr><td align="left">取指</td><td align="left">读纸带</td></tr><tr><td align="left">译码</td><td align="left">寻找对应的转移规则</td></tr><tr><td align="left">执行</td><td align="left">找到规则，执行</td></tr><tr><td align="left">访存</td><td align="left">向纸带上写回数据</td></tr><tr><td align="left">写回</td><td align="left">（同上）</td></tr><tr><td align="left">更新PC</td><td align="left">更新状态，读写头向左或向右移动</td></tr></tbody></table><p>我们可以发现图灵机和CPU的执行过程十分相似，因为CPU本来就是根据图灵的计算模型而设计出来的。</p><p>到这里图灵机就讲的差不多了，<a href="/images/20170109/turing.pdf">这里</a>有一篇文章也是讲图灵机的，算是一篇科普文，讲的也是比较不错的，有兴趣的可以看看。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="计算机的计算（三） - 图灵机">https://www.nosuchfield.com/2017/01/09/Turing-machine/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97/" rel="tag">计算</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>