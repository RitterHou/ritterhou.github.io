<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>Java中的Future模式 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="Java,设计模式"><meta name="description" content="&lt;h3 id=&#34;1-synchronized关键字的类锁和对象锁&#34;&gt;&lt;a href=&#34;#1-synchronized关键字的类锁和对象锁&#34; class=&#34;headerlink&#34; title=&#34;1. synchronized关键字的类锁和对象锁&#34;&gt;&lt;/a&gt;1. synchronized关键字的类锁和对象锁&lt;/h3&gt;&lt;p&gt;synchronized关键字的作用位置可能包含以下几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非静态方法上（在执行该方法时，对这个方法所属的对象进行加锁）；&lt;/li&gt;
&lt;li&gt;静态方法上（在执行该方法时，对该方法对应的整个类进行加锁）；&lt;/li&gt;
&lt;li&gt;直接在代码块中对某个对象加锁（在执行该代码块时，对该对象进行加锁）；&lt;/li&gt;
&lt;li&gt;直接在代码块中对某个类进行加锁（在执行该代码块时，对这个类进行加锁）；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里我们先写一个线程不安全的实例：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">Java中的Future模式</h1></div><div class="post-meta"><span class="post-time">2017-03-22</span></div><div class="post-content"><h3 id="1-synchronized关键字的类锁和对象锁"><a href="#1-synchronized关键字的类锁和对象锁" class="headerlink" title="1. synchronized关键字的类锁和对象锁"></a>1. synchronized关键字的类锁和对象锁</h3><p>synchronized关键字的作用位置可能包含以下几种情况：</p><ol><li>非静态方法上（在执行该方法时，对这个方法所属的对象进行加锁）；</li><li>静态方法上（在执行该方法时，对该方法对应的整个类进行加锁）；</li><li>直接在代码块中对某个对象加锁（在执行该代码块时，对该对象进行加锁）；</li><li>直接在代码块中对某个类进行加锁（在执行该代码块时，对这个类进行加锁）；</li></ol><p>这里我们先写一个线程不安全的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        service.submit(thread);</span><br><span class="line">        service.submit(thread);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-1-对非静态方法进行同步"><a href="#1-1-对非静态方法进行同步" class="headerlink" title="1.1. 对非静态方法进行同步"></a>1.1. 对非静态方法进行同步</h4><p>上面这个例子不能让一个线程<strong>连续的</strong>打印出线程开始和线程结束语句，这里我们只需要在<code>run</code>方法上面加上<code>synchronized</code>关键字就可以保证线程的同步执行，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        service.submit(thread);</span><br><span class="line">        service.submit(thread);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是需要注意的是，千万不要认为给run方法加上了<code>synchronized</code>关键字就万事ok了，在上面的这个例子中确实是这样，但是这是因为我们两个线程使用的是同一个Thread对象（还记得我前面说的非静态方法上的synchronized关键字是对该方法所属的对象进行加锁），所以这个run方法对应的对象会被加锁而导致了同步。但是如果这个run方法是属于两个不同的对象，那么即使你对run方法加上了synchronized关键字，虽然各自的Thread对象会被加锁，但是这两个线程却仍然会交替执行，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 创建的是两个不同的对象，synchronized只会对自己方法所对应的对象加锁</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>了解了非静态方法的synchronized关键字的含义和用法之后，我们再来了解一下静态方法的synchronized关键字的含义。</p><h4 id="1-2-对静态方法进行同步"><a href="#1-2-对静态方法进行同步" class="headerlink" title="1.2. 对静态方法进行同步"></a>1.2. 对静态方法进行同步</h4><p>我们看这样的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Test.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个线程都会试图执行Test类的<code>sayHello()</code>静态方法，如果不进行同步操作，将会打印出如下语句：</p><pre><code>线程开始...
线程开始...
线程结束...
线程结束...
</code></pre><p>但是当我们在<code>sayHello()</code>方法上加上了synchronized关键字之后，就能够保证这两个线程在执行<code>sayHello()</code>静态方法的时候不会产生竞争条件了，修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Test.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程开始...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲完了synchronized关键字对方法的修饰方式之后，我们来了解一下synchronized关键字在代码块中的操作，首先我们了解一下synchronized关键字在代码块中对对象进行同步的操作。</p><h4 id="1-3-对代码快进行同步：锁住对象"><a href="#1-3-对代码快进行同步：锁住对象" class="headerlink" title="1.3. 对代码快进行同步：锁住对象"></a>1.3. 对代码快进行同步：锁住对象</h4><p>synchronized关键字在代码块中锁对象的最简单的操作就是锁住 <code>this</code> 对象，这种情况的操作其实和把synchronized加在非静态方法上的效果是一样的，都是表示在这些代码执行的时候，对<strong>当前对象</strong>进行加锁，他们的区别只是作用的粒度的大小而已，下面就是一个很简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        service.submit(thread);</span><br><span class="line">        service.submit(thread);</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程开始...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的效果和直接在方法 <code>run</code> 上加synchronized关键字的效果是一致的。除了锁当前对象之外，对于这种情况，我们还可以对其余的任意一个对象进行加锁，当某一个线程进入该代码块执行程序时，就会对这个对象进行加锁，防止其余线程对这个对象进行操作。下面就是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(test, <span class="number">1</span>)); <span class="comment">// 线程 1</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(test, <span class="number">2</span>)); <span class="comment">// 线程 2</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> name;</span><br><span class="line"></span><br><span class="line">    Thread1(Test test, <span class="type">int</span> name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="number">1</span>) &#123;</span><br><span class="line">            test.i = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 线程 1 休眠一段时间，让线程 2 有机会改变 test 的对象的值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：&quot;</span> + test.i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            test.i = <span class="number">200</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2：&quot;</span> + test.i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，线程1打印的值也变成了200，这不是我们想要的，下面我们通过锁操作来避免这种情况的产生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(test, <span class="number">1</span>)); <span class="comment">// 线程 1</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(test, <span class="number">2</span>)); <span class="comment">// 线程 2</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> name;</span><br><span class="line"></span><br><span class="line">    Thread1(Test test, <span class="type">int</span> name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (test) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="number">1</span>) &#123;</span><br><span class="line">                test.i = <span class="number">100</span>;</span><br><span class="line">                <span class="comment">// 线程 1 休眠一段时间，让线程 2 有机会改变 test 的对象的值</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1：&quot;</span> + test.i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                test.i = <span class="number">200</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2：&quot;</span> + test.i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们对 <code>test</code> 对象进行了加锁操作，保证在指定的代码块执行的时候，test对象身上是有锁的，避免了多个线程能够同时操作test对象，保证了不会发生竞争条件。</p><h4 id="1-4-对代码块进行同步：锁住类"><a href="#1-4-对代码块进行同步：锁住类" class="headerlink" title="1.4. 对代码块进行同步：锁住类"></a>1.4. 对代码块进行同步：锁住类</h4><p>同样我们先提供一个产生了竞争条件的程序，它使得两个线程可以同时的改变一个类的静态属性的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="number">1</span>)); <span class="comment">// 线程 1</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="number">2</span>)); <span class="comment">// 线程 2</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> name;</span><br><span class="line"></span><br><span class="line">    Thread1(<span class="type">int</span> name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="number">1</span>) &#123;</span><br><span class="line">            Test.i = <span class="number">100</span>;</span><br><span class="line">            <span class="comment">// 线程 1 休眠一段时间，让线程 2 有机会改变 Test 类的静态属性值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程1：&quot;</span> + Test.i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Test.i = <span class="number">200</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程2：&quot;</span> + Test.i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的执行结果为：</p><pre><code>线程2：200
线程1：200
</code></pre><p>显然这种结果是不符合要求的，下面我们通过对类进行加锁来避免这种情况的发生，修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="number">1</span>)); <span class="comment">// 线程 1</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(<span class="number">2</span>)); <span class="comment">// 线程 2</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> name;</span><br><span class="line"></span><br><span class="line">    Thread1(<span class="type">int</span> name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Test.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="number">1</span>) &#123;</span><br><span class="line">                Test.i = <span class="number">100</span>;</span><br><span class="line">                <span class="comment">// 线程 1 休眠一段时间，让线程 2 有机会改变 Test 类的静态属性值</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1：&quot;</span> + Test.i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Test.i = <span class="number">200</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2：&quot;</span> + Test.i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过给Test类上锁，来避免两个线程同时操作类的属性，避免了竞争条件的产生。</p><h4 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5. 小结"></a>1.5. 小结</h4><p>上面一共有四种情况，不外乎就是方法、代码块、类、对象的四种组合。如果你稍微了解JVM，那么应该知道JVM中只有堆内存区和方法区是线程共享的，而诸如程序计数器、栈（包含Java栈和本地方法栈）这样的内存空间是各个线程各自独有的，所以我们的关注点自然就放到了堆和方法区中了。此外我们还知道，对象是存储在堆中、类属性是保存在方法区中的，所以我们只需要了解这些基础知识就可以很容易的了解内存中数据的操作情况了。</p><h3 id="2-线程间的协作（wait和notify关键字）"><a href="#2-线程间的协作（wait和notify关键字）" class="headerlink" title="2. 线程间的协作（wait和notify关键字）"></a>2. 线程间的协作（wait和notify关键字）</h3><p>我们知道，线程的状态一般可以分为就绪、阻塞、运行这三种状态，而所谓的wait和notify方法只是分别让线程进入了阻塞和就绪的状态而已。</p><p>当一个线程上的同步对象调用wait方法时（只能是同步对象才能调用，否则会产生异常，notify方法也是同理），会使得当前线程进入阻塞；而notifyAll方法则是让所有在该对象上的阻塞线程进入就绪态，其中notify方法只是从所有的阻塞线程中<strong>随机的选择一个线程</strong>进入就绪态，一般不推荐使用。</p><p>了解了wait和notifyAll方法的运行原理，下面看一个实际使用了这两个方法的例子，这个例子的目的是使得两个线程绝对的交替执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(test, <span class="number">1</span>)); <span class="comment">// 线程 1</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="title class_">Thread1</span>(test, <span class="number">2</span>)); <span class="comment">// 线程 2</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Test test;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> name;</span><br><span class="line"></span><br><span class="line">    Thread1(Test test, <span class="type">int</span> name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.test = test;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (test) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                test.notifyAll(); <span class="comment">// 唤醒所有在 test 对象上阻塞的线程，使他们进入就绪态</span></span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test.wait(); <span class="comment">// 当前线程进入阻塞态</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 降低打印速度，方便看清输出</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序的执行中，两个线程的状态我们可以如下这张表来表示：</p><table><thead><tr><th align="center">时间片</th><th align="center">线程1状态</th><th align="center">线程2状态</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">运行</td><td align="center">就绪</td></tr><tr><td align="center">2</td><td align="center">阻塞</td><td align="center">就绪</td></tr><tr><td align="center">3</td><td align="center">阻塞</td><td align="center">运行</td></tr><tr><td align="center">4</td><td align="center">就绪</td><td align="center">运行</td></tr><tr><td align="center">5</td><td align="center">就绪</td><td align="center">阻塞</td></tr><tr><td align="center">6</td><td align="center">运行</td><td align="center">阻塞</td></tr><tr><td align="center">7</td><td align="center">运行</td><td align="center">就绪</td></tr><tr><td align="center">8</td><td align="center">…</td><td align="center">…</td></tr></tbody></table><p>上面这个过程将会一直的执行下去，如此往复，保证了控制台能够交替稳定的打印出1和2。</p><h3 id="3-Java-实现Future模式"><a href="#3-Java-实现Future模式" class="headerlink" title="3. Java 实现Future模式"></a>3. Java 实现Future模式</h3><p>所谓的future设计模式，简单来说，就是把客户端的请求改为异步，当客户端进行某种请求时，可以立即返回，可以方便客户端去做接下来的其他事情。接下来，当服务端的请求完成时，客户端再去执行相应的操作，从而提高了效率。</p><p>Future模式本质上其实是创建了一个新的线程，利用这个新的线程来去进行真实的请求和响应接受操作，下面就是一个简单的例子（这个例子参考了<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/ce54d86051b8">这里</a>，如有侵权请告知删除）。</p><p>例子中我们一共会包含以下几个文件：</p><pre><code>├── root
│   ├── Data.java
│   ├── RealData.java
│   ├── FutureData.java
│   ├── Client.java
│   ├── Test.java
</code></pre><ul><li>Data.java 是一个接口，定义了 <code>String getResult()</code> 方法；</li><li>RealData.java 实现了Data接口，是 <code>getResult()</code> 方法的业务实现的类（方法真正需要实现的操作就放在这里面）；</li><li>FutureData.java同样实现了Data接口，它是Future设计模式的核心，它将会在内部获取一个 <code>RealData</code> 的对象，并执行该对象的 <code>getResult()</code> 方法；</li><li>Client.java是一个类，他封装了Future设计模式中的一些核心操作，来提供给调用者使用，抽象了Future模式，降低了使用者的操作成本（我会在最后再提供一个不使用Client类来实现Future模式的Demo，它们的原理都是一样的）；</li><li>Test.java是测试类，包含了我们的 <code>main</code> 方法；</li></ul><p>Data.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    String <span class="title function_">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RealData.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RealData</span> <span class="keyword">implements</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line"></span><br><span class="line">    RealData(String data) &#123;</span><br><span class="line">        <span class="comment">// 利用sleep方法来表示RealData构造过程是非常缓慢的</span></span><br><span class="line">        <span class="comment">// 表示我们正在调用一个执行很慢的函数，它要很久才能返回</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;RealData生成中...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;RealData: &quot;</span> + data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureData.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FutureData</span> <span class="keyword">implements</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RealData realData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否已经设置了realData</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isReady</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setRealData</span><span class="params">(RealData realData)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isReady) <span class="comment">// 如果已经设置了RealData，那么直接返回就可以了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">this</span>.realData = realData;</span><br><span class="line">        isReady = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;FutureData中已经设置好了RealData数据了&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">getResult</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isReady) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;FutureData中的RealData还没有设置好，等待ing&quot;</span>);</span><br><span class="line">            wait(); <span class="comment">// 一直等到RealData注入到FutureData中</span></span><br><span class="line">            System.out.println(<span class="string">&quot;RealData已经被设置到FutureData中了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> realData.getResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 Data</span></span><br><span class="line">    <span class="keyword">static</span> Data <span class="title function_">request</span><span class="params">(<span class="keyword">final</span> String string)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;试图构建一个RealData...&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">FutureData</span> <span class="variable">futureData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureData</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// RealData的构建很慢，所以放在单独的线程中运行</span></span><br><span class="line">            <span class="type">RealData</span> <span class="variable">realData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealData</span>(string);</span><br><span class="line">            futureData.setRealData(realData);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;立即返回futureData&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> futureData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> Client.request(<span class="string">&quot;真实的结果&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;后台已经开始异步处理数据了，这个时候干点什么好呢，不如果傻傻的等2s钟吧ʅ（´◔౪◔）ʃ&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;查看真实数据返回（如果还没有返回堵塞等待）= &quot;</span> + data.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的注释已经讲得比较清楚了，要理解Future的核心就在于创建了一个新的线程来帮助我们去执行一些比较耗时的操作，此线程在执行的操作完成之后，此时可以分为两种情况：</p><ol><li>主线程阻塞在了该方法的调用上，那么就主动提醒主线程操作已经执行完成，此时主线程可以继续向下执行；</li><li>主线程在执行其它的操作，当主线程想要查看这个操作的执行结果的时候，如果该操作还没结束，那么主线程就会阻塞，变成情况1；如果此时异步线程的操作已经结束了，那么主线程就直接返回结果，操作结束，主线程继续向下执行；</li></ol><p>示例代码我在GitHub上面也放了一份，可能查阅起来更清晰一点，地址在<a target="_blank" rel="noopener" href="https://github.com/RitterHou/java-future">这里</a>。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="Java中的Future模式">https://www.nosuchfield.com/2017/03/22/Future-mode-in-Java/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>