<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>二叉堆的概念与实现 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="数据结构"><meta name="description" content="&lt;p&gt;堆的一个经典的实现是完全二叉树(complete binary tree)，这样实现的堆称为二叉堆(binary heap)。数据结构中的堆和Java或者C++中的堆没有任何关系，它们是两个完全不同的概念。数据结构中的堆拥有如下两个性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意节点小于（或大于）它的所有后代，最小元（或最大元）在堆的根上；&lt;/li&gt;
&lt;li&gt;堆是一颗完全二叉树。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为二叉堆是一棵完全二叉树，所以和以前使用链表来构建树结构不一样，我们使用数组来构建这棵完全二叉树。数组和完全二叉树的对应关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/20170228/20150814174525425&#34; alt=&#34;数组和完全二叉树的对应关系&#34;&gt;&lt;/p&gt;
&lt;p&gt;从上图我们可以总结出完全二叉树的数组实现方案中父子节点的关系，假设某个节点的下标为i，则其：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左子节点的下标为2i；&lt;/li&gt;
&lt;li&gt;右子节点的下标为2i + 1；&lt;/li&gt;
&lt;li&gt;父节点的下标为i &amp;#x2F; 2；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假设我们使用"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">二叉堆的概念与实现</h1></div><div class="post-meta"><span class="post-time">2017-02-28</span></div><div class="post-content"><p>堆的一个经典的实现是完全二叉树(complete binary tree)，这样实现的堆称为二叉堆(binary heap)。数据结构中的堆和Java或者C++中的堆没有任何关系，它们是两个完全不同的概念。数据结构中的堆拥有如下两个性质：</p><ul><li>任意节点小于（或大于）它的所有后代，最小元（或最大元）在堆的根上；</li><li>堆是一颗完全二叉树。</li></ul><p>因为二叉堆是一棵完全二叉树，所以和以前使用链表来构建树结构不一样，我们使用数组来构建这棵完全二叉树。数组和完全二叉树的对应关系如下图所示：</p><p><img src="/images/20170228/20150814174525425" alt="数组和完全二叉树的对应关系"></p><p>从上图我们可以总结出完全二叉树的数组实现方案中父子节点的关系，假设某个节点的下标为i，则其：</p><ul><li>左子节点的下标为2i；</li><li>右子节点的下标为2i + 1；</li><li>父节点的下标为i &#x2F; 2；</li></ul><p>假设我们使用的是最小元在顶端的二叉堆，那么它的插入和删除操作应该如下来进行：</p><ul><li>插入：把待插入的值放在二叉堆的底部，然后把该值和其父亲进行比较，如果小于父亲的值，则进行交换，知道符合规则位置；</li><li>删除：删除二叉堆顶端的值，然后把二叉堆的最后一个值放在顶端，之后和其子节点进行比较，如果该节点比两个子节点中小的那一个大，则和该子节点交换，直到该节点比任一子节点都小、或者该节点成为叶节点。</li></ul><p>基本概念讲述完毕，下面我看一个Java实现的二叉堆，代码中实现了插入与删除的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryHeap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] heap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryHeap</span><span class="params">()</span> &#123;</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> heap.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] newHeap = <span class="keyword">new</span> <span class="title class_">int</span>[length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(heap, <span class="number">0</span>, newHeap, <span class="number">0</span>, length);</span><br><span class="line">        newHeap[length] = num;</span><br><span class="line">        insertFix(newHeap, length);</span><br><span class="line"></span><br><span class="line">        heap = newHeap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertFix</span><span class="params">(<span class="type">int</span>[] newHeap, <span class="type">int</span> last)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newHeap.length == <span class="number">1</span> || last == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parentIndex</span> <span class="operator">=</span> (last - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (newHeap[last] &lt; newHeap[parentIndex]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> newHeap[last];</span><br><span class="line">            newHeap[last] = newHeap[parentIndex];</span><br><span class="line">            newHeap[parentIndex] = temp;</span><br><span class="line">            insertFix(newHeap, parentIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">removeItem</span> <span class="operator">=</span> heap[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> heap.length;</span><br><span class="line">        <span class="type">int</span>[] newHeap = <span class="keyword">new</span> <span class="title class_">int</span>[length - <span class="number">1</span>];</span><br><span class="line">        newHeap[<span class="number">0</span>] = heap[length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            newHeap[i] = heap[i];</span><br><span class="line">        &#125;</span><br><span class="line">        removeFix(newHeap, <span class="number">0</span>);</span><br><span class="line">        heap = newHeap;</span><br><span class="line">        <span class="keyword">return</span> removeItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeFix</span><span class="params">(<span class="type">int</span>[] newHeap, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> <span class="number">2</span> * (first + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> <span class="number">2</span> * (first + <span class="number">1</span>) + <span class="number">1</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIndex &gt;= newHeap.length || rightIndex &gt;= newHeap.length)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> sonIndex;</span><br><span class="line">        <span class="keyword">if</span> (newHeap[leftIndex] &lt; newHeap[rightIndex])</span><br><span class="line">            sonIndex = leftIndex;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sonIndex = rightIndex;</span><br><span class="line">        <span class="keyword">if</span> (newHeap[first] &gt; newHeap[sonIndex]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> newHeap[first];</span><br><span class="line">            newHeap[first] = newHeap[sonIndex];</span><br><span class="line">            newHeap[sonIndex] = temp;</span><br><span class="line">            removeFix(newHeap, sonIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BinaryHeap [heap=&quot;</span> + Arrays.toString(heap) + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BinaryHeap</span> <span class="variable">binaryHeap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryHeap</span>();</span><br><span class="line">        binaryHeap.insert(<span class="number">1</span>);</span><br><span class="line">        binaryHeap.insert(<span class="number">2</span>);</span><br><span class="line">        System.out.println(binaryHeap.removeMin());</span><br><span class="line">        binaryHeap.insert(<span class="number">3</span>);</span><br><span class="line">        binaryHeap.insert(<span class="number">4</span>);</span><br><span class="line">        binaryHeap.insert(<span class="number">0</span>);</span><br><span class="line">        System.out.println(binaryHeap.removeMin());</span><br><span class="line">        System.out.println(binaryHeap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码本身比较简单，就不多说了，应该很容易就可以看懂。</p><p>参考：</p><ul><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/vamei/archive/2013/03/20/2966612.html">http://www.cnblogs.com/vamei/archive/2013/03/20/2966612.html</a></li><li><a target="_blank" rel="noopener" href="http://vickyqi.com/2015/08/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F/">http://vickyqi.com/2015/08/14/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%A0%86%E6%8E%92%E5%BA%8F/</a></li></ul></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="二叉堆的概念与实现">https://www.nosuchfield.com/2017/02/28/The-concept-and-realization-of-binary-heap/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>