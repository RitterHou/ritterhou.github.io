<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>async and await - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="JavaScript"><meta name="description" content="&lt;p&gt;&lt;em&gt;为了帮助你了解一下历史的进程，我画了如下图来解释我们为啥要async和await&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/20170916/20170917011621.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;简介&#34;&gt;&lt;a href=&#34;#简介&#34; class=&#34;headerlink&#34; title=&#34;简介&#34;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;async和await是为了简化Promise模式而被提出来的一种解决方案，所以为了学习async和await我们需要先明白Promise模式是啥。&lt;/p&gt;
&lt;p&gt;Promise模式的提出是为了替代JS中本身的回调语法，那么为啥要替代回调语法呢？我们知道，JS一般的实现都是单线程的，所以我们都使用回调函数来进行操作的同步。但是，回调函数写起来实在是太丑了，一段使用回调函数的代码可能是这样的（出自&lt;a href=&#34;http://callbackhell.com/&#34;&gt;http://callbackhell.com/&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/20170916/20170916235214.png&#34;"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">async and await</h1></div><div class="post-meta"><span class="post-time">2017-09-16</span></div><div class="post-content"><p><em>为了帮助你了解一下历史的进程，我画了如下图来解释我们为啥要async和await</em></p><p><img src="/images/20170916/20170917011621.png"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>async和await是为了简化Promise模式而被提出来的一种解决方案，所以为了学习async和await我们需要先明白Promise模式是啥。</p><p>Promise模式的提出是为了替代JS中本身的回调语法，那么为啥要替代回调语法呢？我们知道，JS一般的实现都是单线程的，所以我们都使用回调函数来进行操作的同步。但是，回调函数写起来实在是太丑了，一段使用回调函数的代码可能是这样的（出自<a target="_blank" rel="noopener" href="http://callbackhell.com/">http://callbackhell.com/</a>）：</p><p><img src="/images/20170916/20170916235214.png"></p><p>因为写起来太难看了，而且理解起来也很不方便，所以人们就开始想办法解决回调函数的问题。此时，Promise模式被提出来了，要知道Promise模式是怎么替代回调函数的，参考如下代码：</p><p>最基本的回调函数方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;input.txt&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;read data:&quot;</span>, data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>改写为Promise模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="keyword">function</span> (<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个Promise对象</span></span><br><span class="line">    <span class="comment">// 参数是一个方法，方法需要两个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(file, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err) <span class="comment">// 错误时执行reject方法</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>(data) <span class="comment">// 执行resolve方法</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Promise对象并且执行then方法</span></span><br><span class="line"><span class="comment">// then方法需要两个方法作为参数</span></span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;input.txt&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123; <span class="comment">// resolve 方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise read data:&quot;</span>, data.<span class="title function_">toString</span>())</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="comment">// reject 方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Promise模式"><a href="#Promise模式" class="headerlink" title="Promise模式"></a>Promise模式</h3><p>Promise类在nodejs中已经为我们构建好了（主流浏览器应该也都实现了这个类），所以我们可以直接使用。Promise的构造方法入参是一个方法，这个方法传入两个参数：resolve和reject。根据约定，当程序执行正常，方法resolve被执行；当程序出现异常，方法reject被执行。方法的执行条件已经定义完毕，下面就是方法体的定义了。方法<code>readFile(&#39;input.txt&#39;)</code>返回一个Promise对象，我们调用其 <code>then</code> 方法，这个方法传入两个方法。根据约定，第一个方法是为resolve方法的方法体，第二个方法是为reject方法的方法体。</p><p>也就是说，<code>then</code> 方法中的两个参数分别就是和Promise中传入的方法的两个参数相对应的。上面的resolve方法执行了，执行的就是then方法中的resolve方法方法体（参数也被正确的传递）；上面的reject执行了，执行的就是下面reject方法方法体。</p><h3 id="async-and-await"><a href="#async-and-await" class="headerlink" title="async and await"></a>async and await</h3><p>我们发现，Promise虽然在执行时避免了回调地狱，但是写这个 <code>then</code> 方法还是挺丑的，我们想要去掉这个 <code>then</code>。因此，async和await就出现了，它们的目的是___当调用___Promise对象的方法时候，能够简化操作。我们还是使用上面例子中的Promise对象的定义方式，而使用async和await来替代之前的Promise方法的执行方式，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="keyword">function</span> (<span class="params">file</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义一个Promise对象</span></span><br><span class="line">    <span class="comment">// 参数是一个方法，方法需要两个参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span> (<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(file, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(err) <span class="comment">// 错误时执行reject方法</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">resolve</span>(data) <span class="comment">// 执行resolve方法</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">test</span> = <span class="keyword">async</span> (<span class="params">file</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> data = <span class="keyword">await</span> <span class="title function_">readFile</span>(file) <span class="comment">// 这里把resolve的入参返回给data</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async and await:&#x27;</span>, data.<span class="title function_">toString</span>())</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;input.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们定义了一个async方法，在方法内使用await关键字修饰了一个Promise对象，这个修饰符将会<strong>把resolve对象执行时的入参返回</strong>，我们用data变量接受这个参数。仔细想想，我们的核心目的不就是接受到resolve方法和reject方法的参数吗？因为方法体其实都是我们自己定义的，如此一来拿到了resolve方法的入参，我们就可以用这个参数执行我们想要的操作了；同样的，根据约定，在async方法中reject方法一旦执行就会触发异常，所以我们用 try catch 包裹了代码快，catch的参数就是reject方法执行时候的入参。</p><p>仔细观察上面的代码，这样一来代码就非常的整洁且容易理解了。虽然我们增加了一个Promise对象定义的操作，但这个增加是值得的，因为我们大大的提高了代码的可读性。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="async and await">https://www.nosuchfield.com/2017/09/16/async-and-await/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>