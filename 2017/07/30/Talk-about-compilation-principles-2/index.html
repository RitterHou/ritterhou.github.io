<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>聊聊编译原理（二） - 语法分析 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="编译原理"><meta name="description" content="&lt;p&gt;在&lt;a href=&#34;/2017/07/16/Talk-about-compilation-principles-1/&#34;&gt;聊聊编译原理（一）&lt;/a&gt;中，我们详细的介绍了编译器工作流程中的第一个步骤：词法分析。在这篇文章中，我们开始学习编译过程中的第二个重要步骤：语法分析。&lt;/p&gt;
&lt;h1 id=&#34;语法分析&#34;&gt;&lt;a href=&#34;#语法分析&#34; class=&#34;headerlink&#34; title=&#34;语法分析&#34;&gt;&lt;/a&gt;语法分析&lt;/h1&gt;&lt;p&gt;如果把词法分析看作为字母组合成单词的过程，那么语法分析就是一个把单词组合成句子的过程。正如在词法分析中使用正则表达式来描述词法的规则一样，我们在语法分析中使用一种比RE表达能力更强的工具——上下文无关文法，来描述语言的语法规则。我们可以把某一种语言看成无数个符合语法规则的句子的集合，根据给定的上下文无关文法我们可以判断某一个Token串是否符合某个语法规则；如果符合，那么我们可以把此文法和对应输入的Token串组合起来生成一个句子。整个流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/images/20170730/20170808130605.p"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">聊聊编译原理（二） - 语法分析</h1></div><div class="post-meta"><span class="post-time">2017-07-30</span></div><div class="post-content"><p>在<a href="/2017/07/16/Talk-about-compilation-principles-1/">聊聊编译原理（一）</a>中，我们详细的介绍了编译器工作流程中的第一个步骤：词法分析。在这篇文章中，我们开始学习编译过程中的第二个重要步骤：语法分析。</p><h1 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h1><p>如果把词法分析看作为字母组合成单词的过程，那么语法分析就是一个把单词组合成句子的过程。正如在词法分析中使用正则表达式来描述词法的规则一样，我们在语法分析中使用一种比RE表达能力更强的工具——上下文无关文法，来描述语言的语法规则。我们可以把某一种语言看成无数个符合语法规则的句子的集合，根据给定的上下文无关文法我们可以判断某一个Token串是否符合某个语法规则；如果符合，那么我们可以把此文法和对应输入的Token串组合起来生成一个句子。整个流程如下图所示：</p><p><img src="/images/20170730/20170808130605.png"></p><h3 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h3><p>上下文无关文法（context-free grammar, CFG），是一种用来对某种语言进行形式化的、精确的描述的工具。有了这个工具，我们就可以很方便的定义一种语言的语法了。CFG是一个四元组（N, T, P, S），下面我们看一下CFG的组成：</p><ul><li>N是非终结符的集合；</li><li>T是终结符的集合；</li><li>P是一条产生式规则；</li><li>S是（唯一的）开始符号；</li></ul><p>这样描述不免抽象，下面我们来看一个例子。<em>（除了下面的这种描述语法，你可能还看过其它的描述CFG的语法，其中比较有名的是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F">巴科斯范式</a>，它们的本质其实是一样的，都是对CFG的四元组的描述。）</em></p><pre><code>S –&gt; AB
A –&gt; aA | ε
B –&gt; b | bB
</code></pre><p>其中S A B就是非终结符，代表可以继续扩展或产生的符号；a b ε是终结符，表示其无法再产生新的符号了，其中ε表示一个空句子；上面的每一行就是一个产生式规则，代表了一种非终结符的转移方式；而S就是开始符号。</p><p>只有终结符的符号串称为 句子（sentence）。经过观察可知，这个语法所能推导出的所有句子的集合为：</p><pre><code>A : &#123; ε, a, aa, aaa, ... &#125;
B : &#123; b, bb, bbb, ... &#125;
S : &#123; b, bb, bbb, ..., ab, abb, ..., aab, aabb, ... &#125;
</code></pre><h3 id="分析方法简介"><a href="#分析方法简介" class="headerlink" title="分析方法简介"></a>分析方法简介</h3><p>给定文法G和句子s，回答s是否能够从G推导出来，这是在<strong>语法分析器内部</strong>所要实现的功能，这里我们开始讨论语法分析器内部要如何才能实现这一功能。</p><p><img src="/images/20170730/20170808160606.png"></p><p>在这里我们讨论的是语法分析器内部为了对G和s进行判断所实现或者使用到的数据结构与算法，下面介绍几种常用的算法：</p><ul><li><a href="/2017/07/30/Talk-about-compilation-principles-2/#1-__u81EA_u9876_u5411_u4E0B_u5206_u6790_u7B97_u6CD5">自顶向下分析算法</a></li><li><a href="/2017/07/30/Talk-about-compilation-principles-2/#2-__u9012_u5F52_u4E0B_u964D_u5206_u6790_u7B97_u6CD5">递归下降分析算法</a></li><li><a href="/2017/07/30/Talk-about-compilation-principles-2/#3-_LL_281_29_u5206_u6790_u7B97_u6CD5">LL(1)分析算法</a></li><li><a href="/2017/07/30/Talk-about-compilation-principles-2/#4-__u81EA_u5E95_u5411_u4E0A_u5206_u6790_u7B97_u6CD5">自底向上分析算法</a></li></ul><h4 id="1-自顶向下分析算法"><a href="#1-自顶向下分析算法" class="headerlink" title="1. 自顶向下分析算法"></a>1. 自顶向下分析算法</h4><p>自顶向下分析就是从起始符号开始，不断的挑选出合适的产生式，将中间句子中的非终结符的展开，最终展开到给定的句子。它的核心思想在于，当我们从左往右匹配这个句子的时候，每匹配一次需要从上往下遍历一次这个CFG从而找到合适的产生式，所以被称为自顶向下分析算法。我个人认为这种方法有点类似于“穷举法”（试错法），因为它的本质是不断的使用产生式规则来发现符合这个句子的语法。</p><p>不过自顶向下分析并不是无脑穷举的，当发现某一个产生式产生的终结符和句子的当前结构根本不匹配时，我们就不会再向下继续分析了，因为不管怎么分析也无法得到正确的结果。此时我们就需要回到最近的一次有效的规则，然后继续使用新的规则向后执行，这种行为称为“回溯”。</p><p>例如，我们同样取上面的aab句子，接下来我们用自顶向下分析算法来判断下面的CFG能否推导出句子aab。</p><pre><code>S –&gt; AB
A –&gt; aA | ε
B –&gt; b | bB
</code></pre><p>第一步：从起始状态S开始，产生式只有一个</p><table><thead><tr><th align="left">中间状态</th><th align="left">使用的产生式</th></tr></thead><tbody><tr><td align="left">S</td><td align="left">S -&gt; AB</td></tr><tr><td align="left">AB</td><td align="left"></td></tr></tbody></table><p>第二步：我们开始对A进行展开，可是A的展开式有两个。我们分析发现，句子aab的开头必须是a，所以ε这种展开形式就被剔除了，我们选用aA这个产生式进行展开</p><table><thead><tr><th align="left">中间状态</th><th align="left">使用的产生式</th></tr></thead><tbody><tr><td align="left">AB</td><td align="left">A -&gt; aA</td></tr><tr><td align="left">aAB</td><td align="left"></td></tr></tbody></table><p>第三步：我们继续对A进行展开，此次展开和第二步使用同样的产生式</p><table><thead><tr><th align="left">中间状态</th><th align="left">使用的产生式</th></tr></thead><tbody><tr><td align="left">aAB</td><td align="left">A -&gt; aA</td></tr><tr><td align="left">aaAB</td><td align="left"></td></tr></tbody></table><p>第四步：此时我们需要继续对A进行展开，此时我们分析发现，这里A必须使用A -&gt; ε</p><table><thead><tr><th align="left">中间状态</th><th align="left">使用的产生式</th></tr></thead><tbody><tr><td align="left">aaAB</td><td align="left">A -&gt; ε</td></tr><tr><td align="left">aaB</td><td align="left"></td></tr></tbody></table><p>最后，使用B -&gt; b即可构建句子aab，说明句子aab是符合该文法的。</p><table><thead><tr><th align="left">中间状态</th><th align="left">使用的产生式</th></tr></thead><tbody><tr><td align="left">aaB</td><td align="left">B -&gt; b</td></tr><tr><td align="left">aab</td><td align="left"></td></tr></tbody></table><p>我们可以把自顶向下分析算法总结如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tokens = []</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">stack = [S] <span class="comment"># S 是起始符号</span></span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> stack[top] <span class="keyword">is</span> terminal t:</span><br><span class="line">        <span class="keyword">if</span> t == tokens[i]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            pop()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            backtrace()  <span class="comment"># 回溯</span></span><br><span class="line">    <span class="keyword">else</span> stack[top] <span class="keyword">is</span> nonterminal T:</span><br><span class="line">        pop()</span><br><span class="line">        push(the <span class="built_in">next</span> right hand of T)</span><br></pre></td></tr></table></figure><h4 id="2-递归下降分析算法"><a href="#2-递归下降分析算法" class="headerlink" title="2. 递归下降分析算法"></a>2. 递归下降分析算法</h4><p>递归下降分析算法本质也是一种自顶向下分析算法，其基本思想如下：</p><ul><li>对每一个非终结符构造一个分析函数</li><li>用前看符号指导产生式规则的选择</li></ul><p>递归下降分析算法使用“分治法”来提高分析的效率，对于每一个产生式规则，都应该定义一个自己函数。因为在上下文无关文法中，终结符不可能出现在产生式的左边（可以在产生式左边出现终结符的文法叫做上下文有关文法），上下文无关文法中所有的产生式左边只有一个非终结符。所以我们在调用产生式规则的函数后，就分为两种情况：</p><ol><li>遇到终结符，因为终结符本质上是token，所以直接把这个终结符和句子中对应位置的token进行比较，判断是否符合即可；符合就继续，不符合就返回</li><li>遇到非终结符，此时只需要调用这个非终结符对应的函数即可。在这里函数可能会递归的调用，这也是算法名称的来源。</li></ol><p>简单来说，就是遇到非终结符就调用函数，遇到终结符就比较；例如，同样对于文法G：</p><pre><code>S –&gt; AB
A –&gt; aA | ε
B –&gt; b | bB
</code></pre><p>我们通过递归下降分析来判断aab是否符合该文法，算法如下（_parser.py_）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">EOF = <span class="string">&#x27;\n&#x27;</span>  <span class="comment"># 用换行符作为EOF符号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parser</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, sentence</span>):</span><br><span class="line">        self.sentence = sentence</span><br><span class="line">        self.current_pos = <span class="number">0</span>  <span class="comment"># 当前的token下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_S</span>(<span class="params">self</span>):</span><br><span class="line">        self.parse_A()</span><br><span class="line">        self.parse_B()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_A</span>(<span class="params">self</span>):</span><br><span class="line">        token = self.get_next_token()   <span class="comment"># 从句子中取出一个Token</span></span><br><span class="line">        <span class="keyword">if</span> token == <span class="string">&#x27;a&#x27;</span>:                <span class="comment"># 和CFG中的Token进行比较</span></span><br><span class="line">            self.parse_A()              <span class="comment"># 执行非终结符所对应的函数</span></span><br><span class="line">        <span class="keyword">elif</span> token != <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            self.put_token_back()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_B</span>(<span class="params">self</span>):</span><br><span class="line">        token = self.get_next_token()</span><br><span class="line">        <span class="keyword">if</span> token == <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            token = self.get_next_token()</span><br><span class="line">            <span class="keyword">if</span> token == EOF:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.parse_B()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;非终结符 B 解析异常&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_next_token</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current_pos == <span class="built_in">len</span>(self.sentence):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;数组越界&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        next_token = self.sentence[self.current_pos]</span><br><span class="line">        self.current_pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> next_token</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">put_token_back</span>(<span class="params">self</span>):</span><br><span class="line">        self.current_pos -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sentence = <span class="string">&#x27;aab&#x27;</span></span><br><span class="line">    parser = Parser(sentence + EOF)</span><br><span class="line">    parser.parse_S()</span><br></pre></td></tr></table></figure><p>以上代码只要能正常运行结束而不出现异常，就说明句子’aab’符合此文法。</p><p>让我们来分析一下代码中的逻辑：</p><ul><li>因为S的产生式是非终结符A和B，所以只需要调用A和B的函数即可</li><li>A产生式涉及到了终结符，所以我们需要先从句子取一个Token，然后根据Token的值进行逻辑判断：如果token是a，则获取到非终结符A，继续递归执行A的函数；如果不是a，那么不做任何操作，还要把当前的token放回到句子中</li><li>B产生式第一个token是一样的，无法进行区分，我们可以用第二个token判断：如果已经到了句子结尾（也就是说此token不是b），不做任何操作；如果还有token，则继续执行</li></ul><h4 id="3-LL-1-分析算法"><a href="#3-LL-1-分析算法" class="headerlink" title="3. LL(1)分析算法"></a>3. LL(1)分析算法</h4><p>LL(1)算法也是一个自顶向下的分析算法，它的定义为：从左（L）向右读入一个程序，最左（L）推导，采用一个（1）前看符号。LL(1)算法和自顶向下分析算法本质上是一致的，它们的区别就在于LL(1)算法使用了一种称为<em><strong>分析表</strong></em>的工具来避免了<strong>回溯</strong>操作，提高了效率。在现实中，我们可以根据某种LL(1)分析器来生成分析表，之后根据分析表来进行语法分析操作，我们可以认为这种方法是一种半自动的语法分析方法。LL(1)的总体工作方式如下所示：</p><p><img src="/images/20170730/20170814225920.png"></p><p>例如对于文法（注意我们这里给每个产生式加上了序号，方便区分）</p><ol><li>S → F</li><li>S → ( S + F )</li><li>F → 1</li></ol><p>之后我们根据这个文法来构建一张分析表_（分析表的构建方式会在下面讲到，这里先不做讨论）_如下：</p><p>|N\T|（|）|1|+|$|<br>|:–:|:–:|:–:|:–:|<br>|S|2|-|1|-|-|<br>|F|-|-|3|-|-|</p><p>有了上面这个分析表之后，我们开始从左向右对句子（例如：<code>( 1 + 1 )</code>）进行分析，它的分析流程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">tokens = []</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">stack = [S] <span class="comment"># S 是起始符号</span></span><br><span class="line"><span class="keyword">while</span> stack <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> stack[top] <span class="keyword">is</span> terminal t:</span><br><span class="line">        <span class="keyword">if</span> t == tokens[i]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            pop()</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           error()</span><br><span class="line">    <span class="keyword">else</span> stack[top] <span class="keyword">is</span> nonterminal T:</span><br><span class="line">        pop()</span><br><span class="line">        push(the correct right hand of T)</span><br></pre></td></tr></table></figure><p>仔细观察我们就知道这里的流程和自顶向下分析算法的流程的区别就在于13行和第10行，在第13行我们如果能够一次就取到正确的产生式规则而不是使用穷举去猜测，那么算法效率自然可以提高。关键就在于我们要怎么样才能一次性取到正确的产生式，<em><strong>分析表</strong></em>能够帮助我们完成这样的操作。我们详细的执行一次语法分析过程来看分析表是怎么工作的：</p><ol><li>最开始栈中的元素为：S；执行else中的代码，把S pop出去。此时第一个token为 <code>(</code>，查阅分析表可得我们应该执行产生式2，所以被push进行stack的值为 ( S + F )</li><li>此时栈为： ( S + F )；栈顶元素<code>(</code>等于当前的token，<code>(</code> 被pop，token向后移一位</li><li>栈：S + F)；当前token为1，栈顶元素S，查分析表可得产生式1，栈变为 F + F)</li><li>栈：F + F)；栈顶F，token 1</li><li>栈：1 + F)；栈顶1，token 1</li><li>栈：+ F)；栈顶+,token +</li><li>栈：F)；栈顶F，token 1</li><li>栈：1)；栈顶1，token 1</li><li>栈：)；栈顶 )，token )</li><li>栈：None；token为空。流程结束</li></ol><p>因为以上流程并未报错，所以我们可以推出<code>(1 + 1)</code>可以被此文法描述。至此我们了解到分析表的强大，它避免了回溯操作，大量降低操作时间，提高解析速度。那么问题来了，如此有用的分析表是怎么被构造出来？_（从上面的工作图我们已经知道了分析表可以通过手动和自动两种方式来创建，我们这里的算法原理讲的是LL(1)的手动生成分析表的方式，自动方式读者可以查阅相关资料和软件。）_我们需要先了解几个在构造分析表的时候所要用的集合：first集和follow集，以及nullable集合。</p><ul><li>nullable集合：<ol><li>产生式 x -&gt; 空，则X属于nullable集合；</li><li>x -&gt; Y1…Yn，Y1到Yn都是非终结符且都属于nullable集合，则 X 属于 nullable 集合；</li></ol></li></ul><p>nullable集合的计算方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nullable = &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> nullable <span class="keyword">is</span> changing:</span><br><span class="line">    <span class="keyword">for</span> p: x - &gt; β <span class="keyword">in</span> productions:  <span class="comment"># 遍历所有的产生式</span></span><br><span class="line">        <span class="keyword">if</span> β <span class="keyword">is</span> 空：</span><br><span class="line">            nulable.append(x)</span><br><span class="line">        <span class="keyword">if</span> β <span class="keyword">is</span> Y1..Yn:</span><br><span class="line">            <span class="keyword">if</span> Y1 <span class="keyword">in</span> nullable <span class="keyword">and</span> ... <span class="keyword">and</span> Yn <span class="keyword">in</span> nullable:</span><br><span class="line">                nulable.append(x)</span><br></pre></td></tr></table></figure><ul><li>first集合：对于产生式 x -&gt; β1…βn，<ol><li>如果β1是终结符：first(x) &#x3D; {β1}</li><li>β1是非终结符，first(x) U&#x3D; first(β1)；<ul><li>如果β1属于nullable，first(x) U&#x3D; first(β2)；</li><li>如果β2属于nullable，first(x) U&#x3D; first(β2)；</li><li>…</li></ul></li></ol></li></ul><p>fisrt集合的计算方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> nonterminal n <span class="keyword">in</span> all_nontermials:</span><br><span class="line">    fisrt(n) = &#123;&#125;  <span class="comment"># 初始化所有的first集</span></span><br><span class="line"><span class="keyword">while</span> some <span class="built_in">set</span> <span class="keyword">is</span> changing:  <span class="comment"># 有集合发生了变化</span></span><br><span class="line">    <span class="keyword">for</span> p: x - &gt; β<span class="number">1.</span>.βn <span class="keyword">in</span> productions:  <span class="comment"># 遍历所有的产生式</span></span><br><span class="line">        <span class="keyword">for</span> βi <span class="keyword">in</span> β<span class="number">1</span> to βn:</span><br><span class="line">            <span class="keyword">if</span> βi <span class="keyword">is</span> terminal:</span><br><span class="line">                first(x).append(βi)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> βi <span class="keyword">is</span> nonterminal:</span><br><span class="line">                first(x).append(first(βi))</span><br><span class="line">                <span class="keyword">if</span> βi <span class="keyword">not</span> <span class="keyword">in</span> nullable:  <span class="comment"># 如果βi属于nullable，则还要继续向下计算</span></span><br><span class="line">                    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><ul><li>follow集合：follow（后继）字符集合可以看成所有<strong>可以</strong>合法的站在此非终结符后面的终结符（可能包括结束符 $ 、但不包括 ε ）的集合。</li></ul><p>follow集合的计算方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> nonterminal n <span class="keyword">in</span> all_nontermials:</span><br><span class="line">    fisrt(n) = &#123;&#125;  <span class="comment"># 初始化所有的first集</span></span><br><span class="line"><span class="keyword">while</span> some <span class="built_in">set</span> <span class="keyword">is</span> changing:  <span class="comment"># 有集合发生了变化</span></span><br><span class="line">    <span class="keyword">for</span> p: x - &gt; β<span class="number">1.</span>.βn <span class="keyword">in</span> productions:  <span class="comment"># 遍历所有的产生式</span></span><br><span class="line">        tmp = follow(x)  <span class="comment"># follow表示跟在x后面的符号集合</span></span><br><span class="line">        <span class="keyword">for</span> βi <span class="keyword">in</span> βn to β<span class="number">1</span>:  <span class="comment"># 逆序</span></span><br><span class="line">            <span class="comment"># 下面的所有tmp都代表的是后一个元素的first集合</span></span><br><span class="line">            <span class="keyword">if</span> βi <span class="keyword">is</span> terminal:</span><br><span class="line">                tmp = &#123;βi&#125;  <span class="comment"># 作为一个新的follow符</span></span><br><span class="line">            <span class="keyword">elif</span> βi <span class="keyword">is</span> nonterminal:</span><br><span class="line">                follow(βi).append(tmp)  <span class="comment"># 把此follow符加入到非终结符的follow集合中</span></span><br><span class="line">                <span class="keyword">if</span> βi <span class="keyword">not</span> <span class="keyword">in</span> nullable:</span><br><span class="line">                    tmp = first(βi)  <span class="comment"># 不为空，则前面一个非终结符的follow集合应为此非终结符的first集合</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.append(first(βi))  <span class="comment"># first集合为空，无法独立存在了，只能把加上去了</span></span><br></pre></td></tr></table></figure><p>follow集合存在意义在于如果某个产生式右部的非终结符的first集合全都是 ε，则此时取follow集。</p><p>我们至此已经可以获取到nullable集、first集和follow集，现在我们可以根据这几个集合来构建first_s集，然后我们可以把first_s集合看作是对每一条产生式的计算规则。有了first_s集，之后再和产生式结合就可以创建分析表了。first_s集的生成方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> productions:</span><br><span class="line">    first_s(p) = &#123;&#125;  <span class="comment"># 集合初始化为空</span></span><br><span class="line"><span class="comment"># 获取一个产生式的 p 的first_s集</span></span><br><span class="line">get_first_s(p: N -&gt; β<span class="number">1.</span>.βn):</span><br><span class="line">    <span class="keyword">for</span> βi <span class="keyword">in</span> β<span class="number">1</span> to βn:</span><br><span class="line">        <span class="keyword">if</span> βi <span class="keyword">is</span> terminal:</span><br><span class="line">            first_s(p).append(βi)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> βi <span class="keyword">is</span> nonterminal:  <span class="comment"># 非终结符</span></span><br><span class="line">            first_s(p).append(first(βi))</span><br><span class="line">                <span class="keyword">if</span> βi <span class="keyword">not</span> <span class="keyword">in</span> nullable:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">    first_s(p).append(follow(N)  <span class="comment"># 如果全是空，那么会运行到这里，此时把N的follow集加到first_s里面</span></span><br></pre></td></tr></table></figure><p>有了first_s集之后，我们就可以构造分析表了。我们把first_s集合与产生式结合起来，把first_s集合的值作为横坐标，非终结符作为纵坐标，产生式规则作为值，就可以创建出一张分析表了。这里说的创建分析表的方式不免有些抽象，下面我们借助一个例子来完整的看一下一个分析表是怎么被创建出来的。</p><p>我们还是使用上面的例子来进行说明，假设我们已经有了一个文法G：</p><ol><li>S → F</li><li>S → (S + F)</li><li>F → 1</li></ol><p>我们想要用此文法生成一个分析表。</p><p>首先我们生成nullable集合，根据上面的nullable集合的生成方式可知，此处的nullable集合为空集 {}。<br>first集合的计算过程参考上面的计算方式，计算结果如下：</p><pre><code>first(F): &#123; 1 &#125;
first(S): &#123; ( &#125; U &#123; 1 &#125; = &#123; (, 1 &#125;  # 取两个的并集
</code></pre><p>follow集合根据计算结果为：</p><pre><code>follow(S): &#123; +, ) &#125;
follow(F): &#123; ) &#125;
</code></pre><p>有了nullable，first和follow集合，我们可以计算出first_s集合，这里的序号和产生式中的序号是一一对应的：</p><pre><code>1.S -&gt; &#123; 1 &#125;
2.S -&gt; &#123; ( &#125;
3.F -&gt; &#123; 1 &#125;
</code></pre><p>接着我们用first_s集和产生式集合来构建分析表，构建方式很简单。横轴为终结符，纵轴为非终结符，找到对应的产生规则把序号填入表中即可：</p><table><thead><tr><th align="center">N\T</th><th align="center">(</th><th align="center">)</th><th align="center">+</th><th align="center">1</th></tr></thead><tbody><tr><td align="center">S</td><td align="center">2</td><td align="center">-</td><td align="center">-</td><td align="center">1</td></tr><tr><td align="center">F</td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">3</td></tr></tbody></table><p>对比可以发现，这里的分析表和我们上面用来进行句子识别的分析表是一样的，说明我们的构建是正确的。</p><p>小结：上面我们讲了LL(1)算法的主要内容，需要理解LL(1)算法其实就是对于每个非终结符，能够通过查阅分析表找到正确的产生式规则，这种类似于“偷看”的策略能够避免“回溯”操作，可以有效的提高语法分析的效率。</p><p>⚠&amp;nbsp;需要注意的是，LL(1)文法不能拥有左递归，否则会导致递归到死，所以如果使用LL(1)文法则需要 消除左递归。</p><h4 id="4-自底向上分析算法"><a href="#4-自底向上分析算法" class="headerlink" title="4. 自底向上分析算法"></a>4. 自底向上分析算法</h4><p>自底向上分析算法是语法分析的另一类重要算法，它包含了LR(0)算法、SLR算法和LR(1)算法。自底向上分析算法的主要方式是根据句子的Token，使用产生式来自右向左进行分析，即把右侧的内容“收缩”为左侧的非终结符，这种行为我们称为规约（reduce）。</p><p>由于精力有限（其实是懒），这里就不对自底向上分析算法做介绍了，想要了解的读者可以自行查阅相关的资料来进行学习。</p><h3 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h3><p>语法制导翻译（Syntax-directed translation，SDT），是在解析（parse）输入的Token时，给每一个产生式规则附加一个语义动作（一个代码片段），即把语法“翻译”成一串“动作”，故名“语法制导翻译”。</p><p>例如，我们可以在语法动作中加入生成抽象语法树的行为。</p><h3 id="分析树和抽象语法树"><a href="#分析树和抽象语法树" class="headerlink" title="分析树和抽象语法树"></a>分析树和抽象语法树</h3><p>语法分析不但要判断给定的句子是否符合语法结构，而且还要分析出该句子符合哪些结构，也就是说，要分析出这个句子是怎么从起始符号开始产生出来的，并根据产生过程生成语法树。例如，对于 “我吃饭” 这句话，单纯的知道这句话符合某一个CFG是没有意义的，只有我们知道了 主语、谓语和宾语 分别对应的是那个词，我们才能真正理解这句话的含义。</p><p><img src="/images/20170730/syntax_1.png"></p><p>以第一小节的CFG为例，我们要从它推导出句子aab，则推导方式如下：</p><p>S &#x3D;&gt; AB &#x3D;&gt; aAB &#x3D;&gt; aaAB &#x3D;&gt; aaB &#x3D;&gt; aab，这个推导过程可以用下面的（语法）分析树来表示：</p><p><img src="/images/20170730/20170808144640.png"></p><p>可以去掉此分析树中一些多余的节点，并进一步浓缩，得到抽象语法树（Abstract Syntax Tree, AST）：</p><p><img src="/images/20170730/20170808141619.png"></p><p>⚠&amp;nbsp;需要注意的是，CFG是可能存在二义性的（歧义），例如下面这个例子。</p><pre><code>E -&gt; num | E + E | E * E
</code></pre><p>上面这个CFG，对于句子 1 + 2 * 3，它可以生成以下两种AST：</p><p><img src="/images/20170730/20170808160502.png"></p><p>CFG的二义性将导致同一个程序有多个不同的含义，使得程序的运行结果不唯一。解决二义性的方法就是对文法进行重写，例如把上面的文法改写成如下形式即可。</p><pre><code>E -&gt; E + T | T
T -&gt; T * num | num
</code></pre><p>具体语法和抽象语法：</p><ul><li>具体语法是语法分析器使用的语法</li><li>抽象语法是用来表达语法结构的内部表示</li></ul><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a target="_blank" rel="noopener" href="http://pandolia.net/tinyc/ch9_context_free_grammar.html">http://pandolia.net/tinyc/ch9_context_free_grammar.html</a><br><a target="_blank" rel="noopener" href="http://pandolia.net/tinyc/ch10_top_down_parse.html">http://pandolia.net/tinyc/ch10_top_down_parse.html</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="聊聊编译原理（二） - 语法分析">https://www.nosuchfield.com/2017/07/30/Talk-about-compilation-principles-2/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>