<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>聊聊编译原理（一） - 词法分析 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="编译原理"><meta name="description" content="&lt;blockquote&gt;
&lt;p&gt;编译器（Compiler），是一种计算机程序，它会将用某种编程语言写成的源代码（原始语言），转换成另一种编程语言（目标语言）。—— 维基百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把实现编译器过程中所用到的策略与方法总结起来，这就是编译原理，其主要包含了编译器的构造与优化。&lt;/p&gt;
&lt;p&gt;一般来说编译器的内部包含了如下的工作步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;词法分析；&lt;/li&gt;
&lt;li&gt;语法分析；&lt;/li&gt;
&lt;li&gt;语义分析；&lt;/li&gt;
&lt;li&gt;生成中间表示（intermediate representation，IR）；&lt;/li&gt;
&lt;li&gt;代码生成；&lt;/li&gt;
&lt;li&gt;优化；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说到生成中间表示这过程中的操作被称为编译器的“前端”，而从IR到最终结果被称为编译器的“后端”。也就是说1 ~ 4步为编译器的前端，而5 ~ 6步为编译器的后端。IR的目的在于保证编译器的跨平台，对于不同的平台，它们的IR表示是一样的，区别只在于代码生成和优化阶段。有了IR，我们在不同平台上编译器的前端就可以复用了，只需要对应不同的平台开发其"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">聊聊编译原理（一） - 词法分析</h1></div><div class="post-meta"><span class="post-time">2017-07-16</span></div><div class="post-content"><blockquote><p>编译器（Compiler），是一种计算机程序，它会将用某种编程语言写成的源代码（原始语言），转换成另一种编程语言（目标语言）。—— 维基百科</p></blockquote><p>把实现编译器过程中所用到的策略与方法总结起来，这就是编译原理，其主要包含了编译器的构造与优化。</p><p>一般来说编译器的内部包含了如下的工作步骤：</p><ol><li>词法分析；</li><li>语法分析；</li><li>语义分析；</li><li>生成中间表示（intermediate representation，IR）；</li><li>代码生成；</li><li>优化；</li></ol><p>一般来说到生成中间表示这过程中的操作被称为编译器的“前端”，而从IR到最终结果被称为编译器的“后端”。也就是说1 ~ 4步为编译器的前端，而5 ~ 6步为编译器的后端。IR的目的在于保证编译器的跨平台，对于不同的平台，它们的IR表示是一样的，区别只在于代码生成和优化阶段。有了IR，我们在不同平台上编译器的前端就可以复用了，只需要对应不同的平台开发其对应的后端就可以了，减少了工作量。</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><p>词法分析是编译工作的第一步，它的主要工作是把输入的程序源代码字符流转化为记号（Token）流。例如，对于如下语句，在进行了词法分析操作之后，对应的会生成 <code>int</code>，<code>a</code>，<code>=</code>，<code>0</code>，<code>;</code>这几个记号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>一般来说词法分析的实现主要有两种方式：</p><ol><li>手工编码构造词法分析器，手动构造词法分析器的优点是方便对细节进行控制，缺点是比较复杂且容易出错；</li><li>使用词法分析器的生成器（例如：JavaCC, Yacc, Lex），词法分析器的生成器是一种根据给定的规则把输入构建成Token并输出的程序，其优点时使用简单；</li></ol><p>出于学习的目的，我们这里主要讨论手工构造词法分析器的方式；至于词法分析器的生成器的方式，你可以任选一个流行的生成器进行深入了解。</p><h3 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h3><p>词法分析阶段会用到以下几个数学工具：</p><ul><li>正则表达式（Regular Expression, RE）</li><li>确定性有限状态自动机（DFA）</li><li>非确定性有限状态自动机（NFA）</li></ul><p>手工构造词法分析器的步骤如下，我们通过RE来实现对Token的描述：</p><p><img src="/images/20170716/20170729145025.png"></p><p>下面我们按照此图中的顺序，了解一下在这几个步骤中所用到的算法以及它们的实现方式。</p><h3 id="1-Thompson算法"><a href="#1-Thompson算法" class="headerlink" title="1. Thompson算法"></a>1. Thompson算法</h3><p>我们已经知道一个RE可能会包含如下几种情况：</p><ul><li>ε：代表空；</li><li>c：代表一个输入字符；</li><li>e1 e1：两个re的连接关系；</li><li>e1|e2：两个re的选择关系；</li><li>e1*：闭包，代表一个re重复0次或多次</li></ul><p>例如，对于RE <code>a(b|c)*</code>，我们可以创建如下的NFA：</p><p><img src="/images/20170716/20170729151149.png"></p><p>我们发现，RE和NFA的对应关系还是很清晰的，事实上只需要一些简单的递归操作即可以实现从RE到NFA的转换。</p><h3 id="2-子集构造算法"><a href="#2-子集构造算法" class="headerlink" title="2. 子集构造算法"></a>2. 子集构造算法</h3><p>通过不断的构建一个个的状态集合，这些集合都是自动机的所有状态的子集，这就是子集构造算法名字的意义。这种转化算法的本质在于对于每一个状态集合，给该集合一个输入，会得到一个新的状态的集合，通过这种方式来把一个NFA转化为一个DFA。</p><p>例如下面这个NFA，我们可以先把它状态集合的转移情况列出来，并用一个二维表来表示：</p><p><img src="/images/20170716/20170729183541.png"></p><p>二维表表示集合间的转移关系：</p><p><img src="/images/20170716/20170729183928.png"></p><ul><li>表中的第一列表示不需要任何输入（即输入ε）进行状态转移；</li><li>第二列表示了在当前状态的集合下，对于每个状态输入a，之后把得到的状态组合起来作为一个新的集合；</li><li>第三列表示对所有状态输入b，得到最终的状态集合；</li></ul><p>上表是对所有的状态集进行a和b的输入操作，之后把新得到的状态集再次输入a和b进行转移得到新的状态集，如此反复输入并转移直到最终到达接受状态。</p><p>如果把上表的每个状态集合取个别名，例如1、2、3…，那么我们可以把上表改写成如下的形式，这样使得结构更加的清晰，不过集合和别名之间的对应关系需要被保存下来。</p><p><img src="/images/20170716/20170729184932.png"></p><p>之后，根据上表我们可以的得到这样的一个DFA。至此，NFA到DFA的转化结束。</p><p><img src="/images/20170716/20170729185220.png"></p><h3 id="3-Hopcroft算法"><a href="#3-Hopcroft算法" class="headerlink" title="3. Hopcroft算法"></a>3. Hopcroft算法</h3><p>Hopcroft算法是DFA到DFA的转化，其目的是减少DFA的状态和边，对DFA进行简化，这样可以使得后面的操作变得简单。</p><p>首先我们需要知道最小状态DFA所需要遵守的规则：</p><ol><li><p>没有多余状态；</p><ol><li>什么是多余状态？ 从这个状态没有通路到达终态：S1；从开始状态出发，任何输入串也不能到达的那个状态：S2</li><li>如何消除多余状态？ 删除<br><img src="/images/20170716/20170729234339.png"></li></ol></li><li><p>没有两个状态是互相等价；互相等价需满足下面两个条件：</p><ol><li>兼容性（一致性）条件——同是终态或同是非终态</li><li>传播性（蔓延性）条件——对于所有输入符号，状态s和状态t必须转换到等价的状态里</li></ol></li></ol><p>DFA最小化分为以下几步，它主要是根据上面的<strong>不可互相等价</strong>规则来进行操作的：</p><ol><li>把DFA拆分为非接受状态（N）和接受状态（A）这两个集合；</li><li>对于同样的输入，某个集合中的状态产生了不同的结果（这里的结果不同指的是转移状态所处的<strong>集合不同</strong>），那么根据结果集合的不同应该把这些状态从该集合拆分为新的集合；</li><li>反复进行第2步，直到不可再拆分，此时的集合就可以构成一个新的DFA；</li></ol><p>例如，对于如下的DFA，我们对其进行最小化操作。<br><img src="/images/20170716/20170730001138.png"></p><ol><li>我们根据N和A对其进行拆分，得到集合N {q0, q1, q2, q4}, A {q3, q5}</li><li>对于集合A，任何输入都不能对它们区分，则它们已不可拆分</li><li>对集合N，我们输入e，q0和q1转移到集合N，q2和q4转移到集合A，则集合N可以拆分为N1 {q0, q1}和 N2 {q2, q4}</li><li>集合N2只接受e且转移结果一致（都是转移到A），其不可再区分</li><li>集合N1输入e，q0转移到N1（因为它还是q0状态），q1转移到N2，则N1可以再被拆为{q0}和{q1}</li><li>所有的集合都不可再拆分，现有集合为 {q0}, {q1}, {q2, q4}, {q3, q5} 我们把这些集合生成一个新的DFA，这个新的DFA比初始的6个状态少了两个状态，结构变得简单了。</li></ol><p><img src="/images/20170716/20170730004221.png"></p><h3 id="4-DFA结构解析并生成词法分析器"><a href="#4-DFA结构解析并生成词法分析器" class="headerlink" title="4. DFA结构解析并生成词法分析器"></a>4. DFA结构解析并生成词法分析器</h3><p>在上面的我们已经生成了一个符合要求的DFA，现在我们把这个DFA作为输入读入到程序中，然后通过某种方式把这个DFA转化为某种程序易描述的数据结构（例如数组），之后程序利用该结构对输入的字符流（即某种语言的源代码）进行解析。</p><p>例如：利用二维数组对DFA结构进行描述，左侧表示当前状态，上方表示输入，框中表示转移结果<br><img src="/images/20170716/20170729193334.png"></p><p>从概念上来说，DFA实际上是一个有向图。我们可以通过转移表、跳转表等代码表示来实现对DFA的识别和Token的解析。</p><p>对于识别出来的Token，有些Token只有类型（例如：if），有些Token既有类型又有值（例如：101）。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a target="_blank" rel="noopener" href="http://blog.csdn.net/qq_23100787/article/details/50402643">【编译原理】:NFA转变为DFA的子集构造法</a></li></ol></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="聊聊编译原理（一） - 词法分析">https://www.nosuchfield.com/2017/07/16/Talk-about-compilation-principles-1/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" rel="tag">编译原理</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>