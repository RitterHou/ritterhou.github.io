<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>一个轻量级Web框架的实现 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="Java,框架,Web"><meta name="description" content="&lt;h3 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;自从1990年&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%92%82%E5%A7%86%C2%B7%E4%BC%AF%E7%BA%B3%E6%96%AF-%E6%9D%8E&#34;&gt;蒂莫西·约翰·伯纳斯-李爵士&lt;/a&gt;发明了HTTP协议之后，近30年来HTTP服务已经成为了我们生活中必不可缺的一部分，倘若没有它世界也将缺少一分光彩。我们已经知道了HTTP协议是用于沟通HTTP服务器和客户端的一种协议，那么HTTP服务器作为服务的提供方其重要性自然不言而喻。在HTTP协议刚刚诞生不久的年代，HTTP服务器还只能处理静态网页，后来慢慢的出现了动态网页，在1993年CGI技术诞生，它可以被认为是最早期的Web框架之一。后来随着时间的推移，各种Web框架层出不穷，直到今天Web框架已经多的数不胜数，例如SpringMVC、Laravel、Rails和Flask等等。我因为对SpringMVC的注解式代码书写方式以及Spr"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">一个轻量级Web框架的实现</h1></div><div class="post-meta"><span class="post-time">2017-11-08</span></div><div class="post-content"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>自从1990年<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%92%82%E5%A7%86%C2%B7%E4%BC%AF%E7%BA%B3%E6%96%AF-%E6%9D%8E">蒂莫西·约翰·伯纳斯-李爵士</a>发明了HTTP协议之后，近30年来HTTP服务已经成为了我们生活中必不可缺的一部分，倘若没有它世界也将缺少一分光彩。我们已经知道了HTTP协议是用于沟通HTTP服务器和客户端的一种协议，那么HTTP服务器作为服务的提供方其重要性自然不言而喻。在HTTP协议刚刚诞生不久的年代，HTTP服务器还只能处理静态网页，后来慢慢的出现了动态网页，在1993年CGI技术诞生，它可以被认为是最早期的Web框架之一。后来随着时间的推移，各种Web框架层出不穷，直到今天Web框架已经多的数不胜数，例如SpringMVC、Laravel、Rails和Flask等等。我因为对SpringMVC的注解式代码书写方式以及Spring容器的依赖注入非常好奇，所以便根据Spring的实现来书写了这个框架，故有了这篇文章。</p><h3 id="什么是Web框架"><a href="#什么是Web框架" class="headerlink" title="什么是Web框架"></a>什么是Web框架</h3><p>Web框架出现的目的主要是为了加快开发效率，事实上Web框架可能会在一定程度的降低程序的运行效率，但是我们并不在乎这一部分性能的损失。Web框架本质上还是依赖于HTTP协议，在客户端看来它的响应和我们手动书写的HTTP响应并没有什么不同，不过它可以提升代码的可重用性，还可以提供很多方便数据访问方式。</p><h3 id="实现一个类似于SpringMVC的Web需要解决哪些问题"><a href="#实现一个类似于SpringMVC的Web需要解决哪些问题" class="headerlink" title="实现一个类似于SpringMVC的Web需要解决哪些问题"></a>实现一个类似于SpringMVC的Web需要解决哪些问题</h3><p>我们已经知道了Web框架也需要依赖于HTTP协议，所以我们要做到能够处理HTTP请求并向客户端发回HTTP响应。除此之外，我们还需要实现Java的依赖注入功能，而且因为我们的框架是通过Java的注解做的请求映射，所以我们还需要实现注解的处理并将特定的请求转发指定的处理方法上去。</p><p>综上我们需要解决下面这几个问题：</p><ol><li>处理HTTP请求并生成HTTP响应；</li><li>实现Java的依赖注入功能；</li><li>可以根据注解实现请求到方法的映射；</li></ol><h3 id="HTTP请求的处理"><a href="#HTTP请求的处理" class="headerlink" title="HTTP请求的处理"></a>HTTP请求的处理</h3><p>我在实现HTTP请求处理的时候使用了两种方式，在使用框架时可以通过配置文件的方式来选择使用哪种服务器</p><ol><li>第一种是使用JavaNIO库手动的处理HTTP请求和响应，实现的比较简陋，但是足够完成基本的请求和响应；</li><li>使用Jetty这个Web容器来处理HTTP请求和响应，功能更为强大，这也是框架中默认选择的服务器；</li></ol><p>两种实现分别对应<a target="_blank" rel="noopener" href="https://github.com/RitterHou/Geisha/blob/master/src/main/java/com/nosuchfield/geisha/mvc/server/nio/NioServer.java">NioServer.java</a>和<a target="_blank" rel="noopener" href="https://github.com/RitterHou/Geisha/blob/master/src/main/java/com/nosuchfield/geisha/mvc/server/jetty/JettyServer.java">JettyServer.java</a>，具体选择哪一个服务的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务器配置</span></span><br><span class="line">Map&lt;String, Object&gt; config = ConfigUtil.getConfig();</span><br><span class="line"><span class="type">String</span> <span class="variable">server</span> <span class="operator">=</span> (String) config.get(<span class="string">&quot;server&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> (Integer) config.get(<span class="string">&quot;port&quot;</span>);</span><br><span class="line"><span class="comment">// 启动HTTP服务器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;jetty&quot;</span>.equals(server))</span><br><span class="line">    JettyServer.start(port);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;nio&quot;</span>.equals(server))</span><br><span class="line">    NioServer.start(port);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown server type [&quot;</span> + server + <span class="string">&quot;]&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="实现依赖注入"><a href="#实现依赖注入" class="headerlink" title="实现依赖注入"></a>实现依赖注入</h3><p>依赖注入的目的是让容器来管理JavaBean而不是开发者自己手动来管理，它在一定程度上降低了业务代码的复杂性。我们在Web框架下自己实现了依赖注入的功能，它的原理是通过Java的反射机制来创建用于所需要的Bean。它的核心逻辑如下所示</p><ol><li>获取到当前ClassPath下的所有的Class，这一步的核心逻辑是根据文件IO获取到ClassPath下所有的*.class文件，之后做一定处理获取到该class文件的包名以及类名，最后通过 <code>Class.forName()</code> 方法来使用反射创建该类（该部分逻辑位于 <a target="_blank" rel="noopener" href="https://github.com/RitterHou/Geisha/blob/master/src/main/java/com/nosuchfield/geisha/utils/PackageListUtils.java">java&#x2F;com&#x2F;nosuchfield&#x2F;geisha&#x2F;utils&#x2F;PackageListUtils.java</a>）；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Class&gt; classes = PackageListUtils.getAllClass();</span><br></pre></td></tr></table></figure></li><li>在第一步我们已经获取到了所有的class，在第二步我们扫描所有的class找出加上了 <code>Component</code> 和 <code>Configuration</code> 注解的类，通过反射创建这些类的对象并保存；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描类并且创建bean，把bean保存到内存中</span></span><br><span class="line"><span class="keyword">for</span> (Class clazz : classes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Component.class) || clazz.isAnnotationPresent(Configuration.class)) &#123;</span><br><span class="line">        BeansPool.getInstance().setObject(clazz, clazz.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>扫描所有加上了 <code>Configuration</code> 注解的类中加上了 <code>Bean</code> 注解的方法，并把该方法返回的对象保存；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把用户自定义的Bean保存到内存中去</span></span><br><span class="line"><span class="keyword">for</span> (Class clazz : classes) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Configuration.class)) &#123;</span><br><span class="line">        Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Bean.class)) &#123;</span><br><span class="line">                <span class="type">Object</span> <span class="variable">classObject</span> <span class="operator">=</span> BeansPool.getInstance().getObject(clazz);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> method.invoke(classObject); <span class="comment">// 获取方法的返回值对象</span></span><br><span class="line">                BeansPool.getInstance().setObject(o.getClass(), o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>把所有加上了 <code>Resource</code> 注解的变量进行注入；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把内存中的bean注入到对象中去</span></span><br><span class="line"><span class="keyword">for</span> (Class clazz : classes) &#123;</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="keyword">if</span> (field.isAnnotationPresent(Resource.class)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">classObject</span> <span class="operator">=</span> BeansPool.getInstance().getObject(clazz);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">fieldObject</span> <span class="operator">=</span> BeansPool.getInstance().getObject(field.getType());</span><br><span class="line"></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            field.set(classObject, fieldObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过以上这几步我们已经实现了一个简单的依赖注入功能，它可以使用注解来实现对象的创建、管理和注入。</p><h3 id="实现HTTP请求映射"><a href="#实现HTTP请求映射" class="headerlink" title="实现HTTP请求映射"></a>实现HTTP请求映射</h3><p>其实在实现了依赖注入之后，请求的映射也变得很简单了。无非就是在系统启动时对另外一些注解做处理，把注解所代表的请求和指定方法映射起来，并且把这些映射关系保存起来。之后当有请求到来时，查阅请求关系获取到请求对应的处理方法，之后执行方法即可。</p><p>系统启动时的映射关系获取如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取到所有的class</span></span><br><span class="line">List&lt;Class&gt; classes = PackageListUtils.getAllClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Class clazz : classes) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">classUrl</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 判断当前类是否有 RequestMapping 注解，如果有则获取注解的值</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(RequestMapping.class)) &#123;</span><br><span class="line">        <span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span> (RequestMapping) clazz.getAnnotation(RequestMapping.class);</span><br><span class="line">        classUrl = requestMapping.value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历该类的所有的方法</span></span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 如果方法上有 RequestMapping 注解，则把注解的值取出来做处理然后保存到 UrlMappingPool 中</span></span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(RequestMapping.class)) &#123;</span><br><span class="line">            <span class="type">RequestMapping</span> <span class="variable">requestMapping</span> <span class="operator">=</span> method.getAnnotation(RequestMapping.class);</span><br><span class="line">            <span class="type">String</span> <span class="variable">methodUrl</span> <span class="operator">=</span> requestMapping.value();</span><br><span class="line">            <span class="type">RequestMethod</span> <span class="variable">requestMethod</span> <span class="operator">=</span> requestMapping.method(); <span class="comment">// 只看方法上的HTTP METHOD</span></span><br><span class="line">            <span class="comment">// 把类上的URL和方法上的URL连接起来</span></span><br><span class="line">            methodUrl = classUrl == <span class="literal">null</span> ? methodUrl : classUrl + methodUrl;</span><br><span class="line">            UrlMappingPool.getInstance().setMap(methodUrl, clazz, method, requestMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们已经成功的把所有的请求和方法的映射关系保存了起来，之后我们看一看当HTTP请求到来我们是如何做处理的。我们以Jetty服务器为例（NIO的话要稍微复杂一些，因为我们还需要自己解析HTTp请求），看看我们是如何根据请求从 <code>UrlMappingPool</code> 中取出映射关系并处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析请求并返回响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doResponse</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取请求url</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">    <span class="comment">// 获取请求method</span></span><br><span class="line">    <span class="type">RequestMethod</span> <span class="variable">requestMethod</span> <span class="operator">=</span> RequestMethod.getEnum(request.getMethod());</span><br><span class="line">    <span class="comment">// 从UrlMappingPool中根据请求url和method获取到对应的请求处理方法</span></span><br><span class="line">    <span class="type">MethodDetail</span> <span class="variable">methodDetail</span> <span class="operator">=</span> UrlMappingPool.getInstance().getMap(url, requestMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找不到对应的匹配规则则返回404</span></span><br><span class="line">    <span class="keyword">if</span> (methodDetail == <span class="literal">null</span>) &#123;</span><br><span class="line">        response.setStatus(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">        response.getWriter().print(Constants.NOT_FOUND);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从BeansPool中获取到该处理方法所在的类的对象</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> methodDetail.getClazz();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> BeansPool.getInstance().getObject(clazz);</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;can&#x27;t find bean for &quot;</span> + clazz);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取参数并保存到requestParam中</span></span><br><span class="line">    Map&lt;String, String&gt; requestParam = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    request.getParameterMap().forEach((k, v) -&gt; &#123;</span><br><span class="line">        requestParam.put(k, v[<span class="number">0</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; params = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 最终的处理方法的参数</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodDetail.getMethod();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取处理方法的所有的参数</span></span><br><span class="line">    Parameter[] parameters = method.getParameters();</span><br><span class="line">    <span class="keyword">for</span> (Parameter parameter : parameters) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 获取参数上所有的注解</span></span><br><span class="line">        Annotation[] annotations = parameter.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (annotation.annotationType() == Param.class) &#123;</span><br><span class="line">                <span class="type">Param</span> <span class="variable">param</span> <span class="operator">=</span> (Param) annotation;</span><br><span class="line">                name = param.value();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果请求参数中存在这个方法参数就把该值赋给方法参数，否则赋值null</span></span><br><span class="line">        params.add(requestParam.getOrDefault(name, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用该方法并获取返回值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(object, params.toArray());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写回响应</span></span><br><span class="line">    response.setStatus(HttpServletResponse.SC_OK);</span><br><span class="line">    response.getWriter().print(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此一次请求就能够被成功处理了。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>我实现的这个Web框架还是非常的简单的，大神请轻喷。而且我在实现class获取的时候并没有能够获取到jar包或者war包中的class信息，这也是一个比极大的缺点，以后也许会把该功能完成。</p><p>项目源码：<a target="_blank" rel="noopener" href="https://github.com/RitterHou/Geisha">https://github.com/RitterHou/Geisha</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="一个轻量级Web框架的实现">https://www.nosuchfield.com/2017/11/08/Geisha-Tiny-Java-MVC-Framework/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%A1%86%E6%9E%B6/" rel="tag">框架</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>