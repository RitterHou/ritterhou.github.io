<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>深入Java字符串 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="Java"><meta name="description" content="&lt;p&gt;String应该是每一个Java程序员在工作和学习中使用频率最高的一个类了，正是因为它的使用频率是如此之高，所以Java的设计者对String类型做了一定程度的优化，下面我们来探讨一下String类的几个比较有趣的性质。&lt;/p&gt;
&lt;h3 id=&#34;1-String类的不变性（Immutable）&#34;&gt;&lt;a href=&#34;#1-String类的不变性（Immutable）&#34; class=&#34;headerlink&#34; title=&#34;1. String类的不变性（Immutable）&#34;&gt;&lt;/a&gt;1. String类的不变性（Immutable）&lt;/h3&gt;&lt;p&gt;在Java中，String对象的值是不可能发生改变的。&lt;/p&gt;
&lt;p&gt;和C语言中的字符串表示方式一样，String类在其内部也是通过一个字符数组来保存字符串的所有的字符的（这应该已经算是一个常识了，大家都知道）。观察String类的源码就可以发现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符数组 &lt;code&gt;value&lt;/code&gt; 被关键字 &lt;code&gt;private&lt;/code&gt; 和 &lt;code&gt;final&lt;/code&gt; 所修饰；&lt;/li&gt;
&lt;li"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">深入Java字符串</h1></div><div class="post-meta"><span class="post-time">2016-12-02</span></div><div class="post-content"><p>String应该是每一个Java程序员在工作和学习中使用频率最高的一个类了，正是因为它的使用频率是如此之高，所以Java的设计者对String类型做了一定程度的优化，下面我们来探讨一下String类的几个比较有趣的性质。</p><h3 id="1-String类的不变性（Immutable）"><a href="#1-String类的不变性（Immutable）" class="headerlink" title="1. String类的不变性（Immutable）"></a>1. String类的不变性（Immutable）</h3><p>在Java中，String对象的值是不可能发生改变的。</p><p>和C语言中的字符串表示方式一样，String类在其内部也是通过一个字符数组来保存字符串的所有的字符的（这应该已经算是一个常识了，大家都知道）。观察String类的源码就可以发现：</p><ul><li>字符数组 <code>value</code> 被关键字 <code>private</code> 和 <code>final</code> 所修饰；</li><li>String类本身也<strong>只可能</strong>在执行构造方法的时候才会去修改value的值；</li><li>String类本身也被声明为final的，意味着String类无法被继承；</li></ul><p>以上几个条件保证了String类只会在执行构造方法（即初始化）的时候才会修改字符数组的值，SUN的工程师通过这一系列的技巧来保证String对象的值绝对不会被修改。</p><p>写到这里就会有同学跳出来说了：你胡说，我明明就修改了String的值啊，而且修改的很频繁，比如下面这个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于为什么不使用 new 也能创建一个 String 对象会在下一小结谈到，这里不需要管</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">s1 = s1 + <span class="string">&quot;2&quot;</span>; <span class="comment">// 或 s1 += &quot;2&quot;;</span></span><br></pre></td></tr></table></figure><p>如果我们这里打印s1的值，会发现s1的值变成了12，这是不是就意味着s1所指向的String对象被修改了呢？当然没有，下面这个例子可以证明String对象并没有被修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1;</span><br><span class="line">s1 = s1 + <span class="string">&quot;2&quot;</span>;</span><br><span class="line">System.out.println(s1); <span class="comment">// 结果为 12</span></span><br><span class="line">System.out.println(s2); <span class="comment">// 结果为 1</span></span><br></pre></td></tr></table></figure><p>我们可以发现，s2所指向的对象”1”并没有被修改，说明了String是不变的。</p><p>我们隐约感觉到上面的操作可能和 <code>+</code> 和 <code>+=</code> 这两个操作有关，那么String类型的 <code>+</code> 和 <code>+=</code> 操作是怎么实现的呢？<br>答：<code>+</code> 和 <code>+=</code> 是Java中的<strong>唯一</strong>两个重载的操作符，他们只适用于String对象的操作（不是String类型的对象如果使用了这个操作符，则会调用其 <code>toString()</code> 方法来返回一个String对象）。在使用 <code>+</code> 或者 <code>+=</code> 操作符的时候，实际上是使用了 <code>StringBuilder</code> 这个类来实现了所有的操作。<code>String s = &quot;1&quot; + &quot;2&quot;;</code> 的真实过程如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb1.append(sb2).toString();</span><br></pre></td></tr></table></figure><p>这样我们就明白了，String对象确实是不可变的，而且String对象在执行 <code>+</code> 和 <code>+=</code> 操作的时候原来是通过StringBuilder来协助完成操作的。</p><h3 id="2-为什么不使用new也能创建String对象"><a href="#2-为什么不使用new也能创建String对象" class="headerlink" title="2. 为什么不使用new也能创建String对象"></a>2. 为什么不使用new也能创建String对象</h3><p>String类型和Java中的其他类型（不包括基本类型）的最大区别大概就在于他不需要 <code>new</code> 就可以创建一个对象了，这种实现方法很类似于基本类型的创建方式，难道说String类型和基本类型之间存在着什么联系吗？答案是否定的。</p><p>我们先了解一下Java中是如何对字符串进行操作的：</p><ol><li><p>在Java文件被编译为class文件之后，在class文件中（即字节码文件中），有一个区域叫做<strong>常量池</strong>（Constant Pool Table），常量池中主要保存两个东西：字面量（Literal）和符号引用(Symbolic References)。顾名思义，字面量就是能显示出值的常量，而引用就是对另外一个地方的值进行了引用的常量，我们所关注的字符串就被保存为字面量。</p></li><li><p>当class被加载到JVM中时，原来的class文件常量池中的内容会被加载到<strong>运行时常量池</strong>中，运行时常量池位于方法区。但是字符串并没有被加载到运行时常量池，而是会根据字符串的内容进行判断：如果<strong>字符串常量区中还没有一个引用所指向的堆内存中的对象与这个字符串中的内容一样</strong>，就会在<strong>堆内存</strong>中创建一个对应的String对象，然后会在<strong>字符串常量池（<em>String Literal Pool</em>）</strong>中创建一个指向这个对象的引用。字符串常量池是所有类共享，位于方法区外。注意，以上的String对象创建和字符串常量池中创建引用的操作在类加载时就会执行，并且执行完毕。</p></li></ol><p>之后，如果新建的字符串是 <code>String s = &quot;1&quot;;</code> 的这种格式，虚拟机会在字符串常量区中进行查找，当找到了一个指向堆内存中值为”1”的的对象的引用时，就把这个引用复制给s，也就是说让s也指向堆内存中的那个字符串对象，s的赋值完成。</p><p>如果是 <code>String s = new String(&quot;1&quot;);</code> 这种格式，虚拟机会在堆内存中直接创建一个值为1的字符串对象，然后让s指向这个对象，显然这个新创建的对象和上面的那种<code>String s = &quot;1&quot;;</code>的操作方式所指向的不是同一个对象。<em>但是，在这里有个必须要强调的地方</em>，当使用new方式来创建String对象的时候，会执行String的构造方法，我们看一下String对应的这个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = original.value;</span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现这个新建的对象中的内容实际上是来自于 <code>original</code> 的内容（注意是内容，即那个保存字符串的数组），也就是说，这个新的对象的内容等于 <code>original</code> 的内容。<code>original</code> 其实是一个在class加载的时候就保存在堆内存中的对象，其在字符串常量区中会有一个指向它的引用。所以我们可以说这种通过new来创建字符串对象的方式会在堆内存中创建两个对象，一个是在加载时创建的被所有方法区都可以使用的在字符创常量区有一个指向其的引用的对象；另一个就是new出来的字符串对象，不过它的value是前面的那个 <code>original</code> 对象赋给它的。更进一步，这两个字符串其实指向的是同一个字符数组，如果能把这两个对象的value变量比较一下的话（不过做不到，因为value是private的），它们肯定是相等的。</p><p>看到这里我们就明白了，之所以不使用new也能创建一个String对象，是因为这个String对象在class被载入到方法区的时候就已经被创建在堆内存中了。之后在执行 <code>String s = &quot;xxx&quot;;</code> 语句的时候，其实是把字符串常量区中的对应的引用复制给s。相反的，当使用<code>String s = new String(&quot;xxx&quot;);</code> 的时候，和其他的对象的创建方式就一样了，是直接在堆内存中创建了一个全新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;s&quot;</span>; <span class="comment">// 在字符串常量区拥有同一个引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;s&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;s&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// 打印 true</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// 打印 false</span></span><br></pre></td></tr></table></figure><p>上面这个例子证实了我们的理论，s1和s2之所以相等，就是因为它们都是复制于字符串常量区中的同一个引用，所以它们指向的就是同一个对象，自然也就相等；而s3和s4因为它们指向的是堆内存中的不同的对象（它们都分别创建了自己对象），所以自然不会相等。那么s1和s3比较呢，是否相等？如果你已经理解了上面的过程，那么应该已经知道答案了。</p><p>了解了上面两种创建String对象的方式的区别之后，我再提一下String对象的 <code>intern</code> 方法，SUN对intern方法的功能介绍如下：</p><blockquote><p>When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the <code>equals(Object)</code> method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.</p></blockquote><p>简单说来当一个String对象调用 <code>intern</code> 方法的时候，分为以下两种情况</p><ol><li>如果字符串常量区存在一个和这个String对象equals的string，那么就返回这个string</li><li>如果不存在，就在字符串常量区创建一个指向这个String Object的引用，然后返回</li></ol><p>通过intern方法，能够把通过new关键字创建的string也和字符串常量区联系起来了，下面这两个例子就很好的说明这一点<br>例子1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2.intern());  <span class="comment">// 打印结果为 true</span></span><br><span class="line">System.out.println(s2 == s2.intern());  <span class="comment">// 打印结果为 false</span></span><br></pre></td></tr></table></figure><p>在例子1中，因为s1是在字符串常量区中的，又因为s2的intern方法会直接返回<code>&quot;1&quot;</code>这个对象在字符串常量区中引用，所以它们自然相等，所以打印结果1为true；又因为s2所指向的对象和s1所指向的对象（也就是字符串常量区中的引用所指向的对象）不相等，所以打印结果2为false。<br>例子2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(s1 + s2);</span><br><span class="line">System.out.println(s3 == s3.intern()); <span class="comment">// 打印结果为 true</span></span><br></pre></td></tr></table></figure><p>在例子2中，为了避免在字符串常量区中创建”12”，我们把s3通过两个字符串分开创建然后再组合起来。因为s3在调用intern方法的时候，其返回的字符串常量区中的引用也是指向了堆内存中的同样一个对象，所以他们自然相等。</p><h3 id="3-String和StringBuilder和StringBuffer的适用场景"><a href="#3-String和StringBuilder和StringBuffer的适用场景" class="headerlink" title="3. String和StringBuilder和StringBuffer的适用场景"></a>3. String和StringBuilder和StringBuffer的适用场景</h3><ul><li>我们已经知道了String是不可变的了，所以String一般用于字符串不会产生变化的时候；</li><li>StringBuilder一般用于字符串会变化的情况，因为其线程不安全，所以用于单线程下字符串会变化的情况；</li><li>StringBUffer是线程安全的，一般用于多线程下字符串会变化的情况</li></ul><p>下面是一个比较这三个类的效率的小demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; <span class="comment">// 固定字符串</span></span><br><span class="line">s = s + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">s = s + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;String\t\t&quot;</span> + (time2 - time1));</span><br><span class="line"><span class="type">long</span> <span class="variable">time3</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 变化的字符串，非线程安全，单线程下使用</span></span><br><span class="line">sb = sb.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">sb = sb.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">time4</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuilder\t&quot;</span> + (time4 - time3));</span><br><span class="line"><span class="type">long</span> <span class="variable">time5</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 变化的字符串，线程安全，多线程下使用</span></span><br><span class="line">sb1 = sb1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">sb1 = sb1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">time6</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;StringBuffer\t&quot;</span> + (time6 - time5));</span><br></pre></td></tr></table></figure><p>在我的电脑上测试打印结果如下：</p><pre><code>String          3422
StringBuilder   933
StringBuffer    25503
</code></pre><p>由此可见，StringBuilder的变化效率最高，String其次，StringBuffer最慢。因此如果字符串经常变化，而且是在单线程情况下，请使用StringBuilder来替代String和StringBuffer吧。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a target="_blank" rel="noopener" href="http://www.javaranch.com/journal/200409/ScjpTipLine-StringsLiterally.html">Strings, Literally</a></li><li><a target="_blank" rel="noopener" href="http://rednaxelafx.iteye.com/blog/774673">请别再拿“String s &#x3D; new String(“xyz”);创建了多少个String实例”来面试了吧</a></li><li><a target="_blank" rel="noopener" href="http://www.ciaoshen.com/2016/07/29/string/">String str&#x3D;new String(“Hello”)到底创建了几个对象？</a></li><li>《Java编程思想》第13章</li></ol></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="深入Java字符串">https://www.nosuchfield.com/2016/12/02/Depth-Java-String/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>