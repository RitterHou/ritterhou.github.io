<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>Java 中的 λ 表达式 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="Java"><meta name="description" content="&lt;p&gt;一般来说我们会认为在编程领域通用的lambda意义就是匿名函数（关于为什么叫做lambda可以参考&lt;a href=&#34;http://math.stackexchange.com/questions/64468/why-is-lambda-calculus-named-after-that-specific-greek-letter-why-not-rho-calc&#34;&gt;这里&lt;/a&gt;），1958年Lisp首先采用匿名函数，不过随着时间的推移，越来越多的语言开始采用这种语法（比如PHP，C++，Python，等等）。这种趋势正好验证了Paul Graham在The roots of Lisp（Lisp之根源）所提出的一种观点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我认为目前为止只有两种真正干净利落， 始终如一的编程模式：C语言模式和Lisp语言模式。此二者就像两座高地，在它们中间是尤如沼泽的低地。随着计算机变得越来越强大，新开发的语言一直在坚定地趋向于Lisp模式。二十年来，开发新编程语言的一个流行的秘决是，取C语言的计算模式，逐渐地往上加Lisp模式的特性，例如运行时类型和无用单元收"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">Java 中的 λ 表达式</h1></div><div class="post-meta"><span class="post-time">2016-12-05</span></div><div class="post-content"><p>一般来说我们会认为在编程领域通用的lambda意义就是匿名函数（关于为什么叫做lambda可以参考<a target="_blank" rel="noopener" href="http://math.stackexchange.com/questions/64468/why-is-lambda-calculus-named-after-that-specific-greek-letter-why-not-rho-calc">这里</a>），1958年Lisp首先采用匿名函数，不过随着时间的推移，越来越多的语言开始采用这种语法（比如PHP，C++，Python，等等）。这种趋势正好验证了Paul Graham在The roots of Lisp（Lisp之根源）所提出的一种观点</p><blockquote><p>我认为目前为止只有两种真正干净利落， 始终如一的编程模式：C语言模式和Lisp语言模式。此二者就像两座高地，在它们中间是尤如沼泽的低地。随着计算机变得越来越强大，新开发的语言一直在坚定地趋向于Lisp模式。二十年来，开发新编程语言的一个流行的秘决是，取C语言的计算模式，逐渐地往上加Lisp模式的特性，例如运行时类型和无用单元收集。</p></blockquote><p>我个人对上面的这句话无比的赞同，因为我们也可以观察到，不论PHP、C++还是Python，又或者是最近火的不行的要写天写地写宇宙的JavaScript，他们最初的语法都是借鉴了C，然后又开始逐渐的汲取Lisp的的语言特性，这正是上面所提到的<em>取C语言的计算模式，逐渐地往上加Lisp模式的特性</em>。</p><p>Java在版本8中加入了 λ 表达式，不过这个新添加的语法糖和Lisp不一样并不是用来实现匿名函数的（Java中没有匿名函数），而是用于匿名内部类，新添加的 λ 表达式相当于增加了一种新的书写匿名内部类的方式。</p><h3 id="1-匿名内部类"><a href="#1-匿名内部类" class="headerlink" title="1. 匿名内部类"></a>1. 匿名内部类</h3><p>Java中的匿名内部类使得程序员可以创建一个继承自某一个类或者实现了某一个接口的匿名类，这个类在实现的时候不需要有名字，而可以直接创建一个对象供使用。请看例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lelouch</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">geass</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lelouch</span> <span class="variable">lelouch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lelouch</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">geass</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">lelouch.geass(<span class="string">&quot;ルルーシュ·ヴィ·ブリタニアが命じる&quot;</span>);</span><br></pre></td></tr></table></figure><p>上面我们定义了一个名叫鲁鲁修的接口，在接口中定义了一个方法叫做<code>geass</code>，方法包含了一个String类型的参数。然后我们使用了匿名内部类来创建了一个实现了鲁鲁修这个接口的实现类，并且在匿名类中我们重写了<code>geass</code>这个方法，方法很简单，就是打印这个参数中的字符串。通过匿名内部类的方式创建了一个实现了Lelouch接口的对象之后，创建一个指向了这个对象的类型为Lelouch名为lelouch的引用，之后通过这个引用执行匿名对象的<code>geass</code>方法，成功打印出了<code>ルルーシュ·ヴィ·ブリタニアが命じる</code>这句话。<br><img src="/images/20161205/lelouch.jpg" alt="鲁鲁修"></p><h3 id="2-lambda表达式"><a href="#2-lambda表达式" class="headerlink" title="2. lambda表达式"></a>2. lambda表达式</h3><p>上面这个例子中我们创建了匿名内部类使用了6行代码，接下来，我们使用lambda表达式只需要一行就能够搞定，并且实现的的效果匿名内部类的效果一样。不过需要注意的是，lambda表达式和匿名内部类还有些不太一样的地方：</p><ol><li>匿名内部类可以通过继承类或者实现接口实现，lambda表达式只适用于实现接口的情况</li><li>使用了lambda表达式的接口必须有且仅有一个方法</li></ol><p>我们把上面的代码改写如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lelouch</span> <span class="variable">lelouch</span> <span class="operator">=</span> (s) -&gt; System.out.println(s);</span><br></pre></td></tr></table></figure><p>上面这行代码就是一个实现了和上面的代码相同的效果的lambda表达式，我们来解释下<code>(s)</code>、<code>-&gt;</code>和<code>System.out.println(s)</code>是什么意思。</p><ul><li><code>(s)</code>代表了接口Lelouch中唯一的方法的参数。如果只有一个参数，可以不加括号；如果没有参数，使用<code>()</code>即可；如果有多个参数，只需要按顺序把参数输进去，形如(x, y)。</li><li><code>-&gt;</code>，lambda的操作符，使用了它就代表使用了lambda表达式。</li><li><code>System.out.println(s)</code>是一个方法执行的区域，可以使用第一个括号中所定义好的参数。如果只有一条语句，直接写出来即可；如果有多条语句，需要使用<code>&#123;&#125;</code>把代码括起来。</li></ul><p>上面就是对lambda表达式的解释，很简单，很容易。只要把它和匿名内部类对照起来看，就很明了了。下面是一个稍微复杂点的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lelouch</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">geass</span><span class="params">(String name, String s)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lelouch</span> <span class="variable">lelouch</span> <span class="operator">=</span> (name, s) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;ルルーシュ&quot;</span>.equals(name)) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Yes, your majesty.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">lelouch.geass(<span class="string">&quot;ルルーシュ&quot;</span>, <span class="string">&quot;ルルーシュ·ヴィ·ブリタニアが命じる&quot;</span>);</span><br><span class="line">lelouch.geass(<span class="string">&quot;king&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>打印结果为</p><pre><code>ルルーシュ·ヴィ·ブリタニアが命じる
Yes, your majesty.
</code></pre><p>这里我们把参数由一个添加为了两个，并且把一行执行代码变为了一个代码块，这在lambda表达式中也是合法的。</p><p>如果lambda表达式中只有一条执行语句，并且lambda表示的参数和这条执行语句所需要的参数一致，那我们就可以用<code>::</code>来调用方法进行执行。<br>例如对于第一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lelouch</span> <span class="variable">lelouch</span> <span class="operator">=</span> (s) -&gt; System.out.println(s);</span><br></pre></td></tr></table></figure><p>因为<code>geass</code>方法和<code>System.out.println</code>所需要的参数是一模一样的（都为<code>s</code>），那么我们就可以使用如下的这种lambda表达式来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lelouch</span> <span class="variable">lelouch</span> <span class="operator">=</span> System.out::println;</span><br></pre></td></tr></table></figure><p>上面这条语句是对原始的lambda表达式的进一步的简写，这种语法对参数的个数是没有限制的，只需要保证接口中的方法参数和所执行的语句的方法参数一致就可以了。下面是对这种语法的一个稍微复杂一点的示例，能够加深你的理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String name, <span class="type">int</span> age, String location)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>()::printInfo;</span><br><span class="line">        person.info(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>, <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(String name, <span class="type">int</span> age, String location)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;, location = &quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要知道的是，lambda表达式只是Java的一个语法糖，这种操作在编译的时候编译器就会把它的语法转化为内部类的语法，之后的操作就和内部类的操作是一样的了，也就是说lambda语法不会涉及到JVM中的相关操作。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a target="_blank" rel="noopener" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html">Java SE 8: Lambda Quick Start</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="Java 中的 λ 表达式">https://www.nosuchfield.com/2016/12/05/The-%CE%BB-Expression-in-Java/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>