<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>深入 Java HashMap - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="Java,数据结构"><meta name="description" content="&lt;p&gt;HashMap是Java自带的基础类库中使用频率极高的一个类，其内部使用&lt;code&gt;java.util.HashMap.Entry&amp;lt;K, V&amp;gt;&lt;/code&gt;对象来保存键值对，并且使用&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8&#34;&gt;哈希表&lt;/a&gt;作为内部的存储数据结构，读写效率极高，但是其本身存储的数据是无序的。HashMap位于&lt;code&gt;rt.jar&lt;/code&gt;的&lt;code&gt;java.util&lt;/code&gt;包下，最初于JDK1.2中首次发布。&lt;/p&gt;
&lt;p&gt;这篇文章所分析的HashMap的源码对应JDK的版本为1.7，该版本HashMap的代码出自鼎鼎大名的&lt;a href=&#34;https://en.wikipedia.org/wiki/Doug_Lea&#34;&gt;Doug Lea&lt;/a&gt;之手。在JDK1.8中HashMap被重写，与1.7版本中的源码差异比较大，敬请读者注意。&lt;/p&gt;
&lt;h3 id=&#34;1-使用Entry-lt-K-V-gt-来存储每一组数据&#34;&gt;&lt;a href=&#34;#1-使用"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">深入 Java HashMap</h1></div><div class="post-meta"><span class="post-time">2016-11-16</span></div><div class="post-content"><p>HashMap是Java自带的基础类库中使用频率极高的一个类，其内部使用<code>java.util.HashMap.Entry&lt;K, V&gt;</code>对象来保存键值对，并且使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a>作为内部的存储数据结构，读写效率极高，但是其本身存储的数据是无序的。HashMap位于<code>rt.jar</code>的<code>java.util</code>包下，最初于JDK1.2中首次发布。</p><p>这篇文章所分析的HashMap的源码对应JDK的版本为1.7，该版本HashMap的代码出自鼎鼎大名的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Doug_Lea">Doug Lea</a>之手。在JDK1.8中HashMap被重写，与1.7版本中的源码差异比较大，敬请读者注意。</p><h3 id="1-使用Entry-lt-K-V-gt-来存储每一组数据"><a href="#1-使用Entry-lt-K-V-gt-来存储每一组数据" class="headerlink" title="1. 使用Entry&lt;K, V&gt;来存储每一组数据"></a>1. 使用Entry&lt;K, V&gt;来存储每一组数据</h3><p>HashMap的最基本单元是<code>Entry&lt;K,V&gt;</code>，每一个 <code>Entry</code> 对象包含了如下的四个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> K key;      <span class="comment">// 保存一组数据的 key</span></span><br><span class="line">V value;          <span class="comment">// 保存一组数据的 value</span></span><br><span class="line">Entry&lt;K,V&gt; next;  <span class="comment">// 保存该对象所指向的下一个 Entry 对象</span></span><br><span class="line"><span class="type">int</span> hash;         <span class="comment">// 保存 key 所对应的 hash 值</span></span><br></pre></td></tr></table></figure><p><code>Entry</code> 的构造方法如下，构造方法的目的是对上面的四个参数进行初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates new entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">    next = n;</span><br><span class="line">    key = k;</span><br><span class="line">    hash = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Entry</code> 类还包含了 <code>getKey()</code>、<code>getValue()</code>、<code>setValue</code>等等这样的方法，因为这些方法的实现比较简单，就不一一赘述了。</p><p>下面我们来讨论一下Entry类所对应的这4个全局变量，理解它们的含义：</p><ol><li><p>变量key与变量value</p><p>这两个变量对应的是我们要保存的键值对的key和value，也是HashMap的核心数据。每一个被put到HashMap中的键值对都会创建一个对应的Entry对象，而该Entry对象中的key和value属性就保存了我们put进去的键值对的key和value的值。</p><p>其中类型 <code>K</code> 和 <code>V</code> 是Java中的泛型一种写法，泛型保证了HashMap中所保存的所有的key的类型一致，所保存的所有的value的类型也一致。</p></li><li><p>变量next</p><p>HashMap中的哈希表使用的是数组+链表的形式，所以Entry类需要是设计成一种可以构成链表的结构。Entry对象中的next变量就是一个指向Entry链表中的下一个Entry对象的指针，通过这个变量，就可以把Entry对象通过链表的形式连接起来。关于哈希表数据结构的更多信息，可以参见我之前所写的<a href="/2016/07/29/the-python-implementationp-of-HashTable/">HashTable 的 Python 实现</a>。</p></li><li><p>变量hash</p><p>把当前对象的key所对应的hash值保存起来，方便之后调用。</p></li></ol><p>以上就是Entry类所对应的几个变量和方法，都比较简单。需要知道的是，Entry类是HashMap的一个内部类，并且实现了<code>java.util.Map.Entry&lt;K,V&gt;</code>接口。接下来我们看看HashMap是通过何种方式来构建哈希表的。</p><h3 id="2-通过Entry数组来构建一个哈希表结构"><a href="#2-通过Entry数组来构建一个哈希表结构" class="headerlink" title="2. 通过Entry数组来构建一个哈希表结构"></a>2. 通过Entry数组来构建一个哈希表结构</h3><p>HashMap一共有四个构造方法，抛开一个用来从其他Map对象构建HashMap的构造方法不谈，另外三个构造分别方法是：</p><ol><li><code>public HashMap(int initialCapacity, float loadFactor);</code></li><li><code>public HashMap(int initialCapacity);</code></li><li><code>public HashMap();</code></li></ol><p>第2和第3个构造方法都是在调用第一个构造方法，只是把某些参数设为了默认值而已，所以现在我们重点看看第一个构造方法的两个参数所代表的意义。</p><ul><li><p><code>initialCapacity</code> 的意思是初始化容量，回想一下Hash表的结构，这里所谓的初始化容量其实对应的就是保存哈希值的数组的初始长度（对哈希表结构不清楚的同学还是建议先看看文章<a href="/2016/07/29/the-python-implementationp-of-HashTable/">HashTable 的 Python 实现</a>），同时也表示了所有可能产生的哈希值的数量。如果不主动设置，哈希表的初始容量会被设置为16。</p></li><li><p><code>loadFactor</code> 的意思是<strong>加载因子</strong>，在任一个时刻，如果数组已经使用的容量（即已经保存有值、非空的位置）大于或等于临界值，那么数组就需要把自己的容量扩大到原来的容量的两倍。而在HashMap中临界值<code>threshold</code>的计算方式为[当前数组的容量 * 加载因子]，所以加载因子就是用来控制数组容量的增长速度的。如果不主动设置，那么加载因子默认为0.75。</p></li></ul><p>讲了哈希表的初始化方法，我们就可以了解HashMap中的哈希表的结构了。哈希表其实在本质上就是一个<code>Entry</code>类型的数组，因为<code>Entry</code>本身可以构成一个链表，所以这就和经典的哈希表的结构一致起来了。下面看一下哈希表的初始内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An empty table instance to share when the table is not inflated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</span><br></pre></td></tr></table></figure><p>可以发现，哈希表的初始化只是把变量table设置为一个空的<code>Entry</code>数组而已，接下来我们<strong>所有的数据</strong>都将会保存在这个数组里面。</p><h3 id="3-向HashMap中放入数据吧！"><a href="#3-向HashMap中放入数据吧！" class="headerlink" title="3. 向HashMap中放入数据吧！"></a>3. 向HashMap中放入数据吧！</h3><p>好了，既然已经了解了哈希表是怎么构成的了，是时候向HasMap中放入数据了，让我们来看一下HasMap的<code>public V put(K key, V value)</code>是如何实现的。</p><p>下面这个方法主要是对table和key进行了空判断并进行了相应的操作，之后根据key来计算hash值和数组的下标。然后在指定的数组下标中，对这个数组项对应的Entry链表进行遍历，如果发现之前已经有对应该key的值存在了链表里面，则把旧的值替换为新的要保存的值并把旧的值返回，操作完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 如 table 为空，则需要把 table 扩展到默认容量的大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 为空，则会把其保存在数组的第 0 位</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 根据 key 计算对应的 hash 值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="comment">// 根据 hash 值和数组的长度计算出这个 hash 值对应的数组的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 因为已经知道数组的下标，所以只对数组中与该 key 的 hash 一致的那个链表进行一次遍历操作就可以了，如果发现连表中的某</span></span><br><span class="line">    <span class="comment">// 个节点的 key 与我们所要 put 的 key 是一样的，那么只需要把旧的值覆盖掉置换为新的值就行了，然后把旧的值返回</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>); <span class="comment">// 可以忽视此操作</span></span><br><span class="line">            <span class="comment">// 返回旧的值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++; <span class="comment">// 可以忽视此操作</span></span><br><span class="line">    <span class="comment">// 如果在链表中没能够找到一致的 key，则需要插入新的 Entry 对象用来保存新值</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没能在链表中找到对应的key值，则意味着需要在表中插入新的值了，下面这个方法就表示了这种情况。这里会分成两种情况：</p><ul><li>若数组容量达到了扩容的条件，则需要先对哈希表进行扩容，扩容之后对哈希表进行重新排列，然后再把值插入哈希表中；</li><li>如果不需要扩容，则直接把对应的值插入到哈希表中即可；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前数组的容量已经大于或等于临界值且这个 hash 值对应的链表不为空，那么就需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length); <span class="comment">// 扩容</span></span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>; <span class="comment">// 扩容之后重新计算 hash 值</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length); <span class="comment">// 重新计算对应的下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们先讨论一下不需要扩容的单纯的插入操作，因为这一步比较简单，扩容操作后面会再说。插入节点对应着两步操作：</p><ol><li>把新节点的 next 指针指向当前数组上对应下标位置的头结点；</li><li>把当前节点置换为新的头结点。</li></ol><p>具体的实现在下面，比较简单，就不多说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们重点来讲一下<strong>扩容</strong>的相关操作，我们先看一下HashMap中是怎么实现扩容操作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; <span class="comment">// 如果容量已达扩展上限，把临界值改为 int 最大值</span></span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity]; <span class="comment">// 创建新的数组</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity)); <span class="comment">// 复制元素</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>); <span class="comment">// 修改临界值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是判断了一下当前数组的容量，如果容量已达上限，就把临界值改为 int 最大值，意味着不会再进行扩展。</p><p>如果没有达到容量上限，那么首先会创建一个新的 Entry 数组，其<strong>容量是当前数组的容量的两倍</strong>，之后会<strong>把当前的哈希表中的值全部转移到新的数组中去</strong>（这一步极其耗费时间），之后再根据新容量把临界值修改一下即可。下面我们再讨论一下如何把旧表中的值转移到新建的表中，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实原理也很简单，就是把旧表中的所有的值全部遍历一遍，然后每从旧表中查到一个值，就把它插入到新的表中。</p><p>因为这一步的操作非常耗时，所以我们在操作HashMap的时候要<strong>尽量避免频繁的对表进行扩容操作</strong>。如果能够大概的估算出HashMap所需要的容量大小，那么在定义HashMap的时候最好就指定好其容量，这样就能避免在频繁扩容的时候带来的性能的损失。</p><p>最后，放上一张HashMap中的插入操作的流程图：<br><img src="/images/20161116/HashMap.png"></p><h3 id="4-从HashMap中查找数据"><a href="#4-从HashMap中查找数据" class="headerlink" title="4. 从HashMap中查找数据"></a>4. 从HashMap中查找数据</h3><p>在从HashMap中查找数据的时候，同样需要对key进行是否为空的判断。如果key为空，因为之前我们把key为空的值都保存在<code>table[0]</code>中了，所以这一次在取得时候也只需要从<code>table[0]</code>去取就行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> == entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果key不为空，就调用<code>Entry&lt;K,V&gt; getEntry(Object key)</code>方法，getEntry方法的实现很简单，分为以下这几步：</p><ol><li>通过key来计算出对应hash值；</li><li>通过hash计算出对应的table下标；</li><li>通过下标已知了table中的槽位，然后对该槽位的链表做个遍历，找到了符合要求的Entry就返回，否则返回 null；</li></ol><p>实际的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-从HashMap中删除数据"><a href="#5-从HashMap中删除数据" class="headerlink" title="5. 从HashMap中删除数据"></a>5. 从HashMap中删除数据</h3><p>删除操作同样也很非常简单，只是对key所对应的槽位的链表做一次遍历，之后找出对应的Entry就把其删除掉。</p><p>不过删除需要注意的一点是删除的节点是否是头结点：</p><ul><li>如果是头结点，那么就让头结点的下一个节点成为新的头结点，头结点删除完成；</li><li>如果不是头结点，就让对应节点的前一个节点的<code>next</code>指向要删除节点的下一个节点，指定节点删除完成；</li></ul><p>具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">removeEntryForKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e)</span><br><span class="line">                table[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            e.recordRemoval(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-更多"><a href="#6-更多" class="headerlink" title="6. 更多"></a>6. 更多</h3><p>HashMap是Java中最常用的数据结构之一，除此之外还有几个比较常见的类：</p><ul><li>HashTable，与HashMap相比，HashTable是线程安全的并且不可插入空值，其余部分基本一样；</li><li>TreeMap，这也是一种实现了Map接口的实现类，与HashMap相比，其内部实现的数据结构为红黑树，操作效率略低于HashMap，不过其存储的数据是有序的，TreeMap适用于需要对数据进行有序存储的场合；</li><li>ConcurrentHashMap，是HashMap的线程安全的实现版本，同样出自于Doug Lea之手；</li></ul><p>本文所讲解的HashMap的内容源于JDK版本1.7，HashMap的实现在JDK1.8中被重写了，如果想了解JDK1.8中相关的操作的实现方法，可以参考：<a target="_blank" rel="noopener" href="http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">Java HashMap工作原理及实现</a></p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="深入 Java HashMap">https://www.nosuchfield.com/2016/11/16/Depth-Java-HashMap/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>