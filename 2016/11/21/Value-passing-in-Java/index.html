<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>Java中的值传递 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="Java"><meta name="description" content="&lt;h3 id=&#34;1-由一个问题引出的疑问&#34;&gt;&lt;a href=&#34;#1-由一个问题引出的疑问&#34; class=&#34;headerlink&#34; title=&#34;1. 由一个问题引出的疑问&#34;&gt;&lt;/a&gt;1. 由一个问题引出的疑问&lt;/h3&gt;&lt;p&gt;今天在看&lt;code&gt;java.io.FileInputStream&lt;/code&gt;源码的时候，突然发现Java程序中是可以改变对象的值的，有点违反我以前的认知。因为在我的想法中，局部变量的值的修改是不会影响到原来的值的，但是事实却是被调用函数中参数值的变化导致了原来方法中的值的变化。下面就是一个很简单的例子：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span cl"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">Java中的值传递</h1></div><div class="post-meta"><span class="post-time">2016-11-21</span></div><div class="post-content"><h3 id="1-由一个问题引出的疑问"><a href="#1-由一个问题引出的疑问" class="headerlink" title="1. 由一个问题引出的疑问"></a>1. 由一个问题引出的疑问</h3><p>今天在看<code>java.io.FileInputStream</code>源码的时候，突然发现Java程序中是可以改变对象的值的，有点违反我以前的认知。因为在我的想法中，局部变量的值的修改是不会影响到原来的值的，但是事实却是被调用函数中参数值的变化导致了原来方法中的值的变化。下面就是一个很简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] i = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    System.out.println(i[<span class="number">0</span>]);</span><br><span class="line">    setValue(i); <span class="comment">// 值传递</span></span><br><span class="line">    System.out.println(i[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><pre><code>0
100
</code></pre><p>很显然，数组 <code>i</code> 在调用方法 <code>setValue</code> 时进行的值传递，但是为什么 <code>i[0]</code> 的值还是被修改了呢，这里我们需要先了解一下JVM的内存模型。</p><h3 id="2-JVM内存模型"><a href="#2-JVM内存模型" class="headerlink" title="2. JVM内存模型"></a>2. JVM内存模型</h3><p>Java的虚拟机中内存区域被分为以下几个部分：</p><ul><li>程序计数器</li><li>Java虚拟机栈</li><li>本地方法栈</li><li>Java堆</li><li>方法区</li></ul><p>我们这里需要涉及到的内存区域为<strong>Java虚拟机栈</strong>和<strong>Java堆</strong>。当一个Java方法被调用时，Java虚拟机栈中就会被压入一个新的栈帧，栈帧中的其中一个部分叫做<strong>局部变量区</strong>，这个地方专门用于存放方法参数和局部变量。所以结果很明了了，当一个方法被调用时，Java虚拟机栈中被压入一个新的栈帧，而调用这个方法的那个对象（或方法）会把该方法的方法参数压入到栈帧中。这里需要注意的是这里压入的栈帧里面的方法参数是从上一个栈帧（即调用该方法的方法的栈帧）中复制出来的，而其本身<strong>并不是</strong>上一个栈帧中的值，他只是和上一个栈帧中的对应参数有一样的值而已。</p><p>具体过程可以参见下图：<br><img src="/images/20161121/20161121221310.png" alt="方法调用过程中栈帧的变换"></p><p>上面的那个栈帧是一个名为<code>addAndPrint</code>的方法的，它在内部调用了一个名为<code>addTwoTypes</code>的栈帧，中间那幅图的下面的栈帧就是在调用方法<code>addTwoTypes</code>时所产生的<code>addTwoTypes</code>的栈帧，可以发现参数1和88.88都是值传递。</p><p>通过以上例子我们可以断言：Java中的所有方法方法调用时候的参数引用都是值传递。那么第一节中的那种情况又是为什么呐？</p><p>除了Java虚拟机栈，我们还需要了解到Java中的堆内存，Java中的所有的对象都是保存在堆内存中的。如果我们在进行方法调用的时候传入的参数并不是一个纯粹的值（即不是基本的数据类型），而是一个引用类型，那么事情就变得不一样了。因为引用类型是一个指向堆内存中的对应对象的指针，所以在进行方法调用的时候，栈中压入新的栈帧，新栈帧中的引用是从上一个栈帧中复制过来的。但是，因为是从上一个栈帧中复制过来的，所以<strong>这个栈帧中的引用类型与前一个栈帧中的对应的引用类型指向的是堆内存中的同一个对象</strong>，因为堆内存中的对象只有一份（不过要注意目前有两个引用都指向了这个对象），所以在方法中对该对象进行操作，对象确实被修改了，之后再回到上一个栈帧，对象也还是会处于被修改的状态。所以第一节中的情况是合理的。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>以上的情况如果要总结的话，可以用一句话来概括：</p><blockquote><p>Java方法调用时只存在值传递，但是如果传递的参数是对某一个对象的引用，那么对应的对象也会被修改。</p></blockquote><p>下面这两个链接有兴趣的可以再看看，能够加深理解，并且讲解的也很详细</p><ul><li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">Is Java “pass-by-reference” or “pass-by-value”?</a></li><li><a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.4.1">Chapter 8. Classes</a></li></ul><p>Java规范中关于方法调用有这么一句话（可以在上面链接2的页面中找到）：</p><blockquote><p>When the method or constructor is invoked (§15.12), the values of the actual argument expressions initialize newly created parameter variables, each of the declared type, before execution of the body of the method or constructor. The Identifier that appears in the DeclaratorId may be used as a simple name in the body of the method or constructor to refer to the formal parameter.</p></blockquote><p>这里讲的已经很明白了，再结合JVM中的内存模型一起来看，就很清晰了。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="Java中的值传递">https://www.nosuchfield.com/2016/11/21/Value-passing-in-Java/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>