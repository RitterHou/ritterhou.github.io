<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>深入 Java TreeMap - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="Java,数据结构"><meta name="description" content="&lt;h3 id=&#34;0-引入&#34;&gt;&lt;a href=&#34;#0-引入&#34; class=&#34;headerlink&#34; title=&#34;0. 引入&#34;&gt;&lt;/a&gt;0. 引入&lt;/h3&gt;&lt;p&gt;Java自带基础类库中的TreeMap也是一个实现了Map接口的类，它同HashMap一样用于存储键值对。与HashMap不一样的是，TreeMap内的数据是有序的，并且其内部是由一棵红黑树来实现的。也因为以上的原因，所以TreeMap的插入查找删除的速度都比HashMap慢，所以TreeMap一般在需要对数据进行排序的时候才会使用到。&lt;/p&gt;
&lt;h3 id=&#34;1-二叉查找树&#34;&gt;&lt;a href=&#34;#1-二叉查找树&#34; class=&#34;headerlink&#34; title=&#34;1. 二叉查找树&#34;&gt;&lt;/a&gt;1. 二叉查找树&lt;/h3&gt;&lt;p&gt;红黑树和AVL树一样也是一种二叉查找树，关于二叉查找树的内容可以看我之前写过的&lt;a href=&#34;https://www.nosuchfield.com/2016/09/06/binary-search-tree-with-AVL-tree/#1-_u4E8C_u53C9_u67E5_u627E_u6811&#34;"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">深入 Java TreeMap</h1></div><div class="post-meta"><span class="post-time">2016-11-26</span></div><div class="post-content"><h3 id="0-引入"><a href="#0-引入" class="headerlink" title="0. 引入"></a>0. 引入</h3><p>Java自带基础类库中的TreeMap也是一个实现了Map接口的类，它同HashMap一样用于存储键值对。与HashMap不一样的是，TreeMap内的数据是有序的，并且其内部是由一棵红黑树来实现的。也因为以上的原因，所以TreeMap的插入查找删除的速度都比HashMap慢，所以TreeMap一般在需要对数据进行排序的时候才会使用到。</p><h3 id="1-二叉查找树"><a href="#1-二叉查找树" class="headerlink" title="1. 二叉查找树"></a>1. 二叉查找树</h3><p>红黑树和AVL树一样也是一种二叉查找树，关于二叉查找树的内容可以看我之前写过的<a href="https://www.nosuchfield.com/2016/09/06/binary-search-tree-with-AVL-tree/#1-_u4E8C_u53C9_u67E5_u627E_u6811">二叉查找树与 AVL 树</a>。我们已经知道，AVL树是通过调节左右子树的高度来控制插入和查找的速度的，红黑树虽然也是一棵二叉查找树，但是和AVL树不一样，它是通过给节点标记上不同的颜色来提高数据的插入和查找速度的。</p><p>AVL树为了保持自身的平衡，会频繁的进行旋转操作，而旋转操作是比较耗费时间的。红黑树会尽量的减少旋转操作，所以一般认为红黑树的操作效率会高于AVL树。</p><h3 id="2-红黑树的性质"><a href="#2-红黑树的性质" class="headerlink" title="2. 红黑树的性质"></a>2. 红黑树的性质</h3><p>红黑树的性质如下（摘自维基百科）：</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p>关于为什么通过这些性质就能使红黑树保证其高效率的证明，可以参考维基百科中的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">相关页面</a>。</p><h3 id="3-Entry-lt-K-V-gt-类"><a href="#3-Entry-lt-K-V-gt-类" class="headerlink" title="3. Entry&lt;K,V&gt;类"></a>3. Entry&lt;K,V&gt;类</h3><p>想要购建一颗树，首先需要构建出树中的的每一个节点。每一个节点中所包含的内容应该要合适、能够包含有所有我们需要用到数据即可。Java中是通过<code>Entry&lt;K,V&gt;</code>类来保存红黑树中的每一个节点信息的，具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 bool 类型来保存红色和黑色的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">RED</span>   <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    K key;                  <span class="comment">// Key</span></span><br><span class="line">    V value;                <span class="comment">// Value</span></span><br><span class="line">    Entry&lt;K,V&gt; left;        <span class="comment">// 左子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; right;       <span class="comment">// 右子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; parent;      <span class="comment">// 父节点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">color</span> <span class="operator">=</span> BLACK;  <span class="comment">// 节点颜色默认黑色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个节点，包含了 key、value 和 parent 三个参数</span></span><br><span class="line">    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-红黑树插入一个节点"><a href="#4-红黑树插入一个节点" class="headerlink" title="4. 红黑树插入一个节点"></a>4. 红黑树插入一个节点</h3><p>红黑树插入一个节点和二叉查找树的插入操作是一样的，对二叉查找树插入的过程不太了解可以查看<a href="https://www.nosuchfield.com/2016/09/06/binary-search-tree-with-AVL-tree/#1-_u4E8C_u53C9_u67E5_u627E_u6811">二叉查找树与 AVL 树</a>来进行了解。连接中二叉查找树的插入操作是通过递归来实现的，而TreeMap中是通过迭代来实现，不过其本质都是一样，都是通过和对应节点的值进行大小比较最终把要插入的值插入到合适的位置。</p><p>下面就是TreeMap中的插入操作，我省略掉了其中的一些不重要的步骤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="comment">// 如果根节点为空，就插入根节点（根据性质 2，根节点默认为黑色）</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cmp; <span class="comment">// 记录比较的值</span></span><br><span class="line">    Entry&lt;K,V&gt; parent; <span class="comment">// 记录当前的节点，如果在当前节点下插入了新节点，那么此节点就为新节点的父节点</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = cpr.compare(key, t.key); <span class="comment">// 如果小于当前节点，向左递归；如果大于，向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value); <span class="comment">// 已经存在该值的时候就不插入了，返回旧节点</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>); <span class="comment">// 根据 key 的值来循环直到叶子节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent); <span class="comment">// 创建新节点，其父节点为当前的叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e; <span class="comment">// 如果小于就把该节点作为当前节点左孩子</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e; <span class="comment">// 如果大于就把该节点作为当前节点右孩子</span></span><br><span class="line">    fixAfterInsertion(e); <span class="comment">// 插入了新节点之后，如果想要保持好红黑树的性质，需要进行红黑树的修复操作（参见第 5 节）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作很简单，就是根据二叉查找树的性质在进行一个循环之后把节点插入在合适的叶子节点的位置，并把其父节点设置为上一个叶子节点，并且新插入的节点是上一个叶子节点的左（右）子节点。</p><h3 id="5-插入之后红黑树的修复"><a href="#5-插入之后红黑树的修复" class="headerlink" title="5. 插入之后红黑树的修复*"></a>5. 插入之后红黑树的修复*</h3><p>红黑树和AVL都是二叉查找树，所以插入操作都是一样的，它们的差别就在于插入之后的修复操作不一样。因为红黑树和AVL的性质不一样，所以修复的方式也不一样。AVL树修复的目的是为了是树的高度降低，而红黑树的修复操作就是根据红黑树的5条性质而进行的。</p><p>首先我们会保证新插入的节点的颜色必然为红色，这样会使得情况变得比较简单（如果新插入的节点是黑色，那么必然会违背性质5，会增加修复开销）。当新插入的节点是红色的时候：</p><ul><li>如果插入的是根结点，因为原树是空树，此情况只会违反性质2，所以直接把此结点涂为黑色；</li><li>如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时也是什么也不做。</li></ul><p>但是，以下三种情况则需要进行修复操作：</p><ul><li>插入修复情况1：当前结点的父结点是红色，叔叔结点是红色；<br>对策：将当前结点的父结点和叔叔结点涂黑，祖父结点涂红，把当前结点指向祖父结点，从新的当前结点（即祖父节点）重新开始算法。</li><li>插入修复情况2：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的右子；<br>对策：当前结点的父结点做为新的当前结点，以新当前结点为支点左旋。</li><li>插入修复情况3：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的左子；<br>对策：父结点变为黑色，祖父结点变为红色，在祖父结点为支点右旋。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树性质的修复</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    x.color = RED; <span class="comment">// 把新节点设置为红色可以使得修复操作中需要进行旋转操作的概率降低</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; <span class="comment">// 只有当前节点不为空不为根节点且其父节点是红色的时候才需要修复</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; <span class="comment">// 如果 x 的父亲是 x 的祖父的左子节点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));  <span class="comment">// 那么 x 的叔叔 y 节点就是 x 祖父的右子节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123; <span class="comment">// 如果叔叔是红色，修复情况 1</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED); <span class="comment">// 这一步修改了当前节点的祖父节点的性质，因为其祖父节点的性质变化可能会引入新的影响红黑树性质的因素，所以需要把祖父节点作为新的当前节点来进行一次新的判断，这就是修复的时候需要循环的原因</span></span><br><span class="line">                x = parentOf(parentOf(x)); <span class="comment">// 把祖父节点作为新的当前节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123; 修复情况 <span class="number">2</span></span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// 修复情况 3</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); <span class="comment">// 相反的，x 的叔叔 y 节点就是 x 祖父的左子节点</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 所有操作与上面成镜像操作</span></span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左旋</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="literal">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右旋</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="literal">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面 5 个都是工具方法，在 fixAfterInsertion 方法中使用到了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">colorOf</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">null</span> ? BLACK : p.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(Entry&lt;K,V&gt; p, <span class="type">boolean</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span>)</span><br><span class="line">        p.color = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; Entry&lt;K,V&gt; <span class="title function_">parentOf</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">null</span> ? <span class="literal">null</span>: p.parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; Entry&lt;K,V&gt; <span class="title function_">leftOf</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">null</span>) ? <span class="literal">null</span>: p.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;K,V&gt; Entry&lt;K,V&gt; <span class="title function_">rightOf</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="literal">null</span>) ? <span class="literal">null</span>: p.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的前三个方法都有一个 <code>/** From CLR */</code> 的注释，表示它们其实是借鉴了C#的 <code>Common Language Runtime</code> 中的代码，可能Java的开发者是在看了CLR的源码之后才开发的TreeMap XD。</p><p>在进行了修复操作之后，红黑树又恢复其本身的性质，接下来我们看看红黑树的删除操作。</p><h3 id="6-红黑树的删除"><a href="#6-红黑树的删除" class="headerlink" title="6. 红黑树的删除"></a>6. 红黑树的删除</h3><p>红黑树的删除和普通的二叉查找树的删除操作是一样的，删除一个节点会分为以下三种情况：</p><ol><li>没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了；</li><li>只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了；</li><li>当被删除结点存在左右孩子的时候，真正被删除的点应该是该节点的左子树的最大的节点（或者是右子树的最小的节点，根据实际需要来进行选择即可），之后当前节点的值被替换为真正被删除掉的节点的值（即把子节点的值保存在当前节点了），这样一来问题就变成了第1或者第2种情况了。</li></ol><p>我们先来看一下Java中是如何进行进行删除操作的，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// 1. 删除点 p 有左右两个子节点，对应上面的情况 3，需要执行 successor 函数来把问题转化为第 1 或者第 2 种情况</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="literal">null</span> &amp;&amp; p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="literal">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="literal">null</span>) &#123;<span class="comment">// 2. 删除点 p 只有一个子节点</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="literal">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);<span class="comment">// 调整</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 3. 删除点 p 的左右子树都为空</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);<span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="literal">null</span>;</span><br><span class="line">            p.parent = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上面的源码就可以知道，Java会先对要删除的节点进行判断，分为以下三种情况，对应了我们在上面所说的三种理论情况</p><ol><li>左右两个子树都不为空，就执行 <code>successor</code> 方法来把问题转化为只有一个子树或没有子树的情况（successor方法就是把当前节点和其右子树的最小值进行替换的方法，或者说把其右子树的最小值赋给当前节点，比较简单，就不贴出来了，相信你自己肯定也能够写出来）；</li><li>只有一个子树，把子节点接在父节点上，当前节点删除；</li><li>没有子节点，即叶子节点，直接删除即可。</li></ol><p>上面的三种情况中，左右都不为空的情况会转化为子节点为一个或者没有子节点的情况，也就是说真正执行了删除操作的其实只是后两种情况。而在执行了删除操作之后，红黑树的性质可能发生了变化，所以在后两种情况执行了删除操作之后就要执行方法 <code>fixAfterDeletion</code> 来修复红黑树的性质。</p><p>我在之前的博客<a href="https://www.nosuchfield.com/2016/09/06/binary-search-tree-with-AVL-tree/#1-_u4E8C_u53C9_u67E5_u627E_u6811">二叉查找树与 AVL 树</a>有过介绍二叉查找树的删除操作，也可以做作为参考。</p><p>执行了删除操作之后，红黑树的性质可能分已经发生了改变，需要进行红黑树的修复操作，需要执行方法 <code>fixAfterDeletion</code>。</p><h3 id="7-删除之后红黑树的修复"><a href="#7-删除之后红黑树的修复" class="headerlink" title="7. 删除之后红黑树的修复*"></a>7. 删除之后红黑树的修复*</h3><p>红黑树删除后的修复操作的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123; <span class="comment">// 只有在删除的节点为黑色的时候才会破坏红黑树性质</span></span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123; <span class="comment">// 当 x 为左子节点的时候（下面还存在着一种对称的情况）</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); <span class="comment">// x 的兄弟节点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123; <span class="comment">// 情况 1</span></span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; <span class="comment">// 情况 2</span></span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 情况 3</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123; <span class="comment">// 情况 4</span></span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 和上面的那种情形成对称</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这张图从两种不同的初始状态开始，对应了红黑树的修复操作。虽然两颗红黑树的初始状态不一致，但是事实上还是符合上面源代码中所写的流程的。只不过在这两棵树中因为 sib 的左子树的左儿子颜色不一样，导致了对应情况 2和情况3两种情况（即第13行的那个判定条件，左边流程图对应情况2，右边的流程图对应情况3）。<br><img src="/images/20161126/rbt-del-fix.png"></p><p>从第29行开始，是一种和上面的那种操作构成镜像的情形，不多说了。然后之所以在这里我们需要进行一个循环操作是因为情况2中会把当前节点的父节点作为新的当前节点，这步操作可能会引入新的问题，所以需要再对当前节点进行性质判断，由此引发了一个迭代的过程，最终完成红黑树的性质的修复，操作完成。</p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ol><li><a target="_blank" rel="noopener" href="https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md">教你透彻了解红黑树</a></li><li><a target="_blank" rel="noopener" href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md">TreeSet and TreeMap</a></li></ol></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="深入 Java TreeMap">https://www.nosuchfield.com/2016/11/26/Depth-Java-TreeMap/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>