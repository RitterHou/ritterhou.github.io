<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><title>使用 Netty 与 Nginx 构建一个在线聊天网页 - 侯锐的思考与分享</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0"><meta name="keywords" content="网络编程"><meta name="description" content="&lt;h3 id=&#34;Netty-框架&#34;&gt;&lt;a href=&#34;#Netty-框架&#34; class=&#34;headerlink&#34; title=&#34;Netty 框架&#34;&gt;&lt;/a&gt;Netty 框架&lt;/h3&gt;&lt;p&gt;1.1 Netty 简介&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://netty.io/&#34;&gt;Netty&lt;/a&gt; 是一个高性能、异步事件驱动的 NIO 框架，它提供了对 TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的，通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。&lt;/p&gt;
&lt;p&gt;本文并不会详细的讨论的 Netty 框架的使用方法，关于其详细的使用方法，可以参考 &lt;a href=&#34;https://book.douban.com/subject/24700704/&#34;&gt;Netty in Action&lt;/a&gt; 一书，书中对 Netty 的相关原理和使用方法做了非常细致的讲解。本文虽然只会使用到 Netty 的一小部分特性，但是对于没有接触过 Netty 的读者来说，可以使其快速的了解 Net"><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="侯锐的思考与分享" type="application/atom+xml"></head><body><div class="container"><header class="header"><div class="blog-title"><a href="/" class="logo">侯锐的思考与分享</a><div class="subtitle"></div></div><nav class="navbar"><ul class="menu"><li class="menu-item"><a href="/" class="menu-item-link" data-no-instant>主页</a></li><li class="menu-item"><a href="/atom.xml" class="menu-item-link" data-no-instant>订阅</a></li><li class="menu-item"><a href="/search" class="menu-item-link" data-no-instant>搜索</a></li></ul></nav></header><article class="post"><div class="post-title"><h1 class="article-title">使用 Netty 与 Nginx 构建一个在线聊天网页</h1></div><div class="post-meta"><span class="post-time">2016-10-22</span></div><div class="post-content"><h3 id="Netty-框架"><a href="#Netty-框架" class="headerlink" title="Netty 框架"></a>Netty 框架</h3><p>1.1 Netty 简介</p><p><a target="_blank" rel="noopener" href="http://netty.io/">Netty</a> 是一个高性能、异步事件驱动的 NIO 框架，它提供了对 TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的，通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。</p><p>本文并不会详细的讨论的 Netty 框架的使用方法，关于其详细的使用方法，可以参考 <a target="_blank" rel="noopener" href="https://book.douban.com/subject/24700704/">Netty in Action</a> 一书，书中对 Netty 的相关原理和使用方法做了非常细致的讲解。本文虽然只会使用到 Netty 的一小部分特性，但是对于没有接触过 Netty 的读者来说，可以使其快速的了解 Netty 的整体结构，然后方便其对 Netty 的进一步学习。本文通过 Netty 构建了一个非常具有代表性的 IM 服务端（同时也说明本文并没有介绍 Netty 的客户端使用方法，有兴趣的读者可自行查阅），然后通过 WebSocket 协议从而实现了一个在线聊天系统。</p><p>1.2 通过 Netty 构建一个 WebSocket 服务器</p><p>我们把一个 Netty 服务分为三部分（分别对应了 3 个 Java 类）来讲：</p><ul><li>ServerBootStrap</li><li>ChannelInitializer</li><li>Handler</li></ul><ol><li><p>ServerBootStrap，用于启动一个 Netty 服务，执行了监听端口、获取请求等等这样的操作；具体实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WebSocketServer</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">WebSocketServerInitializer</span>()) <span class="comment">// 创建了 WebSocketServerInitializer</span></span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">             .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;WebSocketServer 启动了&quot;</span> + port);</span><br><span class="line">    		</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(port).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;WebSocketServer 关闭了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> port;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            port = <span class="number">8080</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">WebSocketServer</span>(port).run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ChannelInitializer，看它的名字就知道它是一个和初始化有关的类。确实，它是用来初始化 ChannelPipeline，并且向其中加入各种我们需要用到的 Channel 的；具体实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServerInitializer</span> <span class="keyword">extends</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">64</span>*<span class="number">1024</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/ws&quot;</span>));</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketFrameHandler</span>()); <span class="comment">// 使用了 WebSocketFrameHandler 来对 Channel 进行处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第 2 条中提到了 Channel 的概念，其实你可以把 Channel 看做成一个连接，多个 Channel 就会构成一个 ChannelGroup。我们在这里定义了一个 Handler 管理这些 Channle，Handler 本身会包含了各种回调函数，比如 read、added、removed 等等，当事件发生时，就会触发这些函数的执行，从而实现管理 Channle 的目的。具体实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;TextWebSocketFrame&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">ChannelGroup</span> <span class="variable">channels</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelGroup</span>(GlobalEventExecutor.INSTANCE); <span class="comment">// 这里存储了所有的 Channel</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">incoming</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != incoming)&#123;</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;[&quot;</span> + incoming.remoteAddress() + <span class="string">&quot;]&quot;</span> + msg.text()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;[you]&quot;</span> + msg.text() ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">incoming</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Broadcast a message to multiple Channels</span></span><br><span class="line">        channels.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;[SERVER] - &quot;</span> + incoming.remoteAddress() + <span class="string">&quot; 加入&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        channels.add(incoming);</span><br><span class="line">        System.out.println(<span class="string">&quot;Client:&quot;</span>+incoming.remoteAddress() +<span class="string">&quot;加入&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">incoming</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Broadcast a message to multiple Channels</span></span><br><span class="line">        channels.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;[SERVER] - &quot;</span> + incoming.remoteAddress() + <span class="string">&quot; 离开&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Client:&quot;</span>+incoming.remoteAddress() +<span class="string">&quot;离开&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A closed Channel is automatically removed from ChannelGroup,</span></span><br><span class="line">        <span class="comment">// so there is no need to do &quot;channels.remove(ctx.channel());&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">incoming</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;Client:&quot;</span>+incoming.remoteAddress()+<span class="string">&quot;在线&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">incoming</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;Client:&quot;</span>+incoming.remoteAddress()+<span class="string">&quot;掉线&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span>	<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">incoming</span> <span class="operator">=</span> ctx.channel();</span><br><span class="line">        System.out.println(<span class="string">&quot;Client:&quot;</span>+incoming.remoteAddress()+<span class="string">&quot;异常&quot;</span>);</span><br><span class="line">        <span class="comment">// 当出现异常就关闭连接</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过以上这三个类，我们已经构建好了一个 WebSocket 服务器，可以用于与浏览器进行 WebSocket 连接并且通信了，<a target="_blank" rel="noopener" href="https://github.com/RitterHou/WebSocket/tree/master/netty">完整的代码</a>在 GitHub 上可以找到。</p><h3 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h3><p>2.1 WebSocket 简介</p><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WebSocket">WebSocket</a> 协议是作为一种对 HTTP 协议的补充而提出来的。因为 HTTP 协议的无状态特性，导致服务器无法主动的向客户端进行消息推送，如果我们想要实现一个网页聊天功能，在以前，就必须要由客户端不断的向服务器进行轮询，通过这种不断发送请求的方式来检查服务器是否有新消息发送。显而易见，这种方式十分低效并且浪费资源。</p><p>WebSocket 并不依赖于 HTTP 来实现，他们相互独立。WebSocket 是一种在 TCP 上直接进行全双工通讯的协议，它是有连接的。</p><p>如果想要与服务器进行 WbeSocket 连接，客户端需要先在某一个 HTTP 请求中显示的发送一个 WebSocket 连接请求，服务器收到请求后，会发出一个回应，然后与客户端构建一个 WebSocket 连接，这个过程通常称为“握手”。“握手”成功之后，客户端和服务器就可以通过已经构建好的这个 WebSocket 连接进行通讯了，这个通讯是有链接的。此外，这个 WebSocket 的连接不会对接下来的客户端与服务器其他的 HTTP 请求产生任何影响。</p><p>下图是一个客户端请求 WebSocket 连接以及服务器返回的相应的响应数据，着重观察红色方框中的内容，它表示了一个 HTTP 请求是如何升级为一个 WebSocket 的：</p><p><img src="/images/20161022/20161022122020.png"></p><p>2.2 使用 Nginx 搭建一个静态文件服务器并设置反向代理</p><p>想要实现 WebSocket 需要浏览器的支持，不过现代浏览器已经都支持了这一项特性。接下来我们通过 Nginx 来搭建一个 Web 服务器用来存放静态的聊天网页并且对 WebSocket 的链接进行反向代理，配置如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        </span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  127.0.0.1;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /home/html;</span><br><span class="line">        index  index.html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /ws &#123;</span><br><span class="line">        proxy_pass           http://127.0.0.1:8080;</span><br><span class="line">        proxy_http_version   1.1;</span><br><span class="line">        proxy_read_timeout   300s; # Nginx 的 WebSocket 超时配置，默认 60s 自动断开链接  </span><br><span class="line">        proxy_set_header     Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header     Connection &quot;upgrade&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>我们部署了一个服务监听在 80 端口，然后这个 Web 服务器会默认打开 index.html 页面，这个就是我们接下来在前台通过 JavaScript 实现 WebSocket 功能的前台聊天页面，具体实现会在下面详细说明；</li><li>第二个 location 是对路径为 &#x2F;ws 的请求进行了反向代理，这个对应的就是 WebSocket 的连接。可以看到，此链接被反向代理到 8080 端口，也就是上面我们所写的 Netty 服务器所运行的端口，至于路径为什么是 &#x2F;ws 我会在下面进行解释。另外的三个代理参数表示了这个代理的连接是一个 HTTP 的升级连接，在这里就是 WebSocket 连接。</li></ol><p>2.3 JavaScript 实现 WebSocket 客户端</p><p>浏览器内部可以通过 js 来实现 WebSocket 的相关操作，具体实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">WebSocket</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">WebSocket</span> = <span class="variable language_">window</span>.<span class="property">MozWebSocket</span>; <span class="comment">// 如果浏览器不支持 WebSocket，那就使用 MozWebSocket</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> socket; <span class="comment">// 定义一个连接</span></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebSocket</span>) &#123;</span><br><span class="line">    socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://127.0.0.1/ws&quot;</span>); <span class="comment">// 打开一个新的连接</span></span><br><span class="line">    socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; <span class="comment">// 收到信息的回调函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到信息：&#x27;</span> + event.<span class="property">data</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; <span class="comment">// 连接打开的回调函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接开启！&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    socket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; <span class="comment">// 连接关闭的函数函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;连接关闭！&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;你的浏览器不支持 WebSocket！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">send</span>(<span class="params">message</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">WebSocket</span>) &#123; <span class="comment">// 若不支持 WebSocket，不执行发送操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (socket.<span class="property">readyState</span> == <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>) &#123; <span class="comment">// 如果连接已打开，执行发送操作</span></span><br><span class="line">        socket.<span class="title function_">send</span>(message);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;连接没有开启.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看上面的第 6 行代码，我所设置的请求连接地址为<code>ws://127.0.0.1/ws</code>，第一个 ws 定义了使用 WebSocket 协议，第二个 ws 就和上面的 Nginx 中路径匹配相对应起来了，也就是对 &#x2F;ws 路径进行反向代理操作。点击<a target="_blank" rel="noopener" href="https://github.com/RitterHou/WebSocket/tree/master/html">这里</a>可以看到完整的前台页面实现代码。</p></div><div class="post-copyright"><div><strong>本文链接：</strong> <span title="使用 Netty 与 Nginx 构建一个在线聊天网页">https://www.nosuchfield.com/2016/10/22/Use-Netty-and-Nginx-to-build-an-online-chat-page/</span></div><div><strong>版权声明： </strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处！</div></div><style>summary{cursor:pointer;margin-bottom:10px}summary:focus{outline:0}</style><script src="/js/code-enhancer.js"></script><script src="/js/pangu.min.js"></script><script>pangu.spacingPage()</script><script>function backToTop(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script><script defer src="https://cloud.umami.is/script.js" data-website-id="267e4aaf-8cb5-464d-b16c-89e66283e505"></script><div class="post-footer"><ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag">网络编程</a></li></ul><span onclick="backToTop()" class="top">返回顶部</span></div></article><footer><span>&copy; 2015 - 2025</span> <span class="author">Raymond</span> <span style="float:right"><span class="upyun">本网站由<a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"> <img src="/images/others/upyun.png"></a>提供CDN加速&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> <a class="filing" href="https://beian.miit.gov.cn/" target="_blank">苏ICP备15057335号</a> <a class="github" href="https://github.com/RitterHou" target="_blank">GitHub</a></span></footer></div></body></html>